var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
    };
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.NodeBase = NodeBase;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// ../../node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var Node = require_Node();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        visitor = Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      if (Node.isDocument(node)) {
        const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        _visit(null, node, visitor, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function _visit(key, node, visitor, path) {
      let ctrl = void 0;
      if (typeof visitor === "function")
        ctrl = visitor(key, node, path);
      else if (Node.isMap(node)) {
        if (visitor.Map)
          ctrl = visitor.Map(key, node, path);
      } else if (Node.isSeq(node)) {
        if (visitor.Seq)
          ctrl = visitor.Seq(key, node, path);
      } else if (Node.isPair(node)) {
        if (visitor.Pair)
          ctrl = visitor.Pair(key, node, path);
      } else if (Node.isScalar(node)) {
        if (visitor.Scalar)
          ctrl = visitor.Scalar(key, node, path);
      } else if (Node.isAlias(node)) {
        if (visitor.Alias)
          ctrl = visitor.Alias(key, node, path);
      }
      if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        const parent = path[path.length - 1];
        if (Node.isCollection(parent)) {
          parent.items[key] = ctrl;
        } else if (Node.isPair(parent)) {
          if (key === "key")
            parent.key = ctrl;
          else
            parent.value = ctrl;
        } else if (Node.isDocument(parent)) {
          parent.contents = ctrl;
        } else {
          const pt = Node.isAlias(parent) ? "alias" : "scalar";
          throw new Error(`Cannot replace node with ${pt} parent`);
        }
        return _visit(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (Node.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = _visit(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (Node.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = _visit("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = _visit("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    exports.visit = visit;
  }
});

// ../../node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var Node = require_Node();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class {
      constructor(yaml2, tags) {
        this.marker = null;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length < 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              onError(6, `Unsupported YAML version ${version}`, true);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix)
          return prefix + decodeURIComponent(suffix);
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (Node.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// ../../node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var Node = require_Node();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = new Map();
      let prevAnchors = null;
      return {
        onAnchor(source) {
          aliasObjects.push(source);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        setAnchors() {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// ../../node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var Node = require_Node();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(Node.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        const data = anchors2.get(source);
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (Node.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (Node.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (Node.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// ../../node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var Node = require_Node();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !Node.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !(ctx && ctx.keep))
        return Number(value);
      return value;
    }
    exports.toJS = toJS;
  }
});

// ../../node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(Node.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// ../../node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) || match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify && t.identify(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      var _a, _b;
      if (Node.isNode(value))
        return value;
      if (Node.isPair(value)) {
        const map = (_b = (_a = ctx.schema[Node.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return new Scalar.Scalar(value);
        tagObj = value instanceof Map ? schema[Node.MAP] : Symbol.iterator in Object(value) ? schema[Node.SEQ] : schema[Node.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      if (ref)
        ref.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// ../../node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, typeof k === "symbol" ? k : String(k), {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return createNode.createNode(v, void 0, {
        onAnchor() {
          throw new Error("Repeated objects are not supported here");
        },
        schema,
        sourceObjects: new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (Node.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (Node.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && Node.isScalar(node) ? node.value : node;
        else
          return Node.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!Node.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return Node.isCollection(node) ? node.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (Node.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// ../../node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i) {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx) => ({
      indentAtStart: ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, ctx.options.lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${start}${value}${end}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      var _a;
      const { type, value } = item;
      const { actualString, implicitKey, indent, inFlow } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        const hasDouble = value.indexOf('"') !== -1;
        const hasSingle = value.indexOf("'") !== -1;
        let quotedString;
        if (hasDouble && !hasSingle) {
          quotedString = singleQuotedString;
        } else if (hasSingle && !hasDouble) {
          quotedString = doubleQuotedString;
        } else if (ctx.options.singleQuote) {
          quotedString = singleQuotedString;
        } else {
          quotedString = doubleQuotedString;
        }
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        for (const tag of ctx.doc.schema.tags) {
          if (tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))
            return doubleQuotedString(value, ctx);
        }
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? doubleQuotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// ../../node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var Node = require_Node();
    var stringifyString = require_stringifyString();
    var createStringifyContext = (doc, options) => ({
      anchors: new Set(),
      doc,
      indent: "",
      indentStep: typeof options.indent === "number" ? " ".repeat(options.indent) : "  ",
      options: Object.assign({
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: false,
        trueStr: "true",
        verifyAliasOrder: true
      }, options)
    });
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) || match[0];
      }
      let tagObj = void 0;
      let obj;
      if (Node.isScalar(item)) {
        obj = item.value;
        const match = tags.filter((t) => t.identify && t.identify(obj));
        tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      const props = [];
      const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      if (node.tag) {
        props.push(doc.directives.tagString(node.tag));
      } else if (!tagObj.default) {
        props.push(doc.directives.tagString(tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (Node.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (Node.isAlias(item))
        return item.toString(ctx);
      let tagObj = void 0;
      const node = Node.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : Node.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return Node.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (comment, indent) => /^\n+$/.test(comment) ? comment.substring(1) : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);
    function addComment(str, indent, comment) {
      return !comment ? str : comment.includes("\n") ? `${str}
` + stringifyComment(comment, indent) : str.endsWith(" ") ? `${str}#${comment}` : `${str} #${comment}`;
    }
    exports.addComment = addComment;
    exports.stringifyComment = stringifyComment;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;
      let keyComment = Node.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (Node.isCollection(key)) {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || Node.isCollection(key) || (Node.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        if (keyCommentDone)
          keyComment = null;
        if (chompKeep && !keyComment && onChompKeep)
          onChompKeep();
        return stringifyComment.addComment(`? ${str}`, ctx.indent, keyComment);
      }
      if (keyCommentDone)
        keyComment = null;
      str = explicitKey ? `? ${stringifyComment.addComment(str, ctx.indent, keyComment)}
${indent}:` : stringifyComment.addComment(`${str}:`, ctx.indent, keyComment);
      let vcb = "";
      let valueComment = null;
      if (Node.isNode(value)) {
        if (value.spaceBefore)
          vcb = "\n";
        if (value.commentBefore)
          vcb += `
${stringifyComment.stringifyComment(value.commentBefore, ctx.indent)}`;
        valueComment = value.comment;
      } else if (value && typeof value === "object") {
        value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && Node.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && Node.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substr(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (vcb || keyComment) {
        ws = `${vcb}
${ctx.indent}`;
      } else if (!explicitKey && Node.isCollection(value)) {
        const flow = valueStr[0] === "[" || valueStr[0] === "{";
        if (!flow || valueStr.includes("\n"))
          ws = `
${ctx.indent}`;
      } else if (valueStr[0] === "\n")
        ws = "";
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
        return str + ws + valueStr;
      } else {
        if (valueCommentDone)
          valueComment = null;
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return stringifyComment.addComment(str + ws + valueStr, ctx.indent, valueComment);
      }
    }
    exports.stringifyPair = stringifyPair;
  }
});

// ../../node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug;
    exports.warn = warn;
  }
});

// ../../node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log = require_log();
    var stringify = require_stringify();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map, { key, value }) {
      if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
        if (Node.isSeq(value))
          for (const it of value.items)
            mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
          for (const it of value)
            mergeToJSMap(ctx, map, it);
        else
          mergeToJSMap(ctx, map, value);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    var isMergeKey = (key) => key === MERGE_KEY || Node.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map, value) {
      const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : null;
      if (!Node.isMap(source))
        throw new Error("Merge sources must be map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (Node.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// ../../node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var Node = require_Node();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class {
      constructor(key, value = null) {
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
        this.key = key;
        this.value = value;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// ../../node_modules/yaml/dist/options.js
var require_options = __commonJS({
  "../../node_modules/yaml/dist/options.js"(exports) {
    "use strict";
    var defaultOptions = {
      intAsBigInt: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    };
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var Collection = require_Collection();
    var Node = require_Node();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, indentStep } = ctx;
      const inFlow = flow || ctx.inFlow;
      if (inFlow)
        itemIndent += indentStep;
      ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });
      let singleLineOutput = true;
      let chompKeep = false;
      const nodes = items.reduce((nodes2, item, i) => {
        let comment2 = null;
        if (Node.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            nodes2.push({ comment: true, str: "" });
          let cb = item.commentBefore;
          if (cb && chompKeep)
            cb = cb.replace(/^\n+/, "");
          if (cb) {
            if (/^\n+$/.test(cb))
              cb = cb.substring(1);
            for (const line of cb.match(/^.*$/gm)) {
              const str3 = line === " " ? "#" : line ? `#${line}` : "";
              nodes2.push({ comment: true, str: str3 });
            }
          }
          if (item.comment) {
            comment2 = item.comment;
            singleLineOutput = false;
          }
        } else if (Node.isPair(item)) {
          const ik = Node.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              nodes2.push({ comment: true, str: "" });
            let cb = ik.commentBefore;
            if (cb && chompKeep)
              cb = cb.replace(/^\n+/, "");
            if (cb) {
              if (/^\n+$/.test(cb))
                cb = cb.substring(1);
              for (const line of cb.match(/^.*$/gm)) {
                const str3 = line === " " ? "#" : line ? `#${line}` : "";
                nodes2.push({ comment: true, str: str3 });
              }
            }
            if (ik.comment)
              singleLineOutput = false;
          }
          if (inFlow) {
            const iv = Node.isNode(item.value) ? item.value : null;
            if (iv) {
              if (iv.comment)
                comment2 = iv.comment;
              if (iv.comment || iv.commentBefore)
                singleLineOutput = false;
            } else if (item.value == null && ik && ik.comment) {
              comment2 = ik.comment;
            }
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, ctx, () => comment2 = null, () => chompKeep = true);
        if (inFlow && i < items.length - 1)
          str2 += ",";
        str2 = stringifyComment.addComment(str2, itemIndent, comment2);
        if (chompKeep && (comment2 || inFlow))
          chompKeep = false;
        nodes2.push({ comment: false, str: str2 });
        return nodes2;
      }, []);
      let str;
      if (nodes.length === 0) {
        str = flowChars.start + flowChars.end;
      } else if (inFlow) {
        const { start, end } = flowChars;
        const strings = nodes.map((n) => n.str);
        let singleLineLength = 2;
        for (const node of nodes) {
          if (node.comment || node.str.includes("\n")) {
            singleLineOutput = false;
            break;
          }
          singleLineLength += node.str.length + 2;
        }
        if (!singleLineOutput || singleLineLength > Collection.Collection.maxFlowStringSingleLineLength) {
          str = start;
          for (const s of strings) {
            str += s ? `
${indentStep}${indent}${s}` : "\n";
          }
          str += `
${indent}${end}`;
        } else {
          str = `${start} ${strings.join(" ")} ${end}`;
        }
      } else {
        const strings = nodes.map(blockItem);
        str = strings.shift() || "";
        for (const s of strings)
          str += s ? `
${indent}${s}` : "\n";
      }
      if (comment) {
        str += "\n" + stringifyComment.stringifyComment(comment, indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = Node.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (Node.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (Node.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      constructor(schema) {
        super(Node.MAP, schema);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      add(pair, overwrite) {
        let _pair;
        if (Node.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && Node.isScalar(node) ? node.value : node;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!Node.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItem: (n) => n.str,
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// ../../node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    function createMap(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map2 = new YAMLMap.YAMLMap(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== void 0 || keepUndefined)
          map2.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map = {
      collection: "map",
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!Node.isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
    exports.map = map;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      constructor(schema) {
        super(Node.SEQ, schema);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && Node.isScalar(it) ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (Node.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItem: (n) => n.comment ? n.str : `- ${n.str}`,
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
    };
    function asItemIndex(key) {
      let idx = Node.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// ../../node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var Node = require_Node();
    var YAMLSeq = require_YAMLSeq();
    function createSeq(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new YAMLSeq.YAMLSeq(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq2.items.push(createNode.createNode(it, void 0, ctx));
        }
      }
      return seq2;
    }
    var seq = {
      collection: "seq",
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!Node.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      }
    };
    exports.seq = seq;
  }
});

// ../../node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../../node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string;
  }
});

// ../../node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// ../../node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// ../../node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify: ({ value }) => Number(value).toExponential()
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (Node.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (Node.isPair(item))
            continue;
          else if (Node.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value || pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else
              throw new TypeError(`Expected { key: value } tuple: ${it}`);
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var toJS = require_toJS();
    var Node = require_Node();
    var YAMLMap = require_YAMLMap();
    var pairs = require_pairs();
    var YAMLOMap = class extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (Node.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (Node.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new YAMLOMap();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify: ({ value }) => Number(value).toExponential()
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (Node.isPair(key))
          pair = key;
        else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && Node.isPair(pair) ? Node.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve(map, onError) {
        if (Node.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      },
      createNode(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new YAMLSet(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = {
      core: schema.schema,
      failsafe: [map.map, seq.seq, string.string],
      json: schema$1.schema,
      yaml11: schema$2.schema,
      "yaml-1.1": schema$2.schema
    };
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas[schemaName];
      if (!tags) {
        const keys = Object.keys(schemas).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string")
          return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      });
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// ../../node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var Node = require_Node();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class {
      constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {
        this.merge = !!merge;
        this.name = schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        Object.defineProperty(this, Node.MAP, { value: map.map });
        Object.defineProperty(this, Node.SCALAR, { value: string.string });
        Object.defineProperty(this, Node.SEQ, { value: seq.seq });
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
      }
    };
    exports.Schema = Schema;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var Node = require_Node();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.marker)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        lines.unshift(stringifyComment.stringifyComment(doc.commentBefore, ""));
      }
      const ctx = stringify.createStringifyContext(doc, options);
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (Node.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore)
            lines.push(stringifyComment.stringifyComment(doc.contents.commentBefore, ""));
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body = stringifyComment.addComment(body, "", contentComment);
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.stringifyComment(dc, ""));
      }
      return lines.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// ../../node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// ../../node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var Node = require_Node();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var options = require_options();
    var Schema = require_Schema();
    var stringify = require_stringify();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class {
      constructor(value, replacer, options$1) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options$1 === void 0 && replacer) {
          options$1 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({}, options.defaultOptions, options$1);
        this.options = opt;
        let { version } = opt;
        if (options$1 === null || options$1 === void 0 ? void 0 : options$1.directives) {
          this.directives = options$1.directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options$1);
        if (value === void 0)
          this.contents = null;
        else {
          this.contents = this.createNode(value, _replacer, options$1);
        }
      }
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options2) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const { anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 || {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
        const ctx = {
          keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && Node.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      createPair(key, value, options2 = {}) {
        const k = this.createNode(key, null, options2);
        const v = this.createNode(value, null, options2);
        return new Pair.Pair(k, v);
      }
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      get(key, keepScalar) {
        return Node.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && Node.isScalar(this.contents) ? this.contents.value : this.contents;
        return Node.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return Node.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (Collection.isEmptyPath(path))
          return this.contents !== void 0;
        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      setIn(path, value) {
        if (Collection.isEmptyPath(path))
          this.contents = value;
        else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      setSchema(version, options2) {
        let _options;
        switch (String(version)) {
          case "1.1":
            this.directives.yaml.version = "1.1";
            _options = Object.assign({ merge: true, resolveKnownTags: false, schema: "yaml-1.1" }, options2);
            break;
          case "1.2":
            this.directives.yaml.version = "1.2";
            _options = Object.assign({ merge: false, resolveKnownTags: true, schema: "core" }, options2);
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);
          }
        }
        this.schema = new Schema.Schema(_options);
      }
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
          stringify: stringify.stringify
        };
        const res = toJS.toJS(this.contents, jsonArg || "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      toString(options2 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
          const s = JSON.stringify(options2.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options2);
      }
    };
    function assertCollection(contents) {
      if (Node.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// ../../node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../../node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let anchor = null;
      let tag = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        switch (token.type) {
          case "space":
            if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
              onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            anchor = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            found = token;
            atNewline = false;
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        end,
        start: start !== null && start !== void 0 ? start : end
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// ../../node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// ../../node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var Node = require_Node();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || Node.isScalar(a) && Node.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
      var _a;
      const map = new YAMLMap.YAMLMap(ctx.schema);
      let offset = bm.offset;
      for (const { start, key, sep, value } of bm.items) {
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
          offset,
          onError,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
        } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
        if (implicitKey && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep || [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          offset = valueNode.range[2];
          map.items.push(new Pair.Pair(keyNode, valueNode));
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          map.items.push(new Pair.Pair(keyNode));
        }
      }
      map.range = [bm.offset, offset, offset];
      return map;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
      const seq = new YAMLSeq.YAMLSeq(ctx.schema);
      let offset = bs.offset;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          startOnNewline: true
        });
        offset = props.end;
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, offset, start, null, props, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const coll = isMap ? new YAMLMap.YAMLMap(ctx.schema) : new YAMLSeq.YAMLSeq(ctx.schema);
      coll.flow = true;
      let offset = fc.offset;
      for (let i = 0; i < fc.items.length; ++i) {
        const { start, key, sep, value } = fc.items[i];
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
          offset,
          onError,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st of start) {
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (Node.isPair(prev))
                prev = prev.value || prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          const valueProps = resolveProps.resolveProps(sep || [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        onError(offset + 1, "MISSING_CHAR", `Expected ${fcName} to end with ${expectedEnd}`);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function composeCollection(CN, ctx, token, tagToken, onError) {
      let coll;
      switch (token.type) {
        case "block-map": {
          coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
          break;
        }
        case "block-seq": {
          coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
          break;
        }
        case "flow-collection": {
          coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
          break;
        }
      }
      if (!tagToken)
        return coll;
      const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (!tagName)
        return coll;
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      const expType = Node.isMap(coll) ? "map" : "seq";
      let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          coll.tag = tagName;
          return coll;
        }
      }
      const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
      const node = Node.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag === null || tag === void 0 ? void 0 : tag.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(scalar, strict, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (!scalar.source || chompStart === 0) {
        const value2 = header.chomp === "+" ? lines.map((line) => line[0]).join("\n") : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          break;
        }
        offset += indent.length + content.length + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let message = "";
      switch (source[0]) {
        case "	":
          message = "Plain value cannot start with a tab character";
          break;
        case "|":
        case ">": {
          message = `Plain value cannot start with block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          message = `Plain value cannot start with reserved character ${source[0]}`;
          break;
        }
      }
      if (message)
        onError(0, "BAD_SCALAR_START", message);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match && match[1] || "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n")
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : findScalarTagByTest(ctx.schema, value, token.type === "scalar");
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        onError(tagToken || token, "TAG_RESOLVE_FAILED", error.message);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      var _a;
      if (tagName === "!")
        return schema[Node.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[Node.SCALAR];
    }
    function findScalarTagByTest(schema, value, apply) {
      var _a;
      if (apply) {
        for (const tag of schema.tags) {
          if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))
            return tag;
        }
      }
      return schema[Node.SCALAR];
    }
    exports.composeScalar = composeScalar;
  }
});

// ../../node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default:
          console.log(token);
          throw new Error(`Unsupporten token type: ${token.type}`);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment)
        node.comment = comment;
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// ../../node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value || (end === null || end === void 0 ? void 0 : end[0]),
        offset,
        onError,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.marker = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// ../../node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var Node = require_Node();
    var options = require_options();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1][0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options$1 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({
          version: options$1.version || options.defaultOptions.version
        });
        this.options = options$1;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.marker || !dc) {
            doc.commentBefore = comment;
          } else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (Node.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      *next(token) {
        if (process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.marker)
              this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// ../../node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      var _a;
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { lineWidth: -1 }
      });
      const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// ../../node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item && item[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent && parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports.visit = visit;
  }
});

// ../../node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// ../../node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var invalidFlowScalarChars = [",", "[", "]", "{", "}"];
    var invalidIdentifierChars = [" ", ",", "[", "]", "{", "}", "\n", "\r", "	"];
    var isNotIdentifierChar = (ch) => !ch || invalidIdentifierChars.includes(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.next = null;
        this.pos = 0;
      }
      *lex(source, incomplete = false) {
        if (source)
          this.buffer = this.buffer ? this.buffer + source : source;
        this.atEnd = !incomplete;
        let next = this.next || "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.buffer.indexOf("\n", this.pos);
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotIdentifierChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          sp = yield* this.pushSpaces(true);
          if (nl > 0)
            this.indentValue = indent = sp;
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",")
          n += (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotIdentifierChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        let nl = this.buffer.indexOf("\n", this.pos);
        if (nl !== -1 && nl < end) {
          while (nl !== -1 && nl < end) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          }
          if (nl !== -1 && nl < end) {
            end = nl - 1;
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch2 = this.buffer[i];
            if (ch2 === "\r")
              ch2 = this.buffer[--i];
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i];
            if (ch2 === "\n" && i >= this.pos)
              nl = i;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i;
          } else if (isEmpty(ch)) {
            const next = this.buffer[i + 1];
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
              } else
                end = i;
            }
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            if (this.charAt(1) === "<")
              return (yield* this.pushVerbatimTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotIdentifierChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case ":":
          case "?":
          case "-":
            if (isEmpty(this.charAt(1))) {
              if (this.flowLevel === 0)
                this.indentNext = this.indentValue + 1;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
        }
        return 0;
      }
      *pushVerbatimTag() {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// ../../node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// ../../node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function includesNonEmpty(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return true;
        }
      }
      return false;
    }
    function isFlowToken(token) {
      switch (token === null || token === void 0 ? void 0 : token.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep || it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      var _a;
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        while (--i >= 0) {
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error || this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar" || token.type === "flow-collection")
            token.indent = "indent" in top ? top.indent : -1;
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (includesNonEmpty(doc.start)) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        var _a;
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              map.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map.indent && (it.sep || includesNonEmpty(it.start));
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                map.items.push({ start: [this.sourceToken] });
                this.onKeyLine = true;
              } else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
                it.start.push(this.sourceToken);
              else if (atNextItem || it.value)
                map.items.push({ start: [this.sourceToken] });
              else
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (!it.sep)
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (includesToken(it.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key, delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key, sep }]
                });
              } else
                it.sep.push(this.sourceToken);
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start: [], key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
                  map.items.push({ start: [] });
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        var _a;
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// ../../node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log = require_log();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = !options || options.prettyErrors !== false;
      const lineCounter$1 = options && options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options || replacer || {};
        if (!keepUndefined)
          return void 0;
      }
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports.parse = parse;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var options = require_options();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = Node.isAlias;
    exports.isCollection = Node.isCollection;
    exports.isDocument = Node.isDocument;
    exports.isMap = Node.isMap;
    exports.isNode = Node.isNode;
    exports.isPair = Node.isPair;
    exports.isScalar = Node.isScalar;
    exports.isSeq = Node.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.defaultOptions = options.defaultOptions;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
  }
});

// ../noodl-aggregator/dist/index.js
var require_dist2 = __commonJS({
  "../noodl-aggregator/dist/index.js"(exports) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target, all) => {
      __markAsModule2(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport2 = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames2(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc2(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule2 = (module22) => {
      return __reExport2(__markAsModule2(__defProp2(module22 != null ? __create2(__getProtoOf2(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var require_dist3 = __commonJS2({
      "node_modules/@jsmanifest/utils/dist/index.js"(exports2) {
        var __defProp22 = Object.defineProperty;
        var __markAsModule22 = (target) => __defProp22(target, "__esModule", { value: true });
        var __export22 = (target, all) => {
          for (var name in all)
            __defProp22(target, name, { get: all[name], enumerable: true });
        };
        __markAsModule22(exports2);
        __export22(exports2, {
          array: () => array,
          arrayEach: () => arrayEach,
          assign: () => assign2,
          black: () => black,
          blink: () => blink,
          blue: () => blue,
          bold: () => bold,
          callAll: () => callAll,
          createMap: () => createMap,
          cyan: () => cyan,
          dim: () => dim,
          divider: () => divider,
          eachEntries: () => eachEntries,
          entries: () => entries,
          getRandomKey: () => getRandomKey,
          green: () => green,
          hidden: () => hidden,
          inspect: () => inspect,
          isArr: () => isArr2,
          isBool: () => isBool,
          isFnc: () => isFnc2,
          isMap: () => isMap,
          isNil: () => isNil,
          isNull: () => isNull,
          isNum: () => isNum,
          isObj: () => isObj,
          isSet: () => isSet,
          isStr: () => isStr2,
          isUnd: () => isUnd,
          italic: () => italic,
          keys: () => keys,
          log: () => log2,
          magenta: () => magenta,
          newline: () => newline,
          red: () => red2,
          reduce: () => reduce,
          reverse: () => reverse,
          spread: () => spread,
          underscore: () => underscore,
          values: () => values,
          white: () => white,
          withTag: () => withTag,
          yellow: () => yellow
        });
        var divider = "----------------------------------------------------------";
        function array(val) {
          return isArr2(val) ? val : [val];
        }
        function arrayEach(obj, fn) {
          array(obj).forEach(fn);
        }
        function assign2(v, ...rest) {
          return Object.assign(v, ...rest);
        }
        function callAll(...fns) {
          function onFunc(...args) {
            fns.forEach((fn) => fn == null ? void 0 : fn(...args));
          }
          return onFunc;
        }
        function createMap(defaultValue) {
          return new Map([...entries(defaultValue)]);
        }
        function entries(v) {
          return isObj(v) ? Object.entries(v) : [];
        }
        function eachEntries(obj, fn) {
          if (obj) {
            let isBreak = false;
            if (obj instanceof Map) {
              for (const [key, value] of obj) {
                fn(key, value, () => isBreak = true);
                if (isBreak)
                  break;
              }
            } else if (isObj(obj)) {
              for (const [k, v] of entries(obj)) {
                fn(k, v, () => isBreak = true);
                if (isBreak)
                  break;
              }
            }
          }
        }
        function isArr2(v) {
          return Array.isArray(v);
        }
        function isBool(v) {
          return typeof v === "boolean";
        }
        function isMap(v) {
          return isObj(v) && v instanceof Map;
        }
        function isObj(v) {
          return !!v && !isArr2(v) && typeof v === "object";
        }
        function isNum(v) {
          return typeof v === "number";
        }
        function isSet(v) {
          return isObj(v) && v instanceof Set;
        }
        function isStr2(v) {
          return typeof v === "string";
        }
        function isUnd(v) {
          return typeof v === "undefined";
        }
        function isNull(v) {
          return v === null;
        }
        function isNil(v) {
          return isNull(v) && isUnd(v);
        }
        function isFnc2(v) {
          return typeof v === "function";
        }
        function keys(v) {
          return isObj(v) ? Object.keys(v) : [];
        }
        function reduce(arr, fn, acc) {
          return arr.reduce(fn, acc);
        }
        function spread(fn) {
          function spreadArgs(keyVal) {
            return fn(...keyVal);
          }
          return spreadArgs;
        }
        function values(v) {
          return Object.values(v);
        }
        function getRandomKey() {
          return `_${Math.random().toString(36).substr(2, 9)}`;
        }
        var inspect = Symbol.for("nodejs.util.inspect.custom");
        var resetColorCode = "[0m";
        var createColorStr = (codePoint) => (s) => `[${codePoint}m${s}${resetColorCode}`;
        var log2 = console.log;
        var newline = () => log2("");
        var bold = createColorStr(1);
        var black = createColorStr(30);
        var blink = createColorStr(5);
        var blue = createColorStr(34);
        var cyan = createColorStr(36);
        var dim = createColorStr(2);
        var green = createColorStr(32);
        var hidden = createColorStr(8);
        var italic = createColorStr(3);
        var magenta = createColorStr(35);
        var red2 = createColorStr(31);
        var reverse = createColorStr(7);
        var white = createColorStr(37);
        var withTag = (s, colorFunc = cyan) => `[${(colorFunc == null ? void 0 : colorFunc(s)) || s}]`;
        var yellow = createColorStr(33);
        var underscore = createColorStr(4);
      }
    });
    var require_dist22 = __commonJS2({
      "../noodl-common/dist/index.js"(exports2) {
        var __create22 = Object.create;
        var __defProp22 = Object.defineProperty;
        var __defProps2 = Object.defineProperties;
        var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
        var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
        var __getOwnPropNames22 = Object.getOwnPropertyNames;
        var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
        var __getProtoOf22 = Object.getPrototypeOf;
        var __hasOwnProp22 = Object.prototype.hasOwnProperty;
        var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
        var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
        var __spreadValues2 = (a, b) => {
          for (var prop in b || (b = {}))
            if (__hasOwnProp22.call(b, prop))
              __defNormalProp2(a, prop, b[prop]);
          if (__getOwnPropSymbols2)
            for (var prop of __getOwnPropSymbols2(b)) {
              if (__propIsEnum2.call(b, prop))
                __defNormalProp2(a, prop, b[prop]);
            }
          return a;
        };
        var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
        var __markAsModule22 = (target) => __defProp22(target, "__esModule", { value: true });
        var __commonJS22 = (cb, mod) => function __require() {
          return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
        };
        var __export22 = (target, all) => {
          __markAsModule22(target);
          for (var name in all)
            __defProp22(target, name, { get: all[name], enumerable: true });
        };
        var __reExport22 = (target, module22, desc) => {
          if (module22 && typeof module22 === "object" || typeof module22 === "function") {
            for (let key of __getOwnPropNames22(module22))
              if (!__hasOwnProp22.call(target, key) && key !== "default")
                __defProp22(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable });
          }
          return target;
        };
        var __toModule22 = (module22) => {
          return __reExport22(__markAsModule22(__defProp22(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
        };
        var __async2 = (__this, __arguments, generator) => {
          return new Promise((resolve, reject) => {
            var fulfilled = (value) => {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            };
            var rejected = (value) => {
              try {
                step(generator.throw(value));
              } catch (e) {
                reject(e);
              }
            };
            var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
            step((generator = generator.apply(__this, __arguments)).next());
          });
        };
        var require_dist5 = __commonJS22({
          "node_modules/@jsmanifest/utils/dist/index.js"(exports22) {
            var __defProp222 = Object.defineProperty;
            var __markAsModule222 = (target) => __defProp222(target, "__esModule", { value: true });
            var __export222 = (target, all) => {
              for (var name in all)
                __defProp222(target, name, { get: all[name], enumerable: true });
            };
            __markAsModule222(exports22);
            __export222(exports22, {
              array: () => array2,
              arrayEach: () => arrayEach,
              assign: () => assign2,
              black: () => black,
              blink: () => blink,
              blue: () => blue2,
              bold: () => bold,
              callAll: () => callAll,
              compose: () => compose,
              createMap: () => createMap,
              cyan: () => cyan2,
              dim: () => dim,
              divider: () => divider,
              eachEntries: () => eachEntries,
              entries: () => entries3,
              green: () => green2,
              hidden: () => hidden,
              inspect: () => inspect,
              isArr: () => isArr2,
              isBool: () => isBool,
              isBrowser: () => isBrowser,
              isFnc: () => isFnc2,
              isMap: () => isMap2,
              isNil: () => isNil,
              isNode: () => isNode,
              isNull: () => isNull,
              isNum: () => isNum,
              isObj: () => isObj2,
              isSet: () => isSet,
              isStr: () => isStr4,
              isUnd: () => isUnd,
              isWorker: () => isWorker,
              italic: () => italic2,
              keys: () => keys,
              log: () => log2,
              magenta: () => magenta2,
              newline: () => newline2,
              omit: () => omit,
              pick: () => pick,
              red: () => red22,
              reduce: () => reduce2,
              reverse: () => reverse,
              spread: () => spread,
              underscore: () => underscore,
              unixify: () => unixify,
              values: () => values,
              white: () => white2,
              withTag: () => withTag2,
              yellow: () => yellow2
            });
            var divider = "----------------------------------------------------------";
            function array2(val) {
              return isArr2(val) ? val : [val];
            }
            function arrayEach(obj, fn) {
              array2(obj).forEach(fn);
            }
            function assign2(v, ...rest) {
              return Object.assign(v, ...rest);
            }
            function callAll(...fns) {
              function onFunc(...args) {
                fns.forEach((fn) => fn == null ? void 0 : fn(...args));
              }
              return onFunc;
            }
            function compose(...fns) {
              return function(value) {
                return fns.reduceRight((acc, fn) => acc(fn(value)), (x) => x);
              };
            }
            function createMap(defaultValue) {
              return new Map([...entries3(defaultValue)]);
            }
            function entries3(v) {
              return isObj2(v) ? Object.entries(v) : [];
            }
            function eachEntries(obj, fn) {
              if (obj) {
                let isBreak = false;
                if (obj instanceof Map) {
                  for (const [key, value] of obj) {
                    fn(key, value, () => isBreak = true);
                    if (isBreak)
                      break;
                  }
                } else if (isObj2(obj)) {
                  for (const [k, v] of entries3(obj)) {
                    fn(k, v, () => isBreak = true);
                    if (isBreak)
                      break;
                  }
                }
              }
            }
            function isBrowser() {
              return typeof window !== "undefined" && typeof window.document !== "undefined";
            }
            function isNode() {
              return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
            }
            function isWorker() {
              return typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
            }
            function isArr2(v) {
              return Array.isArray(v);
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isMap2(v) {
              return isObj2(v) && v instanceof Map;
            }
            function isObj2(v) {
              return !!v && !isArr2(v) && typeof v === "object";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isSet(v) {
              return isObj2(v) && v instanceof Set;
            }
            function isStr4(v) {
              return typeof v === "string";
            }
            function isUnd(v) {
              return typeof v === "undefined";
            }
            function isNull(v) {
              return v === null;
            }
            function isNil(v) {
              return isNull(v) && isUnd(v);
            }
            function isFnc2(v) {
              return typeof v === "function";
            }
            function keys(v) {
              return isObj2(v) ? Object.keys(v) : [];
            }
            function omit(obj, _keys) {
              return reduce2(array2(_keys), (acc, key, _, collection) => {
                if (collection.includes(key))
                  return acc;
                acc[key] = obj[key];
                return acc;
              }, {});
            }
            function pick(obj, _keys) {
              return reduce2(array2(_keys), (acc, key, _, collection) => {
                if (collection.includes(key))
                  acc[key] = obj[key];
                return acc;
              }, {});
            }
            function reduce2(arr, fn, acc) {
              return arr.reduce(fn, acc);
            }
            function spread(fn) {
              function spreadArgs(keyVal) {
                return fn(...keyVal);
              }
              return spreadArgs;
            }
            function values(v) {
              return Object.values(v);
            }
            var inspect = Symbol.for("nodejs.util.inspect.custom");
            function unixify(filepath = "") {
              return filepath.replace(/\\/g, "/");
            }
            var resetColorCode = "[0m";
            var createColorStr = (codePoint) => (s) => `[${codePoint}m${s}${resetColorCode}`;
            var log2 = console.log;
            var newline2 = () => log2("");
            var bold = createColorStr(1);
            var black = createColorStr(30);
            var blink = createColorStr(5);
            var blue2 = createColorStr(34);
            var cyan2 = createColorStr(36);
            var dim = createColorStr(2);
            var green2 = createColorStr(32);
            var hidden = createColorStr(8);
            var italic2 = createColorStr(3);
            var magenta2 = createColorStr(35);
            var red22 = createColorStr(31);
            var reverse = createColorStr(7);
            var white2 = createColorStr(37);
            var withTag2 = (s, colorFunc = cyan2) => `[${(colorFunc == null ? void 0 : colorFunc(s)) || s}]`;
            var yellow2 = createColorStr(33);
            var underscore = createColorStr(4);
          }
        });
        var require_universalify = __commonJS22({
          "../../node_modules/universalify/index.js"(exports22) {
            "use strict";
            exports22.fromCallback = function(fn) {
              return Object.defineProperty(function(...args) {
                if (typeof args[args.length - 1] === "function")
                  fn.apply(this, args);
                else {
                  return new Promise((resolve, reject) => {
                    fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve(res));
                  });
                }
              }, "name", { value: fn.name });
            };
            exports22.fromPromise = function(fn) {
              return Object.defineProperty(function(...args) {
                const cb = args[args.length - 1];
                if (typeof cb !== "function")
                  return fn.apply(this, args);
                else
                  fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
              }, "name", { value: fn.name });
            };
          }
        });
        var require_polyfills = __commonJS22({
          "../../node_modules/graceful-fs/polyfills.js"(exports22, module22) {
            var constants2 = require("constants");
            var origCwd = process.cwd;
            var cwd = null;
            var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
            process.cwd = function() {
              if (!cwd)
                cwd = origCwd.call(process);
              return cwd;
            };
            try {
              process.cwd();
            } catch (er) {
            }
            if (typeof process.chdir === "function") {
              chdir = process.chdir;
              process.chdir = function(d) {
                cwd = null;
                chdir.call(process, d);
              };
              if (Object.setPrototypeOf)
                Object.setPrototypeOf(process.chdir, chdir);
            }
            var chdir;
            module22.exports = patch;
            function patch(fs3) {
              if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
                patchLchmod(fs3);
              }
              if (!fs3.lutimes) {
                patchLutimes(fs3);
              }
              fs3.chown = chownFix(fs3.chown);
              fs3.fchown = chownFix(fs3.fchown);
              fs3.lchown = chownFix(fs3.lchown);
              fs3.chmod = chmodFix(fs3.chmod);
              fs3.fchmod = chmodFix(fs3.fchmod);
              fs3.lchmod = chmodFix(fs3.lchmod);
              fs3.chownSync = chownFixSync(fs3.chownSync);
              fs3.fchownSync = chownFixSync(fs3.fchownSync);
              fs3.lchownSync = chownFixSync(fs3.lchownSync);
              fs3.chmodSync = chmodFixSync(fs3.chmodSync);
              fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
              fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
              fs3.stat = statFix(fs3.stat);
              fs3.fstat = statFix(fs3.fstat);
              fs3.lstat = statFix(fs3.lstat);
              fs3.statSync = statFixSync(fs3.statSync);
              fs3.fstatSync = statFixSync(fs3.fstatSync);
              fs3.lstatSync = statFixSync(fs3.lstatSync);
              if (!fs3.lchmod) {
                fs3.lchmod = function(path7, mode, cb) {
                  if (cb)
                    process.nextTick(cb);
                };
                fs3.lchmodSync = function() {
                };
              }
              if (!fs3.lchown) {
                fs3.lchown = function(path7, uid, gid, cb) {
                  if (cb)
                    process.nextTick(cb);
                };
                fs3.lchownSync = function() {
                };
              }
              if (platform === "win32") {
                fs3.rename = function(fs$rename) {
                  return function(from, to, cb) {
                    var start = Date.now();
                    var backoff = 0;
                    fs$rename(from, to, function CB(er) {
                      if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                        setTimeout(function() {
                          fs3.stat(to, function(stater, st) {
                            if (stater && stater.code === "ENOENT")
                              fs$rename(from, to, CB);
                            else
                              cb(er);
                          });
                        }, backoff);
                        if (backoff < 100)
                          backoff += 10;
                        return;
                      }
                      if (cb)
                        cb(er);
                    });
                  };
                }(fs3.rename);
              }
              fs3.read = function(fs$read) {
                function read(fd, buffer, offset, length, position, callback_) {
                  var callback;
                  if (callback_ && typeof callback_ === "function") {
                    var eagCounter = 0;
                    callback = function(er, _, __) {
                      if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
                      }
                      callback_.apply(this, arguments);
                    };
                  }
                  return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
                }
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(read, fs$read);
                return read;
              }(fs3.read);
              fs3.readSync = function(fs$readSync) {
                return function(fd, buffer, offset, length, position) {
                  var eagCounter = 0;
                  while (true) {
                    try {
                      return fs$readSync.call(fs3, fd, buffer, offset, length, position);
                    } catch (er) {
                      if (er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        continue;
                      }
                      throw er;
                    }
                  }
                };
              }(fs3.readSync);
              function patchLchmod(fs4) {
                fs4.lchmod = function(path7, mode, callback) {
                  fs4.open(path7, constants2.O_WRONLY | constants2.O_SYMLINK, mode, function(err, fd) {
                    if (err) {
                      if (callback)
                        callback(err);
                      return;
                    }
                    fs4.fchmod(fd, mode, function(err2) {
                      fs4.close(fd, function(err22) {
                        if (callback)
                          callback(err2 || err22);
                      });
                    });
                  });
                };
                fs4.lchmodSync = function(path7, mode) {
                  var fd = fs4.openSync(path7, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
                  var threw = true;
                  var ret;
                  try {
                    ret = fs4.fchmodSync(fd, mode);
                    threw = false;
                  } finally {
                    if (threw) {
                      try {
                        fs4.closeSync(fd);
                      } catch (er) {
                      }
                    } else {
                      fs4.closeSync(fd);
                    }
                  }
                  return ret;
                };
              }
              function patchLutimes(fs4) {
                if (constants2.hasOwnProperty("O_SYMLINK")) {
                  fs4.lutimes = function(path7, at, mt, cb) {
                    fs4.open(path7, constants2.O_SYMLINK, function(er, fd) {
                      if (er) {
                        if (cb)
                          cb(er);
                        return;
                      }
                      fs4.futimes(fd, at, mt, function(er2) {
                        fs4.close(fd, function(er22) {
                          if (cb)
                            cb(er2 || er22);
                        });
                      });
                    });
                  };
                  fs4.lutimesSync = function(path7, at, mt) {
                    var fd = fs4.openSync(path7, constants2.O_SYMLINK);
                    var ret;
                    var threw = true;
                    try {
                      ret = fs4.futimesSync(fd, at, mt);
                      threw = false;
                    } finally {
                      if (threw) {
                        try {
                          fs4.closeSync(fd);
                        } catch (er) {
                        }
                      } else {
                        fs4.closeSync(fd);
                      }
                    }
                    return ret;
                  };
                } else {
                  fs4.lutimes = function(_a, _b, _c, cb) {
                    if (cb)
                      process.nextTick(cb);
                  };
                  fs4.lutimesSync = function() {
                  };
                }
              }
              function chmodFix(orig) {
                if (!orig)
                  return orig;
                return function(target, mode, cb) {
                  return orig.call(fs3, target, mode, function(er) {
                    if (chownErOk(er))
                      er = null;
                    if (cb)
                      cb.apply(this, arguments);
                  });
                };
              }
              function chmodFixSync(orig) {
                if (!orig)
                  return orig;
                return function(target, mode) {
                  try {
                    return orig.call(fs3, target, mode);
                  } catch (er) {
                    if (!chownErOk(er))
                      throw er;
                  }
                };
              }
              function chownFix(orig) {
                if (!orig)
                  return orig;
                return function(target, uid, gid, cb) {
                  return orig.call(fs3, target, uid, gid, function(er) {
                    if (chownErOk(er))
                      er = null;
                    if (cb)
                      cb.apply(this, arguments);
                  });
                };
              }
              function chownFixSync(orig) {
                if (!orig)
                  return orig;
                return function(target, uid, gid) {
                  try {
                    return orig.call(fs3, target, uid, gid);
                  } catch (er) {
                    if (!chownErOk(er))
                      throw er;
                  }
                };
              }
              function statFix(orig) {
                if (!orig)
                  return orig;
                return function(target, options, cb) {
                  if (typeof options === "function") {
                    cb = options;
                    options = null;
                  }
                  function callback(er, stats) {
                    if (stats) {
                      if (stats.uid < 0)
                        stats.uid += 4294967296;
                      if (stats.gid < 0)
                        stats.gid += 4294967296;
                    }
                    if (cb)
                      cb.apply(this, arguments);
                  }
                  return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
                };
              }
              function statFixSync(orig) {
                if (!orig)
                  return orig;
                return function(target, options) {
                  var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
                  if (stats.uid < 0)
                    stats.uid += 4294967296;
                  if (stats.gid < 0)
                    stats.gid += 4294967296;
                  return stats;
                };
              }
              function chownErOk(er) {
                if (!er)
                  return true;
                if (er.code === "ENOSYS")
                  return true;
                var nonroot = !process.getuid || process.getuid() !== 0;
                if (nonroot) {
                  if (er.code === "EINVAL" || er.code === "EPERM")
                    return true;
                }
                return false;
              }
            }
          }
        });
        var require_legacy_streams = __commonJS22({
          "../../node_modules/graceful-fs/legacy-streams.js"(exports22, module22) {
            var Stream = require("stream").Stream;
            module22.exports = legacy;
            function legacy(fs3) {
              return {
                ReadStream,
                WriteStream
              };
              function ReadStream(path7, options) {
                if (!(this instanceof ReadStream))
                  return new ReadStream(path7, options);
                Stream.call(this);
                var self2 = this;
                this.path = path7;
                this.fd = null;
                this.readable = true;
                this.paused = false;
                this.flags = "r";
                this.mode = 438;
                this.bufferSize = 64 * 1024;
                options = options || {};
                var keys = Object.keys(options);
                for (var index = 0, length = keys.length; index < length; index++) {
                  var key = keys[index];
                  this[key] = options[key];
                }
                if (this.encoding)
                  this.setEncoding(this.encoding);
                if (this.start !== void 0) {
                  if (typeof this.start !== "number") {
                    throw TypeError("start must be a Number");
                  }
                  if (this.end === void 0) {
                    this.end = Infinity;
                  } else if (typeof this.end !== "number") {
                    throw TypeError("end must be a Number");
                  }
                  if (this.start > this.end) {
                    throw new Error("start must be <= end");
                  }
                  this.pos = this.start;
                }
                if (this.fd !== null) {
                  process.nextTick(function() {
                    self2._read();
                  });
                  return;
                }
                fs3.open(this.path, this.flags, this.mode, function(err, fd) {
                  if (err) {
                    self2.emit("error", err);
                    self2.readable = false;
                    return;
                  }
                  self2.fd = fd;
                  self2.emit("open", fd);
                  self2._read();
                });
              }
              function WriteStream(path7, options) {
                if (!(this instanceof WriteStream))
                  return new WriteStream(path7, options);
                Stream.call(this);
                this.path = path7;
                this.fd = null;
                this.writable = true;
                this.flags = "w";
                this.encoding = "binary";
                this.mode = 438;
                this.bytesWritten = 0;
                options = options || {};
                var keys = Object.keys(options);
                for (var index = 0, length = keys.length; index < length; index++) {
                  var key = keys[index];
                  this[key] = options[key];
                }
                if (this.start !== void 0) {
                  if (typeof this.start !== "number") {
                    throw TypeError("start must be a Number");
                  }
                  if (this.start < 0) {
                    throw new Error("start must be >= zero");
                  }
                  this.pos = this.start;
                }
                this.busy = false;
                this._queue = [];
                if (this.fd === null) {
                  this._open = fs3.open;
                  this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
                  this.flush();
                }
              }
            }
          }
        });
        var require_clone = __commonJS22({
          "../../node_modules/graceful-fs/clone.js"(exports22, module22) {
            "use strict";
            module22.exports = clone;
            var getPrototypeOf = Object.getPrototypeOf || function(obj) {
              return obj.__proto__;
            };
            function clone(obj) {
              if (obj === null || typeof obj !== "object")
                return obj;
              if (obj instanceof Object)
                var copy = { __proto__: getPrototypeOf(obj) };
              else
                var copy = Object.create(null);
              Object.getOwnPropertyNames(obj).forEach(function(key) {
                Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
              });
              return copy;
            }
          }
        });
        var require_graceful_fs = __commonJS22({
          "../../node_modules/graceful-fs/graceful-fs.js"(exports22, module22) {
            var fs3 = require("fs");
            var polyfills = require_polyfills();
            var legacy = require_legacy_streams();
            var clone = require_clone();
            var util = require("util");
            var gracefulQueue;
            var previousSymbol;
            if (typeof Symbol === "function" && typeof Symbol.for === "function") {
              gracefulQueue = Symbol.for("graceful-fs.queue");
              previousSymbol = Symbol.for("graceful-fs.previous");
            } else {
              gracefulQueue = "___graceful-fs.queue";
              previousSymbol = "___graceful-fs.previous";
            }
            function noop() {
            }
            function publishQueue(context, queue2) {
              Object.defineProperty(context, gracefulQueue, {
                get: function() {
                  return queue2;
                }
              });
            }
            var debug = noop;
            if (util.debuglog)
              debug = util.debuglog("gfs4");
            else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
              debug = function() {
                var m = util.format.apply(util, arguments);
                m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
                console.error(m);
              };
            if (!fs3[gracefulQueue]) {
              queue = global[gracefulQueue] || [];
              publishQueue(fs3, queue);
              fs3.close = function(fs$close) {
                function close(fd, cb) {
                  return fs$close.call(fs3, fd, function(err) {
                    if (!err) {
                      retry();
                    }
                    if (typeof cb === "function")
                      cb.apply(this, arguments);
                  });
                }
                Object.defineProperty(close, previousSymbol, {
                  value: fs$close
                });
                return close;
              }(fs3.close);
              fs3.closeSync = function(fs$closeSync) {
                function closeSync(fd) {
                  fs$closeSync.apply(fs3, arguments);
                  retry();
                }
                Object.defineProperty(closeSync, previousSymbol, {
                  value: fs$closeSync
                });
                return closeSync;
              }(fs3.closeSync);
              if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
                process.on("exit", function() {
                  debug(fs3[gracefulQueue]);
                  require("assert").equal(fs3[gracefulQueue].length, 0);
                });
              }
            }
            var queue;
            if (!global[gracefulQueue]) {
              publishQueue(global, fs3[gracefulQueue]);
            }
            module22.exports = patch(clone(fs3));
            if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
              module22.exports = patch(fs3);
              fs3.__patched = true;
            }
            function patch(fs4) {
              polyfills(fs4);
              fs4.gracefulify = patch;
              fs4.createReadStream = createReadStream;
              fs4.createWriteStream = createWriteStream;
              var fs$readFile = fs4.readFile;
              fs4.readFile = readFile;
              function readFile(path7, options, cb) {
                if (typeof options === "function")
                  cb = options, options = null;
                return go$readFile(path7, options, cb);
                function go$readFile(path8, options2, cb2) {
                  return fs$readFile(path8, options2, function(err) {
                    if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                      enqueue([go$readFile, [path8, options2, cb2]]);
                    else {
                      if (typeof cb2 === "function")
                        cb2.apply(this, arguments);
                      retry();
                    }
                  });
                }
              }
              var fs$writeFile = fs4.writeFile;
              fs4.writeFile = writeFile;
              function writeFile(path7, data, options, cb) {
                if (typeof options === "function")
                  cb = options, options = null;
                return go$writeFile(path7, data, options, cb);
                function go$writeFile(path8, data2, options2, cb2) {
                  return fs$writeFile(path8, data2, options2, function(err) {
                    if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                      enqueue([go$writeFile, [path8, data2, options2, cb2]]);
                    else {
                      if (typeof cb2 === "function")
                        cb2.apply(this, arguments);
                      retry();
                    }
                  });
                }
              }
              var fs$appendFile = fs4.appendFile;
              if (fs$appendFile)
                fs4.appendFile = appendFile;
              function appendFile(path7, data, options, cb) {
                if (typeof options === "function")
                  cb = options, options = null;
                return go$appendFile(path7, data, options, cb);
                function go$appendFile(path8, data2, options2, cb2) {
                  return fs$appendFile(path8, data2, options2, function(err) {
                    if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                      enqueue([go$appendFile, [path8, data2, options2, cb2]]);
                    else {
                      if (typeof cb2 === "function")
                        cb2.apply(this, arguments);
                      retry();
                    }
                  });
                }
              }
              var fs$copyFile = fs4.copyFile;
              if (fs$copyFile)
                fs4.copyFile = copyFile;
              function copyFile(src, dest, flags, cb) {
                if (typeof flags === "function") {
                  cb = flags;
                  flags = 0;
                }
                return fs$copyFile(src, dest, flags, function(err) {
                  if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                    enqueue([fs$copyFile, [src, dest, flags, cb]]);
                  else {
                    if (typeof cb === "function")
                      cb.apply(this, arguments);
                    retry();
                  }
                });
              }
              var fs$readdir = fs4.readdir;
              fs4.readdir = readdir;
              function readdir(path7, options, cb) {
                var args = [path7];
                if (typeof options !== "function") {
                  args.push(options);
                } else {
                  cb = options;
                }
                args.push(go$readdir$cb);
                return go$readdir(args);
                function go$readdir$cb(err, files) {
                  if (files && files.sort)
                    files.sort();
                  if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                    enqueue([go$readdir, [args]]);
                  else {
                    if (typeof cb === "function")
                      cb.apply(this, arguments);
                    retry();
                  }
                }
              }
              function go$readdir(args) {
                return fs$readdir.apply(fs4, args);
              }
              if (process.version.substr(0, 4) === "v0.8") {
                var legStreams = legacy(fs4);
                ReadStream = legStreams.ReadStream;
                WriteStream = legStreams.WriteStream;
              }
              var fs$ReadStream = fs4.ReadStream;
              if (fs$ReadStream) {
                ReadStream.prototype = Object.create(fs$ReadStream.prototype);
                ReadStream.prototype.open = ReadStream$open;
              }
              var fs$WriteStream = fs4.WriteStream;
              if (fs$WriteStream) {
                WriteStream.prototype = Object.create(fs$WriteStream.prototype);
                WriteStream.prototype.open = WriteStream$open;
              }
              Object.defineProperty(fs4, "ReadStream", {
                get: function() {
                  return ReadStream;
                },
                set: function(val) {
                  ReadStream = val;
                },
                enumerable: true,
                configurable: true
              });
              Object.defineProperty(fs4, "WriteStream", {
                get: function() {
                  return WriteStream;
                },
                set: function(val) {
                  WriteStream = val;
                },
                enumerable: true,
                configurable: true
              });
              var FileReadStream = ReadStream;
              Object.defineProperty(fs4, "FileReadStream", {
                get: function() {
                  return FileReadStream;
                },
                set: function(val) {
                  FileReadStream = val;
                },
                enumerable: true,
                configurable: true
              });
              var FileWriteStream = WriteStream;
              Object.defineProperty(fs4, "FileWriteStream", {
                get: function() {
                  return FileWriteStream;
                },
                set: function(val) {
                  FileWriteStream = val;
                },
                enumerable: true,
                configurable: true
              });
              function ReadStream(path7, options) {
                if (this instanceof ReadStream)
                  return fs$ReadStream.apply(this, arguments), this;
                else
                  return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
              }
              function ReadStream$open() {
                var that = this;
                open(that.path, that.flags, that.mode, function(err, fd) {
                  if (err) {
                    if (that.autoClose)
                      that.destroy();
                    that.emit("error", err);
                  } else {
                    that.fd = fd;
                    that.emit("open", fd);
                    that.read();
                  }
                });
              }
              function WriteStream(path7, options) {
                if (this instanceof WriteStream)
                  return fs$WriteStream.apply(this, arguments), this;
                else
                  return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
              }
              function WriteStream$open() {
                var that = this;
                open(that.path, that.flags, that.mode, function(err, fd) {
                  if (err) {
                    that.destroy();
                    that.emit("error", err);
                  } else {
                    that.fd = fd;
                    that.emit("open", fd);
                  }
                });
              }
              function createReadStream(path7, options) {
                return new fs4.ReadStream(path7, options);
              }
              function createWriteStream(path7, options) {
                return new fs4.WriteStream(path7, options);
              }
              var fs$open = fs4.open;
              fs4.open = open;
              function open(path7, flags, mode, cb) {
                if (typeof mode === "function")
                  cb = mode, mode = null;
                return go$open(path7, flags, mode, cb);
                function go$open(path8, flags2, mode2, cb2) {
                  return fs$open(path8, flags2, mode2, function(err, fd) {
                    if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                      enqueue([go$open, [path8, flags2, mode2, cb2]]);
                    else {
                      if (typeof cb2 === "function")
                        cb2.apply(this, arguments);
                      retry();
                    }
                  });
                }
              }
              return fs4;
            }
            function enqueue(elem) {
              debug("ENQUEUE", elem[0].name, elem[1]);
              fs3[gracefulQueue].push(elem);
            }
            function retry() {
              var elem = fs3[gracefulQueue].shift();
              if (elem) {
                debug("RETRY", elem[0].name, elem[1]);
                elem[0].apply(null, elem[1]);
              }
            }
          }
        });
        var require_fs = __commonJS22({
          "../../node_modules/fs-extra/lib/fs/index.js"(exports22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            var fs3 = require_graceful_fs();
            var api = [
              "access",
              "appendFile",
              "chmod",
              "chown",
              "close",
              "copyFile",
              "fchmod",
              "fchown",
              "fdatasync",
              "fstat",
              "fsync",
              "ftruncate",
              "futimes",
              "lchmod",
              "lchown",
              "link",
              "lstat",
              "mkdir",
              "mkdtemp",
              "open",
              "opendir",
              "readdir",
              "readFile",
              "readlink",
              "realpath",
              "rename",
              "rm",
              "rmdir",
              "stat",
              "symlink",
              "truncate",
              "unlink",
              "utimes",
              "writeFile"
            ].filter((key) => {
              return typeof fs3[key] === "function";
            });
            Object.assign(exports22, fs3);
            api.forEach((method) => {
              exports22[method] = u4(fs3[method]);
            });
            exports22.realpath.native = u4(fs3.realpath.native);
            exports22.exists = function(filename, callback) {
              if (typeof callback === "function") {
                return fs3.exists(filename, callback);
              }
              return new Promise((resolve) => {
                return fs3.exists(filename, resolve);
              });
            };
            exports22.read = function(fd, buffer, offset, length, position, callback) {
              if (typeof callback === "function") {
                return fs3.read(fd, buffer, offset, length, position, callback);
              }
              return new Promise((resolve, reject) => {
                fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
                  if (err)
                    return reject(err);
                  resolve({ bytesRead, buffer: buffer2 });
                });
              });
            };
            exports22.write = function(fd, buffer, ...args) {
              if (typeof args[args.length - 1] === "function") {
                return fs3.write(fd, buffer, ...args);
              }
              return new Promise((resolve, reject) => {
                fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
                  if (err)
                    return reject(err);
                  resolve({ bytesWritten, buffer: buffer2 });
                });
              });
            };
            if (typeof fs3.writev === "function") {
              exports22.writev = function(fd, buffers, ...args) {
                if (typeof args[args.length - 1] === "function") {
                  return fs3.writev(fd, buffers, ...args);
                }
                return new Promise((resolve, reject) => {
                  fs3.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
                    if (err)
                      return reject(err);
                    resolve({ bytesWritten, buffers: buffers2 });
                  });
                });
              };
            }
          }
        });
        var require_utils2 = __commonJS22({
          "../../node_modules/fs-extra/lib/mkdirs/utils.js"(exports22, module22) {
            "use strict";
            var path7 = require("path");
            module22.exports.checkPath = function checkPath(pth) {
              if (process.platform === "win32") {
                const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path7.parse(pth).root, ""));
                if (pathHasInvalidWinCharacters) {
                  const error = new Error(`Path contains invalid characters: ${pth}`);
                  error.code = "EINVAL";
                  throw error;
                }
              }
            };
          }
        });
        var require_make_dir = __commonJS22({
          "../../node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports22, module22) {
            "use strict";
            var fs3 = require_fs();
            var { checkPath } = require_utils2();
            var getMode = (options) => {
              const defaults = { mode: 511 };
              if (typeof options === "number")
                return options;
              return __spreadValues2(__spreadValues2({}, defaults), options).mode;
            };
            module22.exports.makeDir = (dir, options) => __async2(exports22, null, function* () {
              checkPath(dir);
              return fs3.mkdir(dir, {
                mode: getMode(options),
                recursive: true
              });
            });
            module22.exports.makeDirSync = (dir, options) => {
              checkPath(dir);
              return fs3.mkdirSync(dir, {
                mode: getMode(options),
                recursive: true
              });
            };
          }
        });
        var require_mkdirs = __commonJS22({
          "../../node_modules/fs-extra/lib/mkdirs/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromPromise;
            var { makeDir: _makeDir, makeDirSync } = require_make_dir();
            var makeDir = u4(_makeDir);
            module22.exports = {
              mkdirs: makeDir,
              mkdirsSync: makeDirSync,
              mkdirp: makeDir,
              mkdirpSync: makeDirSync,
              ensureDir: makeDir,
              ensureDirSync: makeDirSync
            };
          }
        });
        var require_utimes = __commonJS22({
          "../../node_modules/fs-extra/lib/util/utimes.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            function utimesMillis(path7, atime, mtime, callback) {
              fs3.open(path7, "r+", (err, fd) => {
                if (err)
                  return callback(err);
                fs3.futimes(fd, atime, mtime, (futimesErr) => {
                  fs3.close(fd, (closeErr) => {
                    if (callback)
                      callback(futimesErr || closeErr);
                  });
                });
              });
            }
            function utimesMillisSync(path7, atime, mtime) {
              const fd = fs3.openSync(path7, "r+");
              fs3.futimesSync(fd, atime, mtime);
              return fs3.closeSync(fd);
            }
            module22.exports = {
              utimesMillis,
              utimesMillisSync
            };
          }
        });
        var require_stat = __commonJS22({
          "../../node_modules/fs-extra/lib/util/stat.js"(exports22, module22) {
            "use strict";
            var fs3 = require_fs();
            var path7 = require("path");
            var util = require("util");
            function getStats(src, dest, opts) {
              const statFunc = opts.dereference ? (file) => fs3.stat(file, { bigint: true }) : (file) => fs3.lstat(file, { bigint: true });
              return Promise.all([
                statFunc(src),
                statFunc(dest).catch((err) => {
                  if (err.code === "ENOENT")
                    return null;
                  throw err;
                })
              ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
            }
            function getStatsSync(src, dest, opts) {
              let destStat;
              const statFunc = opts.dereference ? (file) => fs3.statSync(file, { bigint: true }) : (file) => fs3.lstatSync(file, { bigint: true });
              const srcStat = statFunc(src);
              try {
                destStat = statFunc(dest);
              } catch (err) {
                if (err.code === "ENOENT")
                  return { srcStat, destStat: null };
                throw err;
              }
              return { srcStat, destStat };
            }
            function checkPaths(src, dest, funcName, opts, cb) {
              util.callbackify(getStats)(src, dest, opts, (err, stats) => {
                if (err)
                  return cb(err);
                const { srcStat, destStat } = stats;
                if (destStat) {
                  if (areIdentical(srcStat, destStat)) {
                    const srcBaseName = path7.basename(src);
                    const destBaseName = path7.basename(dest);
                    if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                      return cb(null, { srcStat, destStat, isChangingCase: true });
                    }
                    return cb(new Error("Source and destination must not be the same."));
                  }
                  if (srcStat.isDirectory() && !destStat.isDirectory()) {
                    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
                  }
                  if (!srcStat.isDirectory() && destStat.isDirectory()) {
                    return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
                  }
                }
                if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                  return cb(new Error(errMsg(src, dest, funcName)));
                }
                return cb(null, { srcStat, destStat });
              });
            }
            function checkPathsSync(src, dest, funcName, opts) {
              const { srcStat, destStat } = getStatsSync(src, dest, opts);
              if (destStat) {
                if (areIdentical(srcStat, destStat)) {
                  const srcBaseName = path7.basename(src);
                  const destBaseName = path7.basename(dest);
                  if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                    return { srcStat, destStat, isChangingCase: true };
                  }
                  throw new Error("Source and destination must not be the same.");
                }
                if (srcStat.isDirectory() && !destStat.isDirectory()) {
                  throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
                }
                if (!srcStat.isDirectory() && destStat.isDirectory()) {
                  throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
                }
              }
              if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                throw new Error(errMsg(src, dest, funcName));
              }
              return { srcStat, destStat };
            }
            function checkParentPaths(src, srcStat, dest, funcName, cb) {
              const srcParent = path7.resolve(path7.dirname(src));
              const destParent = path7.resolve(path7.dirname(dest));
              if (destParent === srcParent || destParent === path7.parse(destParent).root)
                return cb();
              fs3.stat(destParent, { bigint: true }, (err, destStat) => {
                if (err) {
                  if (err.code === "ENOENT")
                    return cb();
                  return cb(err);
                }
                if (areIdentical(srcStat, destStat)) {
                  return cb(new Error(errMsg(src, dest, funcName)));
                }
                return checkParentPaths(src, srcStat, destParent, funcName, cb);
              });
            }
            function checkParentPathsSync(src, srcStat, dest, funcName) {
              const srcParent = path7.resolve(path7.dirname(src));
              const destParent = path7.resolve(path7.dirname(dest));
              if (destParent === srcParent || destParent === path7.parse(destParent).root)
                return;
              let destStat;
              try {
                destStat = fs3.statSync(destParent, { bigint: true });
              } catch (err) {
                if (err.code === "ENOENT")
                  return;
                throw err;
              }
              if (areIdentical(srcStat, destStat)) {
                throw new Error(errMsg(src, dest, funcName));
              }
              return checkParentPathsSync(src, srcStat, destParent, funcName);
            }
            function areIdentical(srcStat, destStat) {
              return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
            }
            function isSrcSubdir(src, dest) {
              const srcArr = path7.resolve(src).split(path7.sep).filter((i) => i);
              const destArr = path7.resolve(dest).split(path7.sep).filter((i) => i);
              return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
            }
            function errMsg(src, dest, funcName) {
              return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
            }
            module22.exports = {
              checkPaths,
              checkPathsSync,
              checkParentPaths,
              checkParentPathsSync,
              isSrcSubdir,
              areIdentical
            };
          }
        });
        var require_copy_sync = __commonJS22({
          "../../node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var mkdirsSync = require_mkdirs().mkdirsSync;
            var utimesMillisSync = require_utimes().utimesMillisSync;
            var stat = require_stat();
            function copySync(src, dest, opts) {
              if (typeof opts === "function") {
                opts = { filter: opts };
              }
              opts = opts || {};
              opts.clobber = "clobber" in opts ? !!opts.clobber : true;
              opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
              if (opts.preserveTimestamps && process.arch === "ia32") {
                console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
              }
              const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
              stat.checkParentPathsSync(src, srcStat, dest, "copy");
              return handleFilterAndCopy(destStat, src, dest, opts);
            }
            function handleFilterAndCopy(destStat, src, dest, opts) {
              if (opts.filter && !opts.filter(src, dest))
                return;
              const destParent = path7.dirname(dest);
              if (!fs3.existsSync(destParent))
                mkdirsSync(destParent);
              return getStats(destStat, src, dest, opts);
            }
            function startCopy(destStat, src, dest, opts) {
              if (opts.filter && !opts.filter(src, dest))
                return;
              return getStats(destStat, src, dest, opts);
            }
            function getStats(destStat, src, dest, opts) {
              const statSync2 = opts.dereference ? fs3.statSync : fs3.lstatSync;
              const srcStat = statSync2(src);
              if (srcStat.isDirectory())
                return onDir(srcStat, destStat, src, dest, opts);
              else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
                return onFile(srcStat, destStat, src, dest, opts);
              else if (srcStat.isSymbolicLink())
                return onLink(destStat, src, dest, opts);
              else if (srcStat.isSocket())
                throw new Error(`Cannot copy a socket file: ${src}`);
              else if (srcStat.isFIFO())
                throw new Error(`Cannot copy a FIFO pipe: ${src}`);
              throw new Error(`Unknown file: ${src}`);
            }
            function onFile(srcStat, destStat, src, dest, opts) {
              if (!destStat)
                return copyFile(srcStat, src, dest, opts);
              return mayCopyFile(srcStat, src, dest, opts);
            }
            function mayCopyFile(srcStat, src, dest, opts) {
              if (opts.overwrite) {
                fs3.unlinkSync(dest);
                return copyFile(srcStat, src, dest, opts);
              } else if (opts.errorOnExist) {
                throw new Error(`'${dest}' already exists`);
              }
            }
            function copyFile(srcStat, src, dest, opts) {
              fs3.copyFileSync(src, dest);
              if (opts.preserveTimestamps)
                handleTimestamps(srcStat.mode, src, dest);
              return setDestMode(dest, srcStat.mode);
            }
            function handleTimestamps(srcMode, src, dest) {
              if (fileIsNotWritable(srcMode))
                makeFileWritable(dest, srcMode);
              return setDestTimestamps(src, dest);
            }
            function fileIsNotWritable(srcMode) {
              return (srcMode & 128) === 0;
            }
            function makeFileWritable(dest, srcMode) {
              return setDestMode(dest, srcMode | 128);
            }
            function setDestMode(dest, srcMode) {
              return fs3.chmodSync(dest, srcMode);
            }
            function setDestTimestamps(src, dest) {
              const updatedSrcStat = fs3.statSync(src);
              return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
            }
            function onDir(srcStat, destStat, src, dest, opts) {
              if (!destStat)
                return mkDirAndCopy(srcStat.mode, src, dest, opts);
              return copyDir(src, dest, opts);
            }
            function mkDirAndCopy(srcMode, src, dest, opts) {
              fs3.mkdirSync(dest);
              copyDir(src, dest, opts);
              return setDestMode(dest, srcMode);
            }
            function copyDir(src, dest, opts) {
              fs3.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
            }
            function copyDirItem(item, src, dest, opts) {
              const srcItem = path7.join(src, item);
              const destItem = path7.join(dest, item);
              const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
              return startCopy(destStat, srcItem, destItem, opts);
            }
            function onLink(destStat, src, dest, opts) {
              let resolvedSrc = fs3.readlinkSync(src);
              if (opts.dereference) {
                resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
              }
              if (!destStat) {
                return fs3.symlinkSync(resolvedSrc, dest);
              } else {
                let resolvedDest;
                try {
                  resolvedDest = fs3.readlinkSync(dest);
                } catch (err) {
                  if (err.code === "EINVAL" || err.code === "UNKNOWN")
                    return fs3.symlinkSync(resolvedSrc, dest);
                  throw err;
                }
                if (opts.dereference) {
                  resolvedDest = path7.resolve(process.cwd(), resolvedDest);
                }
                if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                  throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
                }
                if (fs3.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                  throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
                }
                return copyLink(resolvedSrc, dest);
              }
            }
            function copyLink(resolvedSrc, dest) {
              fs3.unlinkSync(dest);
              return fs3.symlinkSync(resolvedSrc, dest);
            }
            module22.exports = copySync;
          }
        });
        var require_copy_sync2 = __commonJS22({
          "../../node_modules/fs-extra/lib/copy-sync/index.js"(exports22, module22) {
            "use strict";
            module22.exports = {
              copySync: require_copy_sync()
            };
          }
        });
        var require_path_exists = __commonJS22({
          "../../node_modules/fs-extra/lib/path-exists/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromPromise;
            var fs3 = require_fs();
            function pathExists(path7) {
              return fs3.access(path7).then(() => true).catch(() => false);
            }
            module22.exports = {
              pathExists: u4(pathExists),
              pathExistsSync: fs3.existsSync
            };
          }
        });
        var require_copy = __commonJS22({
          "../../node_modules/fs-extra/lib/copy/copy.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var mkdirs = require_mkdirs().mkdirs;
            var pathExists = require_path_exists().pathExists;
            var utimesMillis = require_utimes().utimesMillis;
            var stat = require_stat();
            function copy(src, dest, opts, cb) {
              if (typeof opts === "function" && !cb) {
                cb = opts;
                opts = {};
              } else if (typeof opts === "function") {
                opts = { filter: opts };
              }
              cb = cb || function() {
              };
              opts = opts || {};
              opts.clobber = "clobber" in opts ? !!opts.clobber : true;
              opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
              if (opts.preserveTimestamps && process.arch === "ia32") {
                console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
              }
              stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
                if (err)
                  return cb(err);
                const { srcStat, destStat } = stats;
                stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
                  if (err2)
                    return cb(err2);
                  if (opts.filter)
                    return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
                  return checkParentDir(destStat, src, dest, opts, cb);
                });
              });
            }
            function checkParentDir(destStat, src, dest, opts, cb) {
              const destParent = path7.dirname(dest);
              pathExists(destParent, (err, dirExists) => {
                if (err)
                  return cb(err);
                if (dirExists)
                  return getStats(destStat, src, dest, opts, cb);
                mkdirs(destParent, (err2) => {
                  if (err2)
                    return cb(err2);
                  return getStats(destStat, src, dest, opts, cb);
                });
              });
            }
            function handleFilter(onInclude, destStat, src, dest, opts, cb) {
              Promise.resolve(opts.filter(src, dest)).then((include) => {
                if (include)
                  return onInclude(destStat, src, dest, opts, cb);
                return cb();
              }, (error) => cb(error));
            }
            function startCopy(destStat, src, dest, opts, cb) {
              if (opts.filter)
                return handleFilter(getStats, destStat, src, dest, opts, cb);
              return getStats(destStat, src, dest, opts, cb);
            }
            function getStats(destStat, src, dest, opts, cb) {
              const stat2 = opts.dereference ? fs3.stat : fs3.lstat;
              stat2(src, (err, srcStat) => {
                if (err)
                  return cb(err);
                if (srcStat.isDirectory())
                  return onDir(srcStat, destStat, src, dest, opts, cb);
                else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
                  return onFile(srcStat, destStat, src, dest, opts, cb);
                else if (srcStat.isSymbolicLink())
                  return onLink(destStat, src, dest, opts, cb);
                else if (srcStat.isSocket())
                  return cb(new Error(`Cannot copy a socket file: ${src}`));
                else if (srcStat.isFIFO())
                  return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
                return cb(new Error(`Unknown file: ${src}`));
              });
            }
            function onFile(srcStat, destStat, src, dest, opts, cb) {
              if (!destStat)
                return copyFile(srcStat, src, dest, opts, cb);
              return mayCopyFile(srcStat, src, dest, opts, cb);
            }
            function mayCopyFile(srcStat, src, dest, opts, cb) {
              if (opts.overwrite) {
                fs3.unlink(dest, (err) => {
                  if (err)
                    return cb(err);
                  return copyFile(srcStat, src, dest, opts, cb);
                });
              } else if (opts.errorOnExist) {
                return cb(new Error(`'${dest}' already exists`));
              } else
                return cb();
            }
            function copyFile(srcStat, src, dest, opts, cb) {
              fs3.copyFile(src, dest, (err) => {
                if (err)
                  return cb(err);
                if (opts.preserveTimestamps)
                  return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
                return setDestMode(dest, srcStat.mode, cb);
              });
            }
            function handleTimestampsAndMode(srcMode, src, dest, cb) {
              if (fileIsNotWritable(srcMode)) {
                return makeFileWritable(dest, srcMode, (err) => {
                  if (err)
                    return cb(err);
                  return setDestTimestampsAndMode(srcMode, src, dest, cb);
                });
              }
              return setDestTimestampsAndMode(srcMode, src, dest, cb);
            }
            function fileIsNotWritable(srcMode) {
              return (srcMode & 128) === 0;
            }
            function makeFileWritable(dest, srcMode, cb) {
              return setDestMode(dest, srcMode | 128, cb);
            }
            function setDestTimestampsAndMode(srcMode, src, dest, cb) {
              setDestTimestamps(src, dest, (err) => {
                if (err)
                  return cb(err);
                return setDestMode(dest, srcMode, cb);
              });
            }
            function setDestMode(dest, srcMode, cb) {
              return fs3.chmod(dest, srcMode, cb);
            }
            function setDestTimestamps(src, dest, cb) {
              fs3.stat(src, (err, updatedSrcStat) => {
                if (err)
                  return cb(err);
                return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
              });
            }
            function onDir(srcStat, destStat, src, dest, opts, cb) {
              if (!destStat)
                return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
              return copyDir(src, dest, opts, cb);
            }
            function mkDirAndCopy(srcMode, src, dest, opts, cb) {
              fs3.mkdir(dest, (err) => {
                if (err)
                  return cb(err);
                copyDir(src, dest, opts, (err2) => {
                  if (err2)
                    return cb(err2);
                  return setDestMode(dest, srcMode, cb);
                });
              });
            }
            function copyDir(src, dest, opts, cb) {
              fs3.readdir(src, (err, items) => {
                if (err)
                  return cb(err);
                return copyDirItems(items, src, dest, opts, cb);
              });
            }
            function copyDirItems(items, src, dest, opts, cb) {
              const item = items.pop();
              if (!item)
                return cb();
              return copyDirItem(items, item, src, dest, opts, cb);
            }
            function copyDirItem(items, item, src, dest, opts, cb) {
              const srcItem = path7.join(src, item);
              const destItem = path7.join(dest, item);
              stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
                if (err)
                  return cb(err);
                const { destStat } = stats;
                startCopy(destStat, srcItem, destItem, opts, (err2) => {
                  if (err2)
                    return cb(err2);
                  return copyDirItems(items, src, dest, opts, cb);
                });
              });
            }
            function onLink(destStat, src, dest, opts, cb) {
              fs3.readlink(src, (err, resolvedSrc) => {
                if (err)
                  return cb(err);
                if (opts.dereference) {
                  resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
                }
                if (!destStat) {
                  return fs3.symlink(resolvedSrc, dest, cb);
                } else {
                  fs3.readlink(dest, (err2, resolvedDest) => {
                    if (err2) {
                      if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                        return fs3.symlink(resolvedSrc, dest, cb);
                      return cb(err2);
                    }
                    if (opts.dereference) {
                      resolvedDest = path7.resolve(process.cwd(), resolvedDest);
                    }
                    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                      return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
                    }
                    if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                      return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                    }
                    return copyLink(resolvedSrc, dest, cb);
                  });
                }
              });
            }
            function copyLink(resolvedSrc, dest, cb) {
              fs3.unlink(dest, (err) => {
                if (err)
                  return cb(err);
                return fs3.symlink(resolvedSrc, dest, cb);
              });
            }
            module22.exports = copy;
          }
        });
        var require_copy2 = __commonJS22({
          "../../node_modules/fs-extra/lib/copy/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            module22.exports = {
              copy: u4(require_copy())
            };
          }
        });
        var require_rimraf = __commonJS22({
          "../../node_modules/fs-extra/lib/remove/rimraf.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var assert = require("assert");
            var isWindows = process.platform === "win32";
            function defaults(options) {
              const methods = [
                "unlink",
                "chmod",
                "stat",
                "lstat",
                "rmdir",
                "readdir"
              ];
              methods.forEach((m) => {
                options[m] = options[m] || fs3[m];
                m = m + "Sync";
                options[m] = options[m] || fs3[m];
              });
              options.maxBusyTries = options.maxBusyTries || 3;
            }
            function rimraf(p, options, cb) {
              let busyTries = 0;
              if (typeof options === "function") {
                cb = options;
                options = {};
              }
              assert(p, "rimraf: missing path");
              assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
              assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
              assert(options, "rimraf: invalid options argument provided");
              assert.strictEqual(typeof options, "object", "rimraf: options should be object");
              defaults(options);
              rimraf_(p, options, function CB(er) {
                if (er) {
                  if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
                    busyTries++;
                    const time = busyTries * 100;
                    return setTimeout(() => rimraf_(p, options, CB), time);
                  }
                  if (er.code === "ENOENT")
                    er = null;
                }
                cb(er);
              });
            }
            function rimraf_(p, options, cb) {
              assert(p);
              assert(options);
              assert(typeof cb === "function");
              options.lstat(p, (er, st) => {
                if (er && er.code === "ENOENT") {
                  return cb(null);
                }
                if (er && er.code === "EPERM" && isWindows) {
                  return fixWinEPERM(p, options, er, cb);
                }
                if (st && st.isDirectory()) {
                  return rmdir(p, options, er, cb);
                }
                options.unlink(p, (er2) => {
                  if (er2) {
                    if (er2.code === "ENOENT") {
                      return cb(null);
                    }
                    if (er2.code === "EPERM") {
                      return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
                    }
                    if (er2.code === "EISDIR") {
                      return rmdir(p, options, er2, cb);
                    }
                  }
                  return cb(er2);
                });
              });
            }
            function fixWinEPERM(p, options, er, cb) {
              assert(p);
              assert(options);
              assert(typeof cb === "function");
              options.chmod(p, 438, (er2) => {
                if (er2) {
                  cb(er2.code === "ENOENT" ? null : er);
                } else {
                  options.stat(p, (er3, stats) => {
                    if (er3) {
                      cb(er3.code === "ENOENT" ? null : er);
                    } else if (stats.isDirectory()) {
                      rmdir(p, options, er, cb);
                    } else {
                      options.unlink(p, cb);
                    }
                  });
                }
              });
            }
            function fixWinEPERMSync(p, options, er) {
              let stats;
              assert(p);
              assert(options);
              try {
                options.chmodSync(p, 438);
              } catch (er2) {
                if (er2.code === "ENOENT") {
                  return;
                } else {
                  throw er;
                }
              }
              try {
                stats = options.statSync(p);
              } catch (er3) {
                if (er3.code === "ENOENT") {
                  return;
                } else {
                  throw er;
                }
              }
              if (stats.isDirectory()) {
                rmdirSync(p, options, er);
              } else {
                options.unlinkSync(p);
              }
            }
            function rmdir(p, options, originalEr, cb) {
              assert(p);
              assert(options);
              assert(typeof cb === "function");
              options.rmdir(p, (er) => {
                if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
                  rmkids(p, options, cb);
                } else if (er && er.code === "ENOTDIR") {
                  cb(originalEr);
                } else {
                  cb(er);
                }
              });
            }
            function rmkids(p, options, cb) {
              assert(p);
              assert(options);
              assert(typeof cb === "function");
              options.readdir(p, (er, files) => {
                if (er)
                  return cb(er);
                let n = files.length;
                let errState;
                if (n === 0)
                  return options.rmdir(p, cb);
                files.forEach((f) => {
                  rimraf(path7.join(p, f), options, (er2) => {
                    if (errState) {
                      return;
                    }
                    if (er2)
                      return cb(errState = er2);
                    if (--n === 0) {
                      options.rmdir(p, cb);
                    }
                  });
                });
              });
            }
            function rimrafSync(p, options) {
              let st;
              options = options || {};
              defaults(options);
              assert(p, "rimraf: missing path");
              assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
              assert(options, "rimraf: missing options");
              assert.strictEqual(typeof options, "object", "rimraf: options should be object");
              try {
                st = options.lstatSync(p);
              } catch (er) {
                if (er.code === "ENOENT") {
                  return;
                }
                if (er.code === "EPERM" && isWindows) {
                  fixWinEPERMSync(p, options, er);
                }
              }
              try {
                if (st && st.isDirectory()) {
                  rmdirSync(p, options, null);
                } else {
                  options.unlinkSync(p);
                }
              } catch (er) {
                if (er.code === "ENOENT") {
                  return;
                } else if (er.code === "EPERM") {
                  return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
                } else if (er.code !== "EISDIR") {
                  throw er;
                }
                rmdirSync(p, options, er);
              }
            }
            function rmdirSync(p, options, originalEr) {
              assert(p);
              assert(options);
              try {
                options.rmdirSync(p);
              } catch (er) {
                if (er.code === "ENOTDIR") {
                  throw originalEr;
                } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
                  rmkidsSync(p, options);
                } else if (er.code !== "ENOENT") {
                  throw er;
                }
              }
            }
            function rmkidsSync(p, options) {
              assert(p);
              assert(options);
              options.readdirSync(p).forEach((f) => rimrafSync(path7.join(p, f), options));
              if (isWindows) {
                const startTime = Date.now();
                do {
                  try {
                    const ret = options.rmdirSync(p, options);
                    return ret;
                  } catch (e) {
                  }
                } while (Date.now() - startTime < 500);
              } else {
                const ret = options.rmdirSync(p, options);
                return ret;
              }
            }
            module22.exports = rimraf;
            rimraf.sync = rimrafSync;
          }
        });
        var require_remove = __commonJS22({
          "../../node_modules/fs-extra/lib/remove/index.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var u4 = require_universalify().fromCallback;
            var rimraf = require_rimraf();
            function remove(path7, callback) {
              if (fs3.rm)
                return fs3.rm(path7, { recursive: true, force: true }, callback);
              rimraf(path7, callback);
            }
            function removeSync(path7) {
              if (fs3.rmSync)
                return fs3.rmSync(path7, { recursive: true, force: true });
              rimraf.sync(path7);
            }
            module22.exports = {
              remove: u4(remove),
              removeSync
            };
          }
        });
        var require_empty = __commonJS22({
          "../../node_modules/fs-extra/lib/empty/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromPromise;
            var fs3 = require_fs();
            var path7 = require("path");
            var mkdir = require_mkdirs();
            var remove = require_remove();
            var emptyDir = u4(function emptyDir2(dir) {
              return __async2(this, null, function* () {
                let items;
                try {
                  items = yield fs3.readdir(dir);
                } catch (e) {
                  return mkdir.mkdirs(dir);
                }
                return Promise.all(items.map((item) => remove.remove(path7.join(dir, item))));
              });
            });
            function emptyDirSync(dir) {
              let items;
              try {
                items = fs3.readdirSync(dir);
              } catch (e) {
                return mkdir.mkdirsSync(dir);
              }
              items.forEach((item) => {
                item = path7.join(dir, item);
                remove.removeSync(item);
              });
            }
            module22.exports = {
              emptyDirSync,
              emptydirSync: emptyDirSync,
              emptyDir,
              emptydir: emptyDir
            };
          }
        });
        var require_file = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/file.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            var path7 = require("path");
            var fs3 = require_graceful_fs();
            var mkdir = require_mkdirs();
            function createFile(file, callback) {
              function makeFile() {
                fs3.writeFile(file, "", (err) => {
                  if (err)
                    return callback(err);
                  callback();
                });
              }
              fs3.stat(file, (err, stats) => {
                if (!err && stats.isFile())
                  return callback();
                const dir = path7.dirname(file);
                fs3.stat(dir, (err2, stats2) => {
                  if (err2) {
                    if (err2.code === "ENOENT") {
                      return mkdir.mkdirs(dir, (err3) => {
                        if (err3)
                          return callback(err3);
                        makeFile();
                      });
                    }
                    return callback(err2);
                  }
                  if (stats2.isDirectory())
                    makeFile();
                  else {
                    fs3.readdir(dir, (err3) => {
                      if (err3)
                        return callback(err3);
                    });
                  }
                });
              });
            }
            function createFileSync(file) {
              let stats;
              try {
                stats = fs3.statSync(file);
              } catch (e) {
              }
              if (stats && stats.isFile())
                return;
              const dir = path7.dirname(file);
              try {
                if (!fs3.statSync(dir).isDirectory()) {
                  fs3.readdirSync(dir);
                }
              } catch (err) {
                if (err && err.code === "ENOENT")
                  mkdir.mkdirsSync(dir);
                else
                  throw err;
              }
              fs3.writeFileSync(file, "");
            }
            module22.exports = {
              createFile: u4(createFile),
              createFileSync
            };
          }
        });
        var require_link = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/link.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            var path7 = require("path");
            var fs3 = require_graceful_fs();
            var mkdir = require_mkdirs();
            var pathExists = require_path_exists().pathExists;
            var { areIdentical } = require_stat();
            function createLink(srcpath, dstpath, callback) {
              function makeLink(srcpath2, dstpath2) {
                fs3.link(srcpath2, dstpath2, (err) => {
                  if (err)
                    return callback(err);
                  callback(null);
                });
              }
              fs3.lstat(dstpath, (_, dstStat) => {
                fs3.lstat(srcpath, (err, srcStat) => {
                  if (err) {
                    err.message = err.message.replace("lstat", "ensureLink");
                    return callback(err);
                  }
                  if (dstStat && areIdentical(srcStat, dstStat))
                    return callback(null);
                  const dir = path7.dirname(dstpath);
                  pathExists(dir, (err2, dirExists) => {
                    if (err2)
                      return callback(err2);
                    if (dirExists)
                      return makeLink(srcpath, dstpath);
                    mkdir.mkdirs(dir, (err3) => {
                      if (err3)
                        return callback(err3);
                      makeLink(srcpath, dstpath);
                    });
                  });
                });
              });
            }
            function createLinkSync(srcpath, dstpath) {
              let dstStat;
              try {
                dstStat = fs3.lstatSync(dstpath);
              } catch (e) {
              }
              try {
                const srcStat = fs3.lstatSync(srcpath);
                if (dstStat && areIdentical(srcStat, dstStat))
                  return;
              } catch (err) {
                err.message = err.message.replace("lstat", "ensureLink");
                throw err;
              }
              const dir = path7.dirname(dstpath);
              const dirExists = fs3.existsSync(dir);
              if (dirExists)
                return fs3.linkSync(srcpath, dstpath);
              mkdir.mkdirsSync(dir);
              return fs3.linkSync(srcpath, dstpath);
            }
            module22.exports = {
              createLink: u4(createLink),
              createLinkSync
            };
          }
        });
        var require_symlink_paths = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports22, module22) {
            "use strict";
            var path7 = require("path");
            var fs3 = require_graceful_fs();
            var pathExists = require_path_exists().pathExists;
            function symlinkPaths(srcpath, dstpath, callback) {
              if (path7.isAbsolute(srcpath)) {
                return fs3.lstat(srcpath, (err) => {
                  if (err) {
                    err.message = err.message.replace("lstat", "ensureSymlink");
                    return callback(err);
                  }
                  return callback(null, {
                    toCwd: srcpath,
                    toDst: srcpath
                  });
                });
              } else {
                const dstdir = path7.dirname(dstpath);
                const relativeToDst = path7.join(dstdir, srcpath);
                return pathExists(relativeToDst, (err, exists) => {
                  if (err)
                    return callback(err);
                  if (exists) {
                    return callback(null, {
                      toCwd: relativeToDst,
                      toDst: srcpath
                    });
                  } else {
                    return fs3.lstat(srcpath, (err2) => {
                      if (err2) {
                        err2.message = err2.message.replace("lstat", "ensureSymlink");
                        return callback(err2);
                      }
                      return callback(null, {
                        toCwd: srcpath,
                        toDst: path7.relative(dstdir, srcpath)
                      });
                    });
                  }
                });
              }
            }
            function symlinkPathsSync(srcpath, dstpath) {
              let exists;
              if (path7.isAbsolute(srcpath)) {
                exists = fs3.existsSync(srcpath);
                if (!exists)
                  throw new Error("absolute srcpath does not exist");
                return {
                  toCwd: srcpath,
                  toDst: srcpath
                };
              } else {
                const dstdir = path7.dirname(dstpath);
                const relativeToDst = path7.join(dstdir, srcpath);
                exists = fs3.existsSync(relativeToDst);
                if (exists) {
                  return {
                    toCwd: relativeToDst,
                    toDst: srcpath
                  };
                } else {
                  exists = fs3.existsSync(srcpath);
                  if (!exists)
                    throw new Error("relative srcpath does not exist");
                  return {
                    toCwd: srcpath,
                    toDst: path7.relative(dstdir, srcpath)
                  };
                }
              }
            }
            module22.exports = {
              symlinkPaths,
              symlinkPathsSync
            };
          }
        });
        var require_symlink_type = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/symlink-type.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            function symlinkType(srcpath, type, callback) {
              callback = typeof type === "function" ? type : callback;
              type = typeof type === "function" ? false : type;
              if (type)
                return callback(null, type);
              fs3.lstat(srcpath, (err, stats) => {
                if (err)
                  return callback(null, "file");
                type = stats && stats.isDirectory() ? "dir" : "file";
                callback(null, type);
              });
            }
            function symlinkTypeSync(srcpath, type) {
              let stats;
              if (type)
                return type;
              try {
                stats = fs3.lstatSync(srcpath);
              } catch (e) {
                return "file";
              }
              return stats && stats.isDirectory() ? "dir" : "file";
            }
            module22.exports = {
              symlinkType,
              symlinkTypeSync
            };
          }
        });
        var require_symlink = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/symlink.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            var path7 = require("path");
            var fs3 = require_fs();
            var _mkdirs = require_mkdirs();
            var mkdirs = _mkdirs.mkdirs;
            var mkdirsSync = _mkdirs.mkdirsSync;
            var _symlinkPaths = require_symlink_paths();
            var symlinkPaths = _symlinkPaths.symlinkPaths;
            var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
            var _symlinkType = require_symlink_type();
            var symlinkType = _symlinkType.symlinkType;
            var symlinkTypeSync = _symlinkType.symlinkTypeSync;
            var pathExists = require_path_exists().pathExists;
            var { areIdentical } = require_stat();
            function createSymlink(srcpath, dstpath, type, callback) {
              callback = typeof type === "function" ? type : callback;
              type = typeof type === "function" ? false : type;
              fs3.lstat(dstpath, (err, stats) => {
                if (!err && stats.isSymbolicLink()) {
                  Promise.all([
                    fs3.stat(srcpath),
                    fs3.stat(dstpath)
                  ]).then(([srcStat, dstStat]) => {
                    if (areIdentical(srcStat, dstStat))
                      return callback(null);
                    _createSymlink(srcpath, dstpath, type, callback);
                  });
                } else
                  _createSymlink(srcpath, dstpath, type, callback);
              });
            }
            function _createSymlink(srcpath, dstpath, type, callback) {
              symlinkPaths(srcpath, dstpath, (err, relative) => {
                if (err)
                  return callback(err);
                srcpath = relative.toDst;
                symlinkType(relative.toCwd, type, (err2, type2) => {
                  if (err2)
                    return callback(err2);
                  const dir = path7.dirname(dstpath);
                  pathExists(dir, (err3, dirExists) => {
                    if (err3)
                      return callback(err3);
                    if (dirExists)
                      return fs3.symlink(srcpath, dstpath, type2, callback);
                    mkdirs(dir, (err4) => {
                      if (err4)
                        return callback(err4);
                      fs3.symlink(srcpath, dstpath, type2, callback);
                    });
                  });
                });
              });
            }
            function createSymlinkSync(srcpath, dstpath, type) {
              let stats;
              try {
                stats = fs3.lstatSync(dstpath);
              } catch (e) {
              }
              if (stats && stats.isSymbolicLink()) {
                const srcStat = fs3.statSync(srcpath);
                const dstStat = fs3.statSync(dstpath);
                if (areIdentical(srcStat, dstStat))
                  return;
              }
              const relative = symlinkPathsSync(srcpath, dstpath);
              srcpath = relative.toDst;
              type = symlinkTypeSync(relative.toCwd, type);
              const dir = path7.dirname(dstpath);
              const exists = fs3.existsSync(dir);
              if (exists)
                return fs3.symlinkSync(srcpath, dstpath, type);
              mkdirsSync(dir);
              return fs3.symlinkSync(srcpath, dstpath, type);
            }
            module22.exports = {
              createSymlink: u4(createSymlink),
              createSymlinkSync
            };
          }
        });
        var require_ensure = __commonJS22({
          "../../node_modules/fs-extra/lib/ensure/index.js"(exports22, module22) {
            "use strict";
            var file = require_file();
            var link = require_link();
            var symlink = require_symlink();
            module22.exports = {
              createFile: file.createFile,
              createFileSync: file.createFileSync,
              ensureFile: file.createFile,
              ensureFileSync: file.createFileSync,
              createLink: link.createLink,
              createLinkSync: link.createLinkSync,
              ensureLink: link.createLink,
              ensureLinkSync: link.createLinkSync,
              createSymlink: symlink.createSymlink,
              createSymlinkSync: symlink.createSymlinkSync,
              ensureSymlink: symlink.createSymlink,
              ensureSymlinkSync: symlink.createSymlinkSync
            };
          }
        });
        var require_utils22 = __commonJS22({
          "../../node_modules/jsonfile/utils.js"(exports22, module22) {
            function stringify2(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
              const EOF = finalEOL ? EOL : "";
              const str = JSON.stringify(obj, replacer, spaces);
              return str.replace(/\n/g, EOL) + EOF;
            }
            function stripBom(content) {
              if (Buffer.isBuffer(content))
                content = content.toString("utf8");
              return content.replace(/^\uFEFF/, "");
            }
            module22.exports = { stringify: stringify2, stripBom };
          }
        });
        var require_jsonfile = __commonJS22({
          "../../node_modules/jsonfile/index.js"(exports22, module22) {
            var _fs;
            try {
              _fs = require_graceful_fs();
            } catch (_) {
              _fs = require("fs");
            }
            var universalify = require_universalify();
            var { stringify: stringify2, stripBom } = require_utils22();
            function _readFile(_0) {
              return __async2(this, arguments, function* (file, options = {}) {
                if (typeof options === "string") {
                  options = { encoding: options };
                }
                const fs3 = options.fs || _fs;
                const shouldThrow = "throws" in options ? options.throws : true;
                let data = yield universalify.fromCallback(fs3.readFile)(file, options);
                data = stripBom(data);
                let obj;
                try {
                  obj = JSON.parse(data, options ? options.reviver : null);
                } catch (err) {
                  if (shouldThrow) {
                    err.message = `${file}: ${err.message}`;
                    throw err;
                  } else {
                    return null;
                  }
                }
                return obj;
              });
            }
            var readFile = universalify.fromPromise(_readFile);
            function readFileSync3(file, options = {}) {
              if (typeof options === "string") {
                options = { encoding: options };
              }
              const fs3 = options.fs || _fs;
              const shouldThrow = "throws" in options ? options.throws : true;
              try {
                let content = fs3.readFileSync(file, options);
                content = stripBom(content);
                return JSON.parse(content, options.reviver);
              } catch (err) {
                if (shouldThrow) {
                  err.message = `${file}: ${err.message}`;
                  throw err;
                } else {
                  return null;
                }
              }
            }
            function _writeFile(_0, _1) {
              return __async2(this, arguments, function* (file, obj, options = {}) {
                const fs3 = options.fs || _fs;
                const str = stringify2(obj, options);
                yield universalify.fromCallback(fs3.writeFile)(file, str, options);
              });
            }
            var writeFile = universalify.fromPromise(_writeFile);
            function writeFileSync3(file, obj, options = {}) {
              const fs3 = options.fs || _fs;
              const str = stringify2(obj, options);
              return fs3.writeFileSync(file, str, options);
            }
            var jsonfile = {
              readFile,
              readFileSync: readFileSync3,
              writeFile,
              writeFileSync: writeFileSync3
            };
            module22.exports = jsonfile;
          }
        });
        var require_jsonfile2 = __commonJS22({
          "../../node_modules/fs-extra/lib/json/jsonfile.js"(exports22, module22) {
            "use strict";
            var jsonFile = require_jsonfile();
            module22.exports = {
              readJson: jsonFile.readFile,
              readJsonSync: jsonFile.readFileSync,
              writeJson: jsonFile.writeFile,
              writeJsonSync: jsonFile.writeFileSync
            };
          }
        });
        var require_output = __commonJS22({
          "../../node_modules/fs-extra/lib/output/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var mkdir = require_mkdirs();
            var pathExists = require_path_exists().pathExists;
            function outputFile(file, data, encoding, callback) {
              if (typeof encoding === "function") {
                callback = encoding;
                encoding = "utf8";
              }
              const dir = path7.dirname(file);
              pathExists(dir, (err, itDoes) => {
                if (err)
                  return callback(err);
                if (itDoes)
                  return fs3.writeFile(file, data, encoding, callback);
                mkdir.mkdirs(dir, (err2) => {
                  if (err2)
                    return callback(err2);
                  fs3.writeFile(file, data, encoding, callback);
                });
              });
            }
            function outputFileSync(file, ...args) {
              const dir = path7.dirname(file);
              if (fs3.existsSync(dir)) {
                return fs3.writeFileSync(file, ...args);
              }
              mkdir.mkdirsSync(dir);
              fs3.writeFileSync(file, ...args);
            }
            module22.exports = {
              outputFile: u4(outputFile),
              outputFileSync
            };
          }
        });
        var require_output_json = __commonJS22({
          "../../node_modules/fs-extra/lib/json/output-json.js"(exports22, module22) {
            "use strict";
            var { stringify: stringify2 } = require_utils22();
            var { outputFile } = require_output();
            function outputJson(_0, _1) {
              return __async2(this, arguments, function* (file, data, options = {}) {
                const str = stringify2(data, options);
                yield outputFile(file, str, options);
              });
            }
            module22.exports = outputJson;
          }
        });
        var require_output_json_sync = __commonJS22({
          "../../node_modules/fs-extra/lib/json/output-json-sync.js"(exports22, module22) {
            "use strict";
            var { stringify: stringify2 } = require_utils22();
            var { outputFileSync } = require_output();
            function outputJsonSync(file, data, options) {
              const str = stringify2(data, options);
              outputFileSync(file, str, options);
            }
            module22.exports = outputJsonSync;
          }
        });
        var require_json = __commonJS22({
          "../../node_modules/fs-extra/lib/json/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromPromise;
            var jsonFile = require_jsonfile2();
            jsonFile.outputJson = u4(require_output_json());
            jsonFile.outputJsonSync = require_output_json_sync();
            jsonFile.outputJSON = jsonFile.outputJson;
            jsonFile.outputJSONSync = jsonFile.outputJsonSync;
            jsonFile.writeJSON = jsonFile.writeJson;
            jsonFile.writeJSONSync = jsonFile.writeJsonSync;
            jsonFile.readJSON = jsonFile.readJson;
            jsonFile.readJSONSync = jsonFile.readJsonSync;
            module22.exports = jsonFile;
          }
        });
        var require_move_sync = __commonJS22({
          "../../node_modules/fs-extra/lib/move-sync/move-sync.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var copySync = require_copy_sync2().copySync;
            var removeSync = require_remove().removeSync;
            var mkdirpSync = require_mkdirs().mkdirpSync;
            var stat = require_stat();
            function moveSync(src, dest, opts) {
              opts = opts || {};
              const overwrite = opts.overwrite || opts.clobber || false;
              const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
              stat.checkParentPathsSync(src, srcStat, dest, "move");
              if (!isParentRoot(dest))
                mkdirpSync(path7.dirname(dest));
              return doRename(src, dest, overwrite, isChangingCase);
            }
            function isParentRoot(dest) {
              const parent = path7.dirname(dest);
              const parsedPath = path7.parse(parent);
              return parsedPath.root === parent;
            }
            function doRename(src, dest, overwrite, isChangingCase) {
              if (isChangingCase)
                return rename(src, dest, overwrite);
              if (overwrite) {
                removeSync(dest);
                return rename(src, dest, overwrite);
              }
              if (fs3.existsSync(dest))
                throw new Error("dest already exists.");
              return rename(src, dest, overwrite);
            }
            function rename(src, dest, overwrite) {
              try {
                fs3.renameSync(src, dest);
              } catch (err) {
                if (err.code !== "EXDEV")
                  throw err;
                return moveAcrossDevice(src, dest, overwrite);
              }
            }
            function moveAcrossDevice(src, dest, overwrite) {
              const opts = {
                overwrite,
                errorOnExist: true
              };
              copySync(src, dest, opts);
              return removeSync(src);
            }
            module22.exports = moveSync;
          }
        });
        var require_move_sync2 = __commonJS22({
          "../../node_modules/fs-extra/lib/move-sync/index.js"(exports22, module22) {
            "use strict";
            module22.exports = {
              moveSync: require_move_sync()
            };
          }
        });
        var require_move = __commonJS22({
          "../../node_modules/fs-extra/lib/move/move.js"(exports22, module22) {
            "use strict";
            var fs3 = require_graceful_fs();
            var path7 = require("path");
            var copy = require_copy2().copy;
            var remove = require_remove().remove;
            var mkdirp = require_mkdirs().mkdirp;
            var pathExists = require_path_exists().pathExists;
            var stat = require_stat();
            function move(src, dest, opts, cb) {
              if (typeof opts === "function") {
                cb = opts;
                opts = {};
              }
              const overwrite = opts.overwrite || opts.clobber || false;
              stat.checkPaths(src, dest, "move", opts, (err, stats) => {
                if (err)
                  return cb(err);
                const { srcStat, isChangingCase = false } = stats;
                stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
                  if (err2)
                    return cb(err2);
                  if (isParentRoot(dest))
                    return doRename(src, dest, overwrite, isChangingCase, cb);
                  mkdirp(path7.dirname(dest), (err3) => {
                    if (err3)
                      return cb(err3);
                    return doRename(src, dest, overwrite, isChangingCase, cb);
                  });
                });
              });
            }
            function isParentRoot(dest) {
              const parent = path7.dirname(dest);
              const parsedPath = path7.parse(parent);
              return parsedPath.root === parent;
            }
            function doRename(src, dest, overwrite, isChangingCase, cb) {
              if (isChangingCase)
                return rename(src, dest, overwrite, cb);
              if (overwrite) {
                return remove(dest, (err) => {
                  if (err)
                    return cb(err);
                  return rename(src, dest, overwrite, cb);
                });
              }
              pathExists(dest, (err, destExists) => {
                if (err)
                  return cb(err);
                if (destExists)
                  return cb(new Error("dest already exists."));
                return rename(src, dest, overwrite, cb);
              });
            }
            function rename(src, dest, overwrite, cb) {
              fs3.rename(src, dest, (err) => {
                if (!err)
                  return cb();
                if (err.code !== "EXDEV")
                  return cb(err);
                return moveAcrossDevice(src, dest, overwrite, cb);
              });
            }
            function moveAcrossDevice(src, dest, overwrite, cb) {
              const opts = {
                overwrite,
                errorOnExist: true
              };
              copy(src, dest, opts, (err) => {
                if (err)
                  return cb(err);
                return remove(src, cb);
              });
            }
            module22.exports = move;
          }
        });
        var require_move2 = __commonJS22({
          "../../node_modules/fs-extra/lib/move/index.js"(exports22, module22) {
            "use strict";
            var u4 = require_universalify().fromCallback;
            module22.exports = {
              move: u4(require_move())
            };
          }
        });
        var require_lib = __commonJS22({
          "../../node_modules/fs-extra/lib/index.js"(exports22, module22) {
            "use strict";
            module22.exports = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, require_fs()), require_copy_sync2()), require_copy2()), require_empty()), require_ensure()), require_json()), require_mkdirs()), require_move_sync2()), require_move2()), require_output()), require_path_exists()), require_remove());
          }
        });
        var require_Node22 = __commonJS22({
          "node_modules/yaml/dist/nodes/Node.js"(exports22) {
            "use strict";
            var ALIAS = Symbol.for("yaml.alias");
            var DOC = Symbol.for("yaml.document");
            var MAP = Symbol.for("yaml.map");
            var PAIR = Symbol.for("yaml.pair");
            var SCALAR = Symbol.for("yaml.scalar");
            var SEQ = Symbol.for("yaml.seq");
            var NODE_TYPE = Symbol.for("yaml.node.type");
            var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
            var isDocument2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
            var isMap2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
            var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
            var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
            var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
            function isCollection(node) {
              if (node && typeof node === "object")
                switch (node[NODE_TYPE]) {
                  case MAP:
                  case SEQ:
                    return true;
                }
              return false;
            }
            function isNode(node) {
              if (node && typeof node === "object")
                switch (node[NODE_TYPE]) {
                  case ALIAS:
                  case MAP:
                  case SCALAR:
                  case SEQ:
                    return true;
                }
              return false;
            }
            var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
            var NodeBase = class {
              constructor(type) {
                Object.defineProperty(this, NODE_TYPE, { value: type });
              }
            };
            exports22.ALIAS = ALIAS;
            exports22.DOC = DOC;
            exports22.MAP = MAP;
            exports22.NODE_TYPE = NODE_TYPE;
            exports22.NodeBase = NodeBase;
            exports22.PAIR = PAIR;
            exports22.SCALAR = SCALAR;
            exports22.SEQ = SEQ;
            exports22.hasAnchor = hasAnchor;
            exports22.isAlias = isAlias;
            exports22.isCollection = isCollection;
            exports22.isDocument = isDocument2;
            exports22.isMap = isMap2;
            exports22.isNode = isNode;
            exports22.isPair = isPair;
            exports22.isScalar = isScalar;
            exports22.isSeq = isSeq;
          }
        });
        var require_visit22 = __commonJS22({
          "node_modules/yaml/dist/visit.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var BREAK = Symbol("break visit");
            var SKIP = Symbol("skip children");
            var REMOVE = Symbol("remove node");
            function visit(node, visitor) {
              if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
                visitor = Object.assign({
                  Alias: visitor.Node,
                  Map: visitor.Node,
                  Scalar: visitor.Node,
                  Seq: visitor.Node
                }, visitor.Value && {
                  Map: visitor.Value,
                  Scalar: visitor.Value,
                  Seq: visitor.Value
                }, visitor.Collection && {
                  Map: visitor.Collection,
                  Seq: visitor.Collection
                }, visitor);
              }
              if (Node.isDocument(node)) {
                const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
                if (cd === REMOVE)
                  node.contents = null;
              } else
                _visit(null, node, visitor, Object.freeze([]));
            }
            visit.BREAK = BREAK;
            visit.SKIP = SKIP;
            visit.REMOVE = REMOVE;
            function _visit(key, node, visitor, path7) {
              let ctrl = void 0;
              if (typeof visitor === "function")
                ctrl = visitor(key, node, path7);
              else if (Node.isMap(node)) {
                if (visitor.Map)
                  ctrl = visitor.Map(key, node, path7);
              } else if (Node.isSeq(node)) {
                if (visitor.Seq)
                  ctrl = visitor.Seq(key, node, path7);
              } else if (Node.isPair(node)) {
                if (visitor.Pair)
                  ctrl = visitor.Pair(key, node, path7);
              } else if (Node.isScalar(node)) {
                if (visitor.Scalar)
                  ctrl = visitor.Scalar(key, node, path7);
              } else if (Node.isAlias(node)) {
                if (visitor.Alias)
                  ctrl = visitor.Alias(key, node, path7);
              }
              if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
                const parent = path7[path7.length - 1];
                if (Node.isCollection(parent)) {
                  parent.items[key] = ctrl;
                } else if (Node.isPair(parent)) {
                  if (key === "key")
                    parent.key = ctrl;
                  else
                    parent.value = ctrl;
                } else if (Node.isDocument(parent)) {
                  parent.contents = ctrl;
                } else {
                  const pt = Node.isAlias(parent) ? "alias" : "scalar";
                  throw new Error(`Cannot replace node with ${pt} parent`);
                }
                return _visit(key, ctrl, visitor, path7);
              }
              if (typeof ctrl !== "symbol") {
                if (Node.isCollection(node)) {
                  path7 = Object.freeze(path7.concat(node));
                  for (let i = 0; i < node.items.length; ++i) {
                    const ci = _visit(i, node.items[i], visitor, path7);
                    if (typeof ci === "number")
                      i = ci - 1;
                    else if (ci === BREAK)
                      return BREAK;
                    else if (ci === REMOVE) {
                      node.items.splice(i, 1);
                      i -= 1;
                    }
                  }
                } else if (Node.isPair(node)) {
                  path7 = Object.freeze(path7.concat(node));
                  const ck = _visit("key", node.key, visitor, path7);
                  if (ck === BREAK)
                    return BREAK;
                  else if (ck === REMOVE)
                    node.key = null;
                  const cv = _visit("value", node.value, visitor, path7);
                  if (cv === BREAK)
                    return BREAK;
                  else if (cv === REMOVE)
                    node.value = null;
                }
              }
              return ctrl;
            }
            exports22.visit = visit;
          }
        });
        var require_directives22 = __commonJS22({
          "node_modules/yaml/dist/doc/directives.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var visit = require_visit22();
            var escapeChars = {
              "!": "%21",
              ",": "%2C",
              "[": "%5B",
              "]": "%5D",
              "{": "%7B",
              "}": "%7D"
            };
            var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
            var Directives = class {
              constructor(yaml2, tags) {
                this.marker = null;
                this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
                this.tags = Object.assign({}, Directives.defaultTags, tags);
              }
              atDocument() {
                const res = new Directives(this.yaml, this.tags);
                switch (this.yaml.version) {
                  case "1.1":
                    this.atNextDocument = true;
                    break;
                  case "1.2":
                    this.atNextDocument = false;
                    this.yaml = {
                      explicit: Directives.defaultYaml.explicit,
                      version: "1.2"
                    };
                    this.tags = Object.assign({}, Directives.defaultTags);
                    break;
                }
                return res;
              }
              add(line, onError) {
                if (this.atNextDocument) {
                  this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
                  this.tags = Object.assign({}, Directives.defaultTags);
                  this.atNextDocument = false;
                }
                const parts = line.trim().split(/[ \t]+/);
                const name = parts.shift();
                switch (name) {
                  case "%TAG": {
                    if (parts.length !== 2) {
                      onError(0, "%TAG directive should contain exactly two parts");
                      if (parts.length < 2)
                        return false;
                    }
                    const [handle, prefix] = parts;
                    this.tags[handle] = prefix;
                    return true;
                  }
                  case "%YAML": {
                    this.yaml.explicit = true;
                    if (parts.length < 1) {
                      onError(0, "%YAML directive should contain exactly one part");
                      return false;
                    }
                    const [version] = parts;
                    if (version === "1.1" || version === "1.2") {
                      this.yaml.version = version;
                      return true;
                    } else {
                      onError(6, `Unsupported YAML version ${version}`, true);
                      return false;
                    }
                  }
                  default:
                    onError(0, `Unknown directive ${name}`, true);
                    return false;
                }
              }
              tagName(source, onError) {
                if (source === "!")
                  return "!";
                if (source[0] !== "!") {
                  onError(`Not a valid tag: ${source}`);
                  return null;
                }
                if (source[1] === "<") {
                  const verbatim = source.slice(2, -1);
                  if (verbatim === "!" || verbatim === "!!") {
                    onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                    return null;
                  }
                  if (source[source.length - 1] !== ">")
                    onError("Verbatim tags must end with a >");
                  return verbatim;
                }
                const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
                if (!suffix)
                  onError(`The ${source} tag has no suffix`);
                const prefix = this.tags[handle];
                if (prefix)
                  return prefix + decodeURIComponent(suffix);
                if (handle === "!")
                  return source;
                onError(`Could not resolve tag: ${source}`);
                return null;
              }
              tagString(tag) {
                for (const [handle, prefix] of Object.entries(this.tags)) {
                  if (tag.startsWith(prefix))
                    return handle + escapeTagName(tag.substring(prefix.length));
                }
                return tag[0] === "!" ? tag : `!<${tag}>`;
              }
              toString(doc) {
                const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
                const tagEntries = Object.entries(this.tags);
                let tagNames;
                if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
                  const tags = {};
                  visit.visit(doc.contents, (_key, node) => {
                    if (Node.isNode(node) && node.tag)
                      tags[node.tag] = true;
                  });
                  tagNames = Object.keys(tags);
                } else
                  tagNames = [];
                for (const [handle, prefix] of tagEntries) {
                  if (handle === "!!" && prefix === "tag:yaml.org,2002:")
                    continue;
                  if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
                    lines.push(`%TAG ${handle} ${prefix}`);
                }
                return lines.join("\n");
              }
            };
            Directives.defaultYaml = { explicit: false, version: "1.2" };
            Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
            exports22.Directives = Directives;
          }
        });
        var require_anchors22 = __commonJS22({
          "node_modules/yaml/dist/doc/anchors.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var visit = require_visit22();
            function anchorIsValid(anchor) {
              if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
                const sa = JSON.stringify(anchor);
                const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
                throw new Error(msg);
              }
              return true;
            }
            function anchorNames(root) {
              const anchors = new Set();
              visit.visit(root, {
                Value(_key, node) {
                  if (node.anchor)
                    anchors.add(node.anchor);
                }
              });
              return anchors;
            }
            function findNewAnchor(prefix, exclude) {
              for (let i = 1; true; ++i) {
                const name = `${prefix}${i}`;
                if (!exclude.has(name))
                  return name;
              }
            }
            function createNodeAnchors(doc, prefix) {
              const aliasObjects = [];
              const sourceObjects = new Map();
              let prevAnchors = null;
              return {
                onAnchor(source) {
                  aliasObjects.push(source);
                  if (!prevAnchors)
                    prevAnchors = anchorNames(doc);
                  const anchor = findNewAnchor(prefix, prevAnchors);
                  prevAnchors.add(anchor);
                  return anchor;
                },
                setAnchors() {
                  for (const source of aliasObjects) {
                    const ref = sourceObjects.get(source);
                    if (typeof ref === "object" && ref.anchor && (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
                      ref.node.anchor = ref.anchor;
                    } else {
                      const error = new Error("Failed to resolve repeated object (this should not happen)");
                      error.source = source;
                      throw error;
                    }
                  }
                },
                sourceObjects
              };
            }
            exports22.anchorIsValid = anchorIsValid;
            exports22.anchorNames = anchorNames;
            exports22.createNodeAnchors = createNodeAnchors;
            exports22.findNewAnchor = findNewAnchor;
          }
        });
        var require_Alias22 = __commonJS22({
          "node_modules/yaml/dist/nodes/Alias.js"(exports22) {
            "use strict";
            var anchors = require_anchors22();
            var visit = require_visit22();
            var Node = require_Node22();
            var Alias = class extends Node.NodeBase {
              constructor(source) {
                super(Node.ALIAS);
                this.source = source;
                Object.defineProperty(this, "tag", {
                  set() {
                    throw new Error("Alias nodes cannot have tags");
                  }
                });
              }
              resolve(doc) {
                let found = void 0;
                visit.visit(doc, {
                  Node: (_key, node) => {
                    if (node === this)
                      return visit.visit.BREAK;
                    if (node.anchor === this.source)
                      found = node;
                  }
                });
                return found;
              }
              toJSON(_arg, ctx) {
                if (!ctx)
                  return { source: this.source };
                const { anchors: anchors2, doc, maxAliasCount } = ctx;
                const source = this.resolve(doc);
                if (!source) {
                  const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                  throw new ReferenceError(msg);
                }
                const data = anchors2.get(source);
                if (!data || data.res === void 0) {
                  const msg = "This should not happen: Alias anchor was not resolved?";
                  throw new ReferenceError(msg);
                }
                if (maxAliasCount >= 0) {
                  data.count += 1;
                  if (data.aliasCount === 0)
                    data.aliasCount = getAliasCount(doc, source, anchors2);
                  if (data.count * data.aliasCount > maxAliasCount) {
                    const msg = "Excessive alias count indicates a resource exhaustion attack";
                    throw new ReferenceError(msg);
                  }
                }
                return data.res;
              }
              toString(ctx, _onComment, _onChompKeep) {
                const src = `*${this.source}`;
                if (ctx) {
                  anchors.anchorIsValid(this.source);
                  if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                    const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                    throw new Error(msg);
                  }
                  if (ctx.implicitKey)
                    return `${src} `;
                }
                return src;
              }
            };
            function getAliasCount(doc, node, anchors2) {
              if (Node.isAlias(node)) {
                const source = node.resolve(doc);
                const anchor = anchors2 && source && anchors2.get(source);
                return anchor ? anchor.count * anchor.aliasCount : 0;
              } else if (Node.isCollection(node)) {
                let count = 0;
                for (const item of node.items) {
                  const c2 = getAliasCount(doc, item, anchors2);
                  if (c2 > count)
                    count = c2;
                }
                return count;
              } else if (Node.isPair(node)) {
                const kc = getAliasCount(doc, node.key, anchors2);
                const vc = getAliasCount(doc, node.value, anchors2);
                return Math.max(kc, vc);
              }
              return 1;
            }
            exports22.Alias = Alias;
          }
        });
        var require_toJS22 = __commonJS22({
          "node_modules/yaml/dist/nodes/toJS.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            function toJS(value, arg, ctx) {
              if (Array.isArray(value))
                return value.map((v, i) => toJS(v, String(i), ctx));
              if (value && typeof value.toJSON === "function") {
                if (!ctx || !Node.hasAnchor(value))
                  return value.toJSON(arg, ctx);
                const data = { aliasCount: 0, count: 1, res: void 0 };
                ctx.anchors.set(value, data);
                ctx.onCreate = (res2) => {
                  data.res = res2;
                  delete ctx.onCreate;
                };
                const res = value.toJSON(arg, ctx);
                if (ctx.onCreate)
                  ctx.onCreate(res);
                return res;
              }
              if (typeof value === "bigint" && !(ctx && ctx.keep))
                return Number(value);
              return value;
            }
            exports22.toJS = toJS;
          }
        });
        var require_Scalar22 = __commonJS22({
          "node_modules/yaml/dist/nodes/Scalar.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var toJS = require_toJS22();
            var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
            var Scalar2 = class extends Node.NodeBase {
              constructor(value) {
                super(Node.SCALAR);
                this.value = value;
              }
              toJSON(arg, ctx) {
                return ctx && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
              }
              toString() {
                return String(this.value);
              }
            };
            Scalar2.BLOCK_FOLDED = "BLOCK_FOLDED";
            Scalar2.BLOCK_LITERAL = "BLOCK_LITERAL";
            Scalar2.PLAIN = "PLAIN";
            Scalar2.QUOTE_DOUBLE = "QUOTE_DOUBLE";
            Scalar2.QUOTE_SINGLE = "QUOTE_SINGLE";
            exports22.Scalar = Scalar2;
            exports22.isScalarValue = isScalarValue;
          }
        });
        var require_createNode22 = __commonJS22({
          "node_modules/yaml/dist/doc/createNode.js"(exports22) {
            "use strict";
            var Alias = require_Alias22();
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var defaultTagPrefix = "tag:yaml.org,2002:";
            function findTagObject(value, tagName, tags) {
              if (tagName) {
                const match = tags.filter((t) => t.tag === tagName);
                const tagObj = match.find((t) => !t.format) || match[0];
                if (!tagObj)
                  throw new Error(`Tag ${tagName} not found`);
                return tagObj;
              }
              return tags.find((t) => t.identify && t.identify(value) && !t.format);
            }
            function createNode(value, tagName, ctx) {
              var _a, _b;
              if (Node.isNode(value))
                return value;
              if (Node.isPair(value)) {
                const map = (_b = (_a = ctx.schema[Node.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
                map.items.push(value);
                return map;
              }
              if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
                value = value.valueOf();
              }
              const { onAnchor, onTagObj, schema, sourceObjects } = ctx;
              let ref = void 0;
              if (value && typeof value === "object") {
                ref = sourceObjects.get(value);
                if (ref) {
                  if (!ref.anchor)
                    ref.anchor = onAnchor(value);
                  return new Alias.Alias(ref.anchor);
                } else {
                  ref = { anchor: null, node: null };
                  sourceObjects.set(value, ref);
                }
              }
              if (tagName && tagName.startsWith("!!"))
                tagName = defaultTagPrefix + tagName.slice(2);
              let tagObj = findTagObject(value, tagName, schema.tags);
              if (!tagObj) {
                if (value && typeof value.toJSON === "function")
                  value = value.toJSON();
                if (!value || typeof value !== "object")
                  return new Scalar2.Scalar(value);
                tagObj = value instanceof Map ? schema[Node.MAP] : Symbol.iterator in Object(value) ? schema[Node.SEQ] : schema[Node.MAP];
              }
              if (onTagObj) {
                onTagObj(tagObj);
                delete ctx.onTagObj;
              }
              const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar2.Scalar(value);
              if (tagName)
                node.tag = tagName;
              if (ref)
                ref.node = node;
              return node;
            }
            exports22.createNode = createNode;
          }
        });
        var require_Collection22 = __commonJS22({
          "node_modules/yaml/dist/nodes/Collection.js"(exports22) {
            "use strict";
            var createNode = require_createNode22();
            var Node = require_Node22();
            function collectionFromPath(schema, path7, value) {
              let v = value;
              for (let i = path7.length - 1; i >= 0; --i) {
                const k = path7[i];
                if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
                  const a = [];
                  a[k] = v;
                  v = a;
                } else {
                  const o = {};
                  Object.defineProperty(o, typeof k === "symbol" ? k : String(k), {
                    value: v,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                  v = o;
                }
              }
              return createNode.createNode(v, void 0, {
                onAnchor() {
                  throw new Error("Repeated objects are not supported here");
                },
                schema,
                sourceObjects: new Map()
              });
            }
            var isEmptyPath = (path7) => path7 == null || typeof path7 === "object" && !!path7[Symbol.iterator]().next().done;
            var Collection = class extends Node.NodeBase {
              constructor(type, schema) {
                super(type);
                Object.defineProperty(this, "schema", {
                  value: schema,
                  configurable: true,
                  enumerable: false,
                  writable: true
                });
              }
              addIn(path7, value) {
                if (isEmptyPath(path7))
                  this.add(value);
                else {
                  const [key, ...rest] = path7;
                  const node = this.get(key, true);
                  if (Node.isCollection(node))
                    node.addIn(rest, value);
                  else if (node === void 0 && this.schema)
                    this.set(key, collectionFromPath(this.schema, rest, value));
                  else
                    throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
                }
              }
              deleteIn([key, ...rest]) {
                if (rest.length === 0)
                  return this.delete(key);
                const node = this.get(key, true);
                if (Node.isCollection(node))
                  return node.deleteIn(rest);
                else
                  throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
              }
              getIn([key, ...rest], keepScalar) {
                const node = this.get(key, true);
                if (rest.length === 0)
                  return !keepScalar && Node.isScalar(node) ? node.value : node;
                else
                  return Node.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
              }
              hasAllNullValues(allowScalar) {
                return this.items.every((node) => {
                  if (!Node.isPair(node))
                    return false;
                  const n = node.value;
                  return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
                });
              }
              hasIn([key, ...rest]) {
                if (rest.length === 0)
                  return this.has(key);
                const node = this.get(key, true);
                return Node.isCollection(node) ? node.hasIn(rest) : false;
              }
              setIn([key, ...rest], value) {
                if (rest.length === 0) {
                  this.set(key, value);
                } else {
                  const node = this.get(key, true);
                  if (Node.isCollection(node))
                    node.setIn(rest, value);
                  else if (node === void 0 && this.schema)
                    this.set(key, collectionFromPath(this.schema, rest, value));
                  else
                    throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
                }
              }
            };
            Collection.maxFlowStringSingleLineLength = 60;
            exports22.Collection = Collection;
            exports22.collectionFromPath = collectionFromPath;
            exports22.isEmptyPath = isEmptyPath;
          }
        });
        var require_foldFlowLines22 = __commonJS22({
          "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports22) {
            "use strict";
            var FOLD_FLOW = "flow";
            var FOLD_BLOCK = "block";
            var FOLD_QUOTED = "quoted";
            function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
              if (!lineWidth || lineWidth < 0)
                return text;
              const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
              if (text.length <= endStep)
                return text;
              const folds = [];
              const escapedFolds = {};
              let end = lineWidth - indent.length;
              if (typeof indentAtStart === "number") {
                if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
                  folds.push(0);
                else
                  end = lineWidth - indentAtStart;
              }
              let split = void 0;
              let prev = void 0;
              let overflow = false;
              let i = -1;
              let escStart = -1;
              let escEnd = -1;
              if (mode === FOLD_BLOCK) {
                i = consumeMoreIndentedLines(text, i);
                if (i !== -1)
                  end = i + endStep;
              }
              for (let ch; ch = text[i += 1]; ) {
                if (mode === FOLD_QUOTED && ch === "\\") {
                  escStart = i;
                  switch (text[i + 1]) {
                    case "x":
                      i += 3;
                      break;
                    case "u":
                      i += 5;
                      break;
                    case "U":
                      i += 9;
                      break;
                    default:
                      i += 1;
                  }
                  escEnd = i;
                }
                if (ch === "\n") {
                  if (mode === FOLD_BLOCK)
                    i = consumeMoreIndentedLines(text, i);
                  end = i + endStep;
                  split = void 0;
                } else {
                  if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
                    const next = text[i + 1];
                    if (next && next !== " " && next !== "\n" && next !== "	")
                      split = i;
                  }
                  if (i >= end) {
                    if (split) {
                      folds.push(split);
                      end = split + endStep;
                      split = void 0;
                    } else if (mode === FOLD_QUOTED) {
                      while (prev === " " || prev === "	") {
                        prev = ch;
                        ch = text[i += 1];
                        overflow = true;
                      }
                      const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                      if (escapedFolds[j])
                        return text;
                      folds.push(j);
                      escapedFolds[j] = true;
                      end = j + endStep;
                      split = void 0;
                    } else {
                      overflow = true;
                    }
                  }
                }
                prev = ch;
              }
              if (overflow && onOverflow)
                onOverflow();
              if (folds.length === 0)
                return text;
              if (onFold)
                onFold();
              let res = text.slice(0, folds[0]);
              for (let i2 = 0; i2 < folds.length; ++i2) {
                const fold = folds[i2];
                const end2 = folds[i2 + 1] || text.length;
                if (fold === 0)
                  res = `
${indent}${text.slice(0, end2)}`;
                else {
                  if (mode === FOLD_QUOTED && escapedFolds[fold])
                    res += `${text[fold]}\\`;
                  res += `
${indent}${text.slice(fold + 1, end2)}`;
                }
              }
              return res;
            }
            function consumeMoreIndentedLines(text, i) {
              let ch = text[i + 1];
              while (ch === " " || ch === "	") {
                do {
                  ch = text[i += 1];
                } while (ch && ch !== "\n");
                ch = text[i + 1];
              }
              return i;
            }
            exports22.FOLD_BLOCK = FOLD_BLOCK;
            exports22.FOLD_FLOW = FOLD_FLOW;
            exports22.FOLD_QUOTED = FOLD_QUOTED;
            exports22.foldFlowLines = foldFlowLines;
          }
        });
        var require_stringifyString22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyString.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var foldFlowLines = require_foldFlowLines22();
            var getFoldOptions = (ctx) => ({
              indentAtStart: ctx.indentAtStart,
              lineWidth: ctx.options.lineWidth,
              minContentWidth: ctx.options.minContentWidth
            });
            var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
            function lineLengthOverLimit(str, lineWidth, indentLength) {
              if (!lineWidth || lineWidth < 0)
                return false;
              const limit = lineWidth - indentLength;
              const strLen = str.length;
              if (strLen <= limit)
                return false;
              for (let i = 0, start = 0; i < strLen; ++i) {
                if (str[i] === "\n") {
                  if (i - start > limit)
                    return true;
                  start = i + 1;
                  if (strLen - start <= limit)
                    return false;
                }
              }
              return true;
            }
            function doubleQuotedString(value, ctx) {
              const json = JSON.stringify(value);
              if (ctx.options.doubleQuotedAsJSON)
                return json;
              const { implicitKey } = ctx;
              const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
              const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
              let str = "";
              let start = 0;
              for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
                if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
                  str += json.slice(start, i) + "\\ ";
                  i += 1;
                  start = i;
                  ch = "\\";
                }
                if (ch === "\\")
                  switch (json[i + 1]) {
                    case "u":
                      {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                          case "0000":
                            str += "\\0";
                            break;
                          case "0007":
                            str += "\\a";
                            break;
                          case "000b":
                            str += "\\v";
                            break;
                          case "001b":
                            str += "\\e";
                            break;
                          case "0085":
                            str += "\\N";
                            break;
                          case "00a0":
                            str += "\\_";
                            break;
                          case "2028":
                            str += "\\L";
                            break;
                          case "2029":
                            str += "\\P";
                            break;
                          default:
                            if (code.substr(0, 2) === "00")
                              str += "\\x" + code.substr(2);
                            else
                              str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                      }
                      break;
                    case "n":
                      if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                        i += 1;
                      } else {
                        str += json.slice(start, i) + "\n\n";
                        while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                          str += "\n";
                          i += 2;
                        }
                        str += indent;
                        if (json[i + 2] === " ")
                          str += "\\";
                        i += 1;
                        start = i + 1;
                      }
                      break;
                    default:
                      i += 1;
                  }
              }
              str = start ? str + json.slice(start) : json;
              return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
            }
            function singleQuotedString(value, ctx) {
              if (ctx.implicitKey) {
                if (/\n/.test(value))
                  return doubleQuotedString(value, ctx);
              } else {
                if (/[ \t]\n|\n[ \t]/.test(value))
                  return doubleQuotedString(value, ctx);
              }
              const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
              const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
              return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
            }
            function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
              if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
                return doubleQuotedString(value, ctx);
              }
              const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
              const literal = type === Scalar2.Scalar.BLOCK_FOLDED ? false : type === Scalar2.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, ctx.options.lineWidth, indent.length);
              if (!value)
                return literal ? "|\n" : ">\n";
              let chomp;
              let endStart;
              for (endStart = value.length; endStart > 0; --endStart) {
                const ch = value[endStart - 1];
                if (ch !== "\n" && ch !== "	" && ch !== " ")
                  break;
              }
              let end = value.substring(endStart);
              const endNlPos = end.indexOf("\n");
              if (endNlPos === -1) {
                chomp = "-";
              } else if (value === end || endNlPos !== end.length - 1) {
                chomp = "+";
                if (onChompKeep)
                  onChompKeep();
              } else {
                chomp = "";
              }
              if (end) {
                value = value.slice(0, -end.length);
                if (end[end.length - 1] === "\n")
                  end = end.slice(0, -1);
                end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
              }
              let startWithSpace = false;
              let startEnd;
              let startNlPos = -1;
              for (startEnd = 0; startEnd < value.length; ++startEnd) {
                const ch = value[startEnd];
                if (ch === " ")
                  startWithSpace = true;
                else if (ch === "\n")
                  startNlPos = startEnd;
                else
                  break;
              }
              let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
              if (start) {
                value = value.substring(start.length);
                start = start.replace(/\n+/g, `$&${indent}`);
              }
              const indentSize = indent ? "2" : "1";
              let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
              if (comment) {
                header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
                if (onComment)
                  onComment();
              }
              if (literal) {
                value = value.replace(/\n+/g, `$&${indent}`);
                return `${header}
${indent}${start}${value}${end}`;
              }
              value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
              const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
              return `${header}
${indent}${body}`;
            }
            function plainString(item, ctx, onComment, onChompKeep) {
              var _a;
              const { type, value } = item;
              const { actualString, implicitKey, indent, inFlow } = ctx;
              if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
                return doubleQuotedString(value, ctx);
              }
              if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
                const hasDouble = value.indexOf('"') !== -1;
                const hasSingle = value.indexOf("'") !== -1;
                let quotedString;
                if (hasDouble && !hasSingle) {
                  quotedString = singleQuotedString;
                } else if (hasSingle && !hasDouble) {
                  quotedString = doubleQuotedString;
                } else if (ctx.options.singleQuote) {
                  quotedString = singleQuotedString;
                } else {
                  quotedString = doubleQuotedString;
                }
                return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
              }
              if (!implicitKey && !inFlow && type !== Scalar2.Scalar.PLAIN && value.indexOf("\n") !== -1) {
                return blockString(item, ctx, onComment, onChompKeep);
              }
              if (indent === "" && containsDocumentMarker(value)) {
                ctx.forceBlockIndent = true;
                return blockString(item, ctx, onComment, onChompKeep);
              }
              const str = value.replace(/\n+/g, `$&
${indent}`);
              if (actualString) {
                for (const tag of ctx.doc.schema.tags) {
                  if (tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))
                    return doubleQuotedString(value, ctx);
                }
              }
              return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
            }
            function stringifyString(item, ctx, onComment, onChompKeep) {
              const { implicitKey, inFlow } = ctx;
              const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
              let { type } = item;
              if (type !== Scalar2.Scalar.QUOTE_DOUBLE) {
                if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
                  type = Scalar2.Scalar.QUOTE_DOUBLE;
              }
              const _stringify = (_type) => {
                switch (_type) {
                  case Scalar2.Scalar.BLOCK_FOLDED:
                  case Scalar2.Scalar.BLOCK_LITERAL:
                    return implicitKey || inFlow ? doubleQuotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
                  case Scalar2.Scalar.QUOTE_DOUBLE:
                    return doubleQuotedString(ss.value, ctx);
                  case Scalar2.Scalar.QUOTE_SINGLE:
                    return singleQuotedString(ss.value, ctx);
                  case Scalar2.Scalar.PLAIN:
                    return plainString(ss, ctx, onComment, onChompKeep);
                  default:
                    return null;
                }
              };
              let res = _stringify(type);
              if (res === null) {
                const { defaultKeyType, defaultStringType } = ctx.options;
                const t = implicitKey && defaultKeyType || defaultStringType;
                res = _stringify(t);
                if (res === null)
                  throw new Error(`Unsupported default string type ${t}`);
              }
              return res;
            }
            exports22.stringifyString = stringifyString;
          }
        });
        var require_stringify22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringify.js"(exports22) {
            "use strict";
            var anchors = require_anchors22();
            var Node = require_Node22();
            var stringifyString = require_stringifyString22();
            var createStringifyContext = (doc, options) => ({
              anchors: new Set(),
              doc,
              indent: "",
              indentStep: typeof options.indent === "number" ? " ".repeat(options.indent) : "  ",
              options: Object.assign({
                defaultKeyType: null,
                defaultStringType: "PLAIN",
                directives: null,
                doubleQuotedAsJSON: false,
                doubleQuotedMinMultiLineLength: 40,
                falseStr: "false",
                indentSeq: true,
                lineWidth: 80,
                minContentWidth: 20,
                nullStr: "null",
                simpleKeys: false,
                singleQuote: false,
                trueStr: "true",
                verifyAliasOrder: true
              }, options)
            });
            function getTagObject(tags, item) {
              if (item.tag) {
                const match = tags.filter((t) => t.tag === item.tag);
                if (match.length > 0)
                  return match.find((t) => t.format === item.format) || match[0];
              }
              let tagObj = void 0;
              let obj;
              if (Node.isScalar(item)) {
                obj = item.value;
                const match = tags.filter((t) => t.identify && t.identify(obj));
                tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
              } else {
                obj = item;
                tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
              }
              if (!tagObj) {
                const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
                throw new Error(`Tag not resolved for ${name} value`);
              }
              return tagObj;
            }
            function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
              const props = [];
              const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
              if (anchor && anchors.anchorIsValid(anchor)) {
                anchors$1.add(anchor);
                props.push(`&${anchor}`);
              }
              if (node.tag) {
                props.push(doc.directives.tagString(node.tag));
              } else if (!tagObj.default) {
                props.push(doc.directives.tagString(tagObj.tag));
              }
              return props.join(" ");
            }
            function stringify2(item, ctx, onComment, onChompKeep) {
              if (Node.isPair(item))
                return item.toString(ctx, onComment, onChompKeep);
              if (Node.isAlias(item))
                return item.toString(ctx);
              let tagObj = void 0;
              const node = Node.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
              if (!tagObj)
                tagObj = getTagObject(ctx.doc.schema.tags, node);
              const props = stringifyProps(node, tagObj, ctx);
              if (props.length > 0)
                ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
              const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : Node.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
              if (!props)
                return str;
              return Node.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
            }
            exports22.createStringifyContext = createStringifyContext;
            exports22.stringify = stringify2;
          }
        });
        var require_stringifyComment22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyComment.js"(exports22) {
            "use strict";
            var stringifyComment = (comment, indent) => /^\n+$/.test(comment) ? comment.substring(1) : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);
            function addComment(str, indent, comment) {
              return !comment ? str : comment.includes("\n") ? `${str}
` + stringifyComment(comment, indent) : str.endsWith(" ") ? `${str}#${comment}` : `${str} #${comment}`;
            }
            exports22.addComment = addComment;
            exports22.stringifyComment = stringifyComment;
          }
        });
        var require_stringifyPair22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyPair.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var stringify2 = require_stringify22();
            var stringifyComment = require_stringifyComment22();
            function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
              const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;
              let keyComment = Node.isNode(key) && key.comment || null;
              if (simpleKeys) {
                if (keyComment) {
                  throw new Error("With simple keys, key nodes cannot have comments");
                }
                if (Node.isCollection(key)) {
                  const msg = "With simple keys, collection cannot be used as a key value";
                  throw new Error(msg);
                }
              }
              let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || Node.isCollection(key) || (Node.isScalar(key) ? key.type === Scalar2.Scalar.BLOCK_FOLDED || key.type === Scalar2.Scalar.BLOCK_LITERAL : typeof key === "object"));
              ctx = Object.assign({}, ctx, {
                allNullValues: false,
                implicitKey: !explicitKey && (simpleKeys || !allNullValues),
                indent: indent + indentStep
              });
              let keyCommentDone = false;
              let chompKeep = false;
              let str = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
              if (!explicitKey && !ctx.inFlow && str.length > 1024) {
                if (simpleKeys)
                  throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
                explicitKey = true;
              }
              if (ctx.inFlow) {
                if (allNullValues || value == null) {
                  if (keyCommentDone && onComment)
                    onComment();
                  return explicitKey ? `? ${str}` : str;
                }
              } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
                if (keyCommentDone)
                  keyComment = null;
                if (chompKeep && !keyComment && onChompKeep)
                  onChompKeep();
                return stringifyComment.addComment(`? ${str}`, ctx.indent, keyComment);
              }
              if (keyCommentDone)
                keyComment = null;
              str = explicitKey ? `? ${stringifyComment.addComment(str, ctx.indent, keyComment)}
${indent}:` : stringifyComment.addComment(`${str}:`, ctx.indent, keyComment);
              let vcb = "";
              let valueComment = null;
              if (Node.isNode(value)) {
                if (value.spaceBefore)
                  vcb = "\n";
                if (value.commentBefore)
                  vcb += `
${stringifyComment.stringifyComment(value.commentBefore, ctx.indent)}`;
                valueComment = value.comment;
              } else if (value && typeof value === "object") {
                value = doc.createNode(value);
              }
              ctx.implicitKey = false;
              if (!explicitKey && !keyComment && Node.isScalar(value))
                ctx.indentAtStart = str.length + 1;
              chompKeep = false;
              if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && Node.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
                ctx.indent = ctx.indent.substr(2);
              }
              let valueCommentDone = false;
              const valueStr = stringify2.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
              let ws = " ";
              if (vcb || keyComment) {
                ws = `${vcb}
${ctx.indent}`;
              } else if (!explicitKey && Node.isCollection(value)) {
                const flow = valueStr[0] === "[" || valueStr[0] === "{";
                if (!flow || valueStr.includes("\n"))
                  ws = `
${ctx.indent}`;
              } else if (valueStr[0] === "\n")
                ws = "";
              if (ctx.inFlow) {
                if (valueCommentDone && onComment)
                  onComment();
                return str + ws + valueStr;
              } else {
                if (valueCommentDone)
                  valueComment = null;
                if (chompKeep && !valueComment && onChompKeep)
                  onChompKeep();
                return stringifyComment.addComment(str + ws + valueStr, ctx.indent, valueComment);
              }
            }
            exports22.stringifyPair = stringifyPair;
          }
        });
        var require_log22 = __commonJS22({
          "node_modules/yaml/dist/log.js"(exports22) {
            "use strict";
            function debug(logLevel, ...messages) {
              if (logLevel === "debug")
                console.log(...messages);
            }
            function warn(logLevel, warning) {
              if (logLevel === "debug" || logLevel === "warn") {
                if (typeof process !== "undefined" && process.emitWarning)
                  process.emitWarning(warning);
                else
                  console.warn(warning);
              }
            }
            exports22.debug = debug;
            exports22.warn = warn;
          }
        });
        var require_addPairToJSMap22 = __commonJS22({
          "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports22) {
            "use strict";
            var log2 = require_log22();
            var stringify2 = require_stringify22();
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var toJS = require_toJS22();
            var MERGE_KEY = "<<";
            function addPairToJSMap(ctx, map, { key, value }) {
              if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
                if (Node.isSeq(value))
                  for (const it of value.items)
                    mergeToJSMap(ctx, map, it);
                else if (Array.isArray(value))
                  for (const it of value)
                    mergeToJSMap(ctx, map, it);
                else
                  mergeToJSMap(ctx, map, value);
              } else {
                const jsKey = toJS.toJS(key, "", ctx);
                if (map instanceof Map) {
                  map.set(jsKey, toJS.toJS(value, jsKey, ctx));
                } else if (map instanceof Set) {
                  map.add(jsKey);
                } else {
                  const stringKey = stringifyKey(key, jsKey, ctx);
                  const jsValue = toJS.toJS(value, stringKey, ctx);
                  if (stringKey in map)
                    Object.defineProperty(map, stringKey, {
                      value: jsValue,
                      writable: true,
                      enumerable: true,
                      configurable: true
                    });
                  else
                    map[stringKey] = jsValue;
                }
              }
              return map;
            }
            var isMergeKey = (key) => key === MERGE_KEY || Node.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar2.Scalar.PLAIN);
            function mergeToJSMap(ctx, map, value) {
              const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : null;
              if (!Node.isMap(source))
                throw new Error("Merge sources must be map aliases");
              const srcMap = source.toJSON(null, ctx, Map);
              for (const [key, value2] of srcMap) {
                if (map instanceof Map) {
                  if (!map.has(key))
                    map.set(key, value2);
                } else if (map instanceof Set) {
                  map.add(key);
                } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
                  Object.defineProperty(map, key, {
                    value: value2,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
              return map;
            }
            function stringifyKey(key, jsKey, ctx) {
              if (jsKey === null)
                return "";
              if (typeof jsKey !== "object")
                return String(jsKey);
              if (Node.isNode(key) && ctx && ctx.doc) {
                const strCtx = stringify2.createStringifyContext(ctx.doc, {});
                strCtx.anchors = new Set();
                for (const node of ctx.anchors.keys())
                  strCtx.anchors.add(node.anchor);
                strCtx.inFlow = true;
                strCtx.inStringifyKey = true;
                const strKey = key.toString(strCtx);
                if (!ctx.mapKeyWarned) {
                  let jsonStr = JSON.stringify(strKey);
                  if (jsonStr.length > 40)
                    jsonStr = jsonStr.substring(0, 36) + '..."';
                  log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
                  ctx.mapKeyWarned = true;
                }
                return strKey;
              }
              return JSON.stringify(jsKey);
            }
            exports22.addPairToJSMap = addPairToJSMap;
          }
        });
        var require_Pair22 = __commonJS22({
          "node_modules/yaml/dist/nodes/Pair.js"(exports22) {
            "use strict";
            var createNode = require_createNode22();
            var stringifyPair = require_stringifyPair22();
            var addPairToJSMap = require_addPairToJSMap22();
            var Node = require_Node22();
            function createPair(key, value, ctx) {
              const k = createNode.createNode(key, void 0, ctx);
              const v = createNode.createNode(value, void 0, ctx);
              return new Pair(k, v);
            }
            var Pair = class {
              constructor(key, value = null) {
                Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
                this.key = key;
                this.value = value;
              }
              toJSON(_, ctx) {
                const pair = ctx && ctx.mapAsMap ? new Map() : {};
                return addPairToJSMap.addPairToJSMap(ctx, pair, this);
              }
              toString(ctx, onComment, onChompKeep) {
                return ctx && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
              }
            };
            exports22.Pair = Pair;
            exports22.createPair = createPair;
          }
        });
        var require_options22 = __commonJS22({
          "node_modules/yaml/dist/options.js"(exports22) {
            "use strict";
            var defaultOptions = {
              intAsBigInt: false,
              logLevel: "warn",
              prettyErrors: true,
              strict: true,
              uniqueKeys: true,
              version: "1.2"
            };
            exports22.defaultOptions = defaultOptions;
          }
        });
        var require_stringifyCollection22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports22) {
            "use strict";
            var Collection = require_Collection22();
            var Node = require_Node22();
            var stringify2 = require_stringify22();
            var stringifyComment = require_stringifyComment22();
            function stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {
              const { indent, indentStep } = ctx;
              const inFlow = flow || ctx.inFlow;
              if (inFlow)
                itemIndent += indentStep;
              ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });
              let singleLineOutput = true;
              let chompKeep = false;
              const nodes = items.reduce((nodes2, item, i) => {
                let comment2 = null;
                if (Node.isNode(item)) {
                  if (!chompKeep && item.spaceBefore)
                    nodes2.push({ comment: true, str: "" });
                  let cb = item.commentBefore;
                  if (cb && chompKeep)
                    cb = cb.replace(/^\n+/, "");
                  if (cb) {
                    if (/^\n+$/.test(cb))
                      cb = cb.substring(1);
                    for (const line of cb.match(/^.*$/gm)) {
                      const str3 = line === " " ? "#" : line ? `#${line}` : "";
                      nodes2.push({ comment: true, str: str3 });
                    }
                  }
                  if (item.comment) {
                    comment2 = item.comment;
                    singleLineOutput = false;
                  }
                } else if (Node.isPair(item)) {
                  const ik = Node.isNode(item.key) ? item.key : null;
                  if (ik) {
                    if (!chompKeep && ik.spaceBefore)
                      nodes2.push({ comment: true, str: "" });
                    let cb = ik.commentBefore;
                    if (cb && chompKeep)
                      cb = cb.replace(/^\n+/, "");
                    if (cb) {
                      if (/^\n+$/.test(cb))
                        cb = cb.substring(1);
                      for (const line of cb.match(/^.*$/gm)) {
                        const str3 = line === " " ? "#" : line ? `#${line}` : "";
                        nodes2.push({ comment: true, str: str3 });
                      }
                    }
                    if (ik.comment)
                      singleLineOutput = false;
                  }
                  if (inFlow) {
                    const iv = Node.isNode(item.value) ? item.value : null;
                    if (iv) {
                      if (iv.comment)
                        comment2 = iv.comment;
                      if (iv.comment || iv.commentBefore)
                        singleLineOutput = false;
                    } else if (item.value == null && ik && ik.comment) {
                      comment2 = ik.comment;
                    }
                  }
                }
                chompKeep = false;
                let str2 = stringify2.stringify(item, ctx, () => comment2 = null, () => chompKeep = true);
                if (inFlow && i < items.length - 1)
                  str2 += ",";
                str2 = stringifyComment.addComment(str2, itemIndent, comment2);
                if (chompKeep && (comment2 || inFlow))
                  chompKeep = false;
                nodes2.push({ comment: false, str: str2 });
                return nodes2;
              }, []);
              let str;
              if (nodes.length === 0) {
                str = flowChars.start + flowChars.end;
              } else if (inFlow) {
                const { start, end } = flowChars;
                const strings = nodes.map((n) => n.str);
                let singleLineLength = 2;
                for (const node of nodes) {
                  if (node.comment || node.str.includes("\n")) {
                    singleLineOutput = false;
                    break;
                  }
                  singleLineLength += node.str.length + 2;
                }
                if (!singleLineOutput || singleLineLength > Collection.Collection.maxFlowStringSingleLineLength) {
                  str = start;
                  for (const s of strings) {
                    str += s ? `
${indentStep}${indent}${s}` : "\n";
                  }
                  str += `
${indent}${end}`;
                } else {
                  str = `${start} ${strings.join(" ")} ${end}`;
                }
              } else {
                const strings = nodes.map(blockItem);
                str = strings.shift() || "";
                for (const s of strings)
                  str += s ? `
${indent}${s}` : "\n";
              }
              if (comment) {
                str += "\n" + stringifyComment.stringifyComment(comment, indent);
                if (onComment)
                  onComment();
              } else if (chompKeep && onChompKeep)
                onChompKeep();
              return str;
            }
            exports22.stringifyCollection = stringifyCollection;
          }
        });
        var require_YAMLMap22 = __commonJS22({
          "node_modules/yaml/dist/nodes/YAMLMap.js"(exports22) {
            "use strict";
            var stringifyCollection = require_stringifyCollection22();
            var addPairToJSMap = require_addPairToJSMap22();
            var Collection = require_Collection22();
            var Node = require_Node22();
            var Pair = require_Pair22();
            var Scalar2 = require_Scalar22();
            function findPair(items, key) {
              const k = Node.isScalar(key) ? key.value : key;
              for (const it of items) {
                if (Node.isPair(it)) {
                  if (it.key === key || it.key === k)
                    return it;
                  if (Node.isScalar(it.key) && it.key.value === k)
                    return it;
                }
              }
              return void 0;
            }
            var YAMLMap = class extends Collection.Collection {
              constructor(schema) {
                super(Node.MAP, schema);
                this.items = [];
              }
              static get tagName() {
                return "tag:yaml.org,2002:map";
              }
              add(pair, overwrite) {
                let _pair;
                if (Node.isPair(pair))
                  _pair = pair;
                else if (!pair || typeof pair !== "object" || !("key" in pair)) {
                  _pair = new Pair.Pair(pair, pair.value);
                } else
                  _pair = new Pair.Pair(pair.key, pair.value);
                const prev = findPair(this.items, _pair.key);
                const sortEntries = this.schema && this.schema.sortMapEntries;
                if (prev) {
                  if (!overwrite)
                    throw new Error(`Key ${_pair.key} already set`);
                  if (Node.isScalar(prev.value) && Scalar2.isScalarValue(_pair.value))
                    prev.value.value = _pair.value;
                  else
                    prev.value = _pair.value;
                } else if (sortEntries) {
                  const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
                  if (i === -1)
                    this.items.push(_pair);
                  else
                    this.items.splice(i, 0, _pair);
                } else {
                  this.items.push(_pair);
                }
              }
              delete(key) {
                const it = findPair(this.items, key);
                if (!it)
                  return false;
                const del = this.items.splice(this.items.indexOf(it), 1);
                return del.length > 0;
              }
              get(key, keepScalar) {
                const it = findPair(this.items, key);
                const node = it && it.value;
                return !keepScalar && Node.isScalar(node) ? node.value : node;
              }
              has(key) {
                return !!findPair(this.items, key);
              }
              set(key, value) {
                this.add(new Pair.Pair(key, value), true);
              }
              toJSON(_, ctx, Type) {
                const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
                if (ctx && ctx.onCreate)
                  ctx.onCreate(map);
                for (const item of this.items)
                  addPairToJSMap.addPairToJSMap(ctx, map, item);
                return map;
              }
              toString(ctx, onComment, onChompKeep) {
                if (!ctx)
                  return JSON.stringify(this);
                for (const item of this.items) {
                  if (!Node.isPair(item))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
                }
                if (!ctx.allNullValues && this.hasAllNullValues(false))
                  ctx = Object.assign({}, ctx, { allNullValues: true });
                return stringifyCollection.stringifyCollection(this, ctx, {
                  blockItem: (n) => n.str,
                  flowChars: { start: "{", end: "}" },
                  itemIndent: ctx.indent || "",
                  onChompKeep,
                  onComment
                });
              }
            };
            exports22.YAMLMap = YAMLMap;
            exports22.findPair = findPair;
          }
        });
        var require_map22 = __commonJS22({
          "node_modules/yaml/dist/schema/common/map.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Pair = require_Pair22();
            var YAMLMap = require_YAMLMap22();
            function createMap(schema, obj, ctx) {
              const { keepUndefined, replacer } = ctx;
              const map2 = new YAMLMap.YAMLMap(schema);
              const add = (key, value) => {
                if (typeof replacer === "function")
                  value = replacer.call(obj, key, value);
                else if (Array.isArray(replacer) && !replacer.includes(key))
                  return;
                if (value !== void 0 || keepUndefined)
                  map2.items.push(Pair.createPair(key, value, ctx));
              };
              if (obj instanceof Map) {
                for (const [key, value] of obj)
                  add(key, value);
              } else if (obj && typeof obj === "object") {
                for (const key of Object.keys(obj))
                  add(key, obj[key]);
              }
              if (typeof schema.sortMapEntries === "function") {
                map2.items.sort(schema.sortMapEntries);
              }
              return map2;
            }
            var map = {
              collection: "map",
              createNode: createMap,
              default: true,
              nodeClass: YAMLMap.YAMLMap,
              tag: "tag:yaml.org,2002:map",
              resolve(map2, onError) {
                if (!Node.isMap(map2))
                  onError("Expected a mapping for this tag");
                return map2;
              }
            };
            exports22.map = map;
          }
        });
        var require_YAMLSeq22 = __commonJS22({
          "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports22) {
            "use strict";
            var stringifyCollection = require_stringifyCollection22();
            var Collection = require_Collection22();
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var toJS = require_toJS22();
            var YAMLSeq = class extends Collection.Collection {
              constructor(schema) {
                super(Node.SEQ, schema);
                this.items = [];
              }
              static get tagName() {
                return "tag:yaml.org,2002:seq";
              }
              add(value) {
                this.items.push(value);
              }
              delete(key) {
                const idx = asItemIndex(key);
                if (typeof idx !== "number")
                  return false;
                const del = this.items.splice(idx, 1);
                return del.length > 0;
              }
              get(key, keepScalar) {
                const idx = asItemIndex(key);
                if (typeof idx !== "number")
                  return void 0;
                const it = this.items[idx];
                return !keepScalar && Node.isScalar(it) ? it.value : it;
              }
              has(key) {
                const idx = asItemIndex(key);
                return typeof idx === "number" && idx < this.items.length;
              }
              set(key, value) {
                const idx = asItemIndex(key);
                if (typeof idx !== "number")
                  throw new Error(`Expected a valid index, not ${key}.`);
                const prev = this.items[idx];
                if (Node.isScalar(prev) && Scalar2.isScalarValue(value))
                  prev.value = value;
                else
                  this.items[idx] = value;
              }
              toJSON(_, ctx) {
                const seq = [];
                if (ctx && ctx.onCreate)
                  ctx.onCreate(seq);
                let i = 0;
                for (const item of this.items)
                  seq.push(toJS.toJS(item, String(i++), ctx));
                return seq;
              }
              toString(ctx, onComment, onChompKeep) {
                if (!ctx)
                  return JSON.stringify(this);
                return stringifyCollection.stringifyCollection(this, ctx, {
                  blockItem: (n) => n.comment ? n.str : `- ${n.str}`,
                  flowChars: { start: "[", end: "]" },
                  itemIndent: (ctx.indent || "") + "  ",
                  onChompKeep,
                  onComment
                });
              }
            };
            function asItemIndex(key) {
              let idx = Node.isScalar(key) ? key.value : key;
              if (idx && typeof idx === "string")
                idx = Number(idx);
              return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
            }
            exports22.YAMLSeq = YAMLSeq;
          }
        });
        var require_seq22 = __commonJS22({
          "node_modules/yaml/dist/schema/common/seq.js"(exports22) {
            "use strict";
            var createNode = require_createNode22();
            var Node = require_Node22();
            var YAMLSeq = require_YAMLSeq22();
            function createSeq(schema, obj, ctx) {
              const { replacer } = ctx;
              const seq2 = new YAMLSeq.YAMLSeq(schema);
              if (obj && Symbol.iterator in Object(obj)) {
                let i = 0;
                for (let it of obj) {
                  if (typeof replacer === "function") {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                  }
                  seq2.items.push(createNode.createNode(it, void 0, ctx));
                }
              }
              return seq2;
            }
            var seq = {
              collection: "seq",
              createNode: createSeq,
              default: true,
              nodeClass: YAMLSeq.YAMLSeq,
              tag: "tag:yaml.org,2002:seq",
              resolve(seq2, onError) {
                if (!Node.isSeq(seq2))
                  onError("Expected a sequence for this tag");
                return seq2;
              }
            };
            exports22.seq = seq;
          }
        });
        var require_string22 = __commonJS22({
          "node_modules/yaml/dist/schema/common/string.js"(exports22) {
            "use strict";
            var stringifyString = require_stringifyString22();
            var string = {
              identify: (value) => typeof value === "string",
              default: true,
              tag: "tag:yaml.org,2002:str",
              resolve: (str) => str,
              stringify(item, ctx, onComment, onChompKeep) {
                ctx = Object.assign({ actualString: true }, ctx);
                return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
              }
            };
            exports22.string = string;
          }
        });
        var require_null22 = __commonJS22({
          "node_modules/yaml/dist/schema/common/null.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var nullTag = {
              identify: (value) => value == null,
              createNode: () => new Scalar2.Scalar(null),
              default: true,
              tag: "tag:yaml.org,2002:null",
              test: /^(?:~|[Nn]ull|NULL)?$/,
              resolve: () => new Scalar2.Scalar(null),
              stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
            };
            exports22.nullTag = nullTag;
          }
        });
        var require_bool32 = __commonJS22({
          "node_modules/yaml/dist/schema/core/bool.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var boolTag = {
              identify: (value) => typeof value === "boolean",
              default: true,
              tag: "tag:yaml.org,2002:bool",
              test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
              resolve: (str) => new Scalar2.Scalar(str[0] === "t" || str[0] === "T"),
              stringify({ source, value }, ctx) {
                if (source && boolTag.test.test(source)) {
                  const sv = source[0] === "t" || source[0] === "T";
                  if (value === sv)
                    return source;
                }
                return value ? ctx.options.trueStr : ctx.options.falseStr;
              }
            };
            exports22.boolTag = boolTag;
          }
        });
        var require_stringifyNumber22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports22) {
            "use strict";
            function stringifyNumber({ format, minFractionDigits, tag, value }) {
              if (typeof value === "bigint")
                return String(value);
              const num = typeof value === "number" ? value : Number(value);
              if (!isFinite(num))
                return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
              let n = JSON.stringify(value);
              if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
                let i = n.indexOf(".");
                if (i < 0) {
                  i = n.length;
                  n += ".";
                }
                let d = minFractionDigits - (n.length - i - 1);
                while (d-- > 0)
                  n += "0";
              }
              return n;
            }
            exports22.stringifyNumber = stringifyNumber;
          }
        });
        var require_float32 = __commonJS22({
          "node_modules/yaml/dist/schema/core/float.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var stringifyNumber = require_stringifyNumber22();
            var floatNaN = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
              resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
              stringify: stringifyNumber.stringifyNumber
            };
            var floatExp = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              format: "EXP",
              test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
              resolve: (str) => parseFloat(str),
              stringify: ({ value }) => Number(value).toExponential()
            };
            var float = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
              resolve(str) {
                const node = new Scalar2.Scalar(parseFloat(str));
                const dot = str.indexOf(".");
                if (dot !== -1 && str[str.length - 1] === "0")
                  node.minFractionDigits = str.length - dot - 1;
                return node;
              },
              stringify: stringifyNumber.stringifyNumber
            };
            exports22.float = float;
            exports22.floatExp = floatExp;
            exports22.floatNaN = floatNaN;
          }
        });
        var require_int32 = __commonJS22({
          "node_modules/yaml/dist/schema/core/int.js"(exports22) {
            "use strict";
            var stringifyNumber = require_stringifyNumber22();
            var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
            var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
            function intStringify(node, radix, prefix) {
              const { value } = node;
              if (intIdentify(value) && value >= 0)
                return prefix + value.toString(radix);
              return stringifyNumber.stringifyNumber(node);
            }
            var intOct = {
              identify: (value) => intIdentify(value) && value >= 0,
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "OCT",
              test: /^0o[0-7]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
              stringify: (node) => intStringify(node, 8, "0o")
            };
            var int = {
              identify: intIdentify,
              default: true,
              tag: "tag:yaml.org,2002:int",
              test: /^[-+]?[0-9]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
              stringify: stringifyNumber.stringifyNumber
            };
            var intHex = {
              identify: (value) => intIdentify(value) && value >= 0,
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "HEX",
              test: /^0x[0-9a-fA-F]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
              stringify: (node) => intStringify(node, 16, "0x")
            };
            exports22.int = int;
            exports22.intHex = intHex;
            exports22.intOct = intOct;
          }
        });
        var require_schema42 = __commonJS22({
          "node_modules/yaml/dist/schema/core/schema.js"(exports22) {
            "use strict";
            var map = require_map22();
            var _null = require_null22();
            var seq = require_seq22();
            var string = require_string22();
            var bool = require_bool32();
            var float = require_float32();
            var int = require_int32();
            var schema = [
              map.map,
              seq.seq,
              string.string,
              _null.nullTag,
              bool.boolTag,
              int.intOct,
              int.int,
              int.intHex,
              float.floatNaN,
              float.floatExp,
              float.float
            ];
            exports22.schema = schema;
          }
        });
        var require_schema222 = __commonJS22({
          "node_modules/yaml/dist/schema/json/schema.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var map = require_map22();
            var seq = require_seq22();
            function intIdentify(value) {
              return typeof value === "bigint" || Number.isInteger(value);
            }
            var stringifyJSON = ({ value }) => JSON.stringify(value);
            var jsonScalars = [
              {
                identify: (value) => typeof value === "string",
                default: true,
                tag: "tag:yaml.org,2002:str",
                resolve: (str) => str,
                stringify: stringifyJSON
              },
              {
                identify: (value) => value == null,
                createNode: () => new Scalar2.Scalar(null),
                default: true,
                tag: "tag:yaml.org,2002:null",
                test: /^null$/,
                resolve: () => null,
                stringify: stringifyJSON
              },
              {
                identify: (value) => typeof value === "boolean",
                default: true,
                tag: "tag:yaml.org,2002:bool",
                test: /^true|false$/,
                resolve: (str) => str === "true",
                stringify: stringifyJSON
              },
              {
                identify: intIdentify,
                default: true,
                tag: "tag:yaml.org,2002:int",
                test: /^-?(?:0|[1-9][0-9]*)$/,
                resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
                stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
              },
              {
                identify: (value) => typeof value === "number",
                default: true,
                tag: "tag:yaml.org,2002:float",
                test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
                resolve: (str) => parseFloat(str),
                stringify: stringifyJSON
              }
            ];
            var jsonError = {
              default: true,
              tag: "",
              test: /^/,
              resolve(str, onError) {
                onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
                return str;
              }
            };
            var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
            exports22.schema = schema;
          }
        });
        var require_binary22 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var stringifyString = require_stringifyString22();
            var binary = {
              identify: (value) => value instanceof Uint8Array,
              default: false,
              tag: "tag:yaml.org,2002:binary",
              resolve(src, onError) {
                if (typeof Buffer === "function") {
                  return Buffer.from(src, "base64");
                } else if (typeof atob === "function") {
                  const str = atob(src.replace(/[\n\r]/g, ""));
                  const buffer = new Uint8Array(str.length);
                  for (let i = 0; i < str.length; ++i)
                    buffer[i] = str.charCodeAt(i);
                  return buffer;
                } else {
                  onError("This environment does not support reading binary tags; either Buffer or atob is required");
                  return src;
                }
              },
              stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
                const buf = value;
                let str;
                if (typeof Buffer === "function") {
                  str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
                } else if (typeof btoa === "function") {
                  let s = "";
                  for (let i = 0; i < buf.length; ++i)
                    s += String.fromCharCode(buf[i]);
                  str = btoa(s);
                } else {
                  throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
                }
                if (!type)
                  type = Scalar2.Scalar.BLOCK_LITERAL;
                if (type !== Scalar2.Scalar.QUOTE_DOUBLE) {
                  const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
                  const n = Math.ceil(str.length / lineWidth);
                  const lines = new Array(n);
                  for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                    lines[i] = str.substr(o, lineWidth);
                  }
                  str = lines.join(type === Scalar2.Scalar.BLOCK_LITERAL ? "\n" : " ");
                }
                return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
              }
            };
            exports22.binary = binary;
          }
        });
        var require_pairs22 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Pair = require_Pair22();
            var Scalar2 = require_Scalar22();
            var YAMLSeq = require_YAMLSeq22();
            function resolvePairs(seq, onError) {
              if (Node.isSeq(seq)) {
                for (let i = 0; i < seq.items.length; ++i) {
                  let item = seq.items[i];
                  if (Node.isPair(item))
                    continue;
                  else if (Node.isMap(item)) {
                    if (item.items.length > 1)
                      onError("Each pair must have its own sequence indicator");
                    const pair = item.items[0] || new Pair.Pair(new Scalar2.Scalar(null));
                    if (item.commentBefore)
                      pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
                    if (item.comment) {
                      const cn = pair.value || pair.key;
                      cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
                    }
                    item = pair;
                  }
                  seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
                }
              } else
                onError("Expected a sequence for this tag");
              return seq;
            }
            function createPairs(schema, iterable, ctx) {
              const { replacer } = ctx;
              const pairs2 = new YAMLSeq.YAMLSeq(schema);
              pairs2.tag = "tag:yaml.org,2002:pairs";
              let i = 0;
              if (iterable && Symbol.iterator in Object(iterable))
                for (let it of iterable) {
                  if (typeof replacer === "function")
                    it = replacer.call(iterable, String(i++), it);
                  let key, value;
                  if (Array.isArray(it)) {
                    if (it.length === 2) {
                      key = it[0];
                      value = it[1];
                    } else
                      throw new TypeError(`Expected [key, value] tuple: ${it}`);
                  } else if (it && it instanceof Object) {
                    const keys = Object.keys(it);
                    if (keys.length === 1) {
                      key = keys[0];
                      value = it[key];
                    } else
                      throw new TypeError(`Expected { key: value } tuple: ${it}`);
                  } else {
                    key = it;
                  }
                  pairs2.items.push(Pair.createPair(key, value, ctx));
                }
              return pairs2;
            }
            var pairs = {
              collection: "seq",
              default: false,
              tag: "tag:yaml.org,2002:pairs",
              resolve: resolvePairs,
              createNode: createPairs
            };
            exports22.createPairs = createPairs;
            exports22.pairs = pairs;
            exports22.resolvePairs = resolvePairs;
          }
        });
        var require_omap22 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports22) {
            "use strict";
            var YAMLSeq = require_YAMLSeq22();
            var toJS = require_toJS22();
            var Node = require_Node22();
            var YAMLMap = require_YAMLMap22();
            var pairs = require_pairs22();
            var YAMLOMap = class extends YAMLSeq.YAMLSeq {
              constructor() {
                super();
                this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
                this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
                this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
                this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
                this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
                this.tag = YAMLOMap.tag;
              }
              toJSON(_, ctx) {
                if (!ctx)
                  return super.toJSON(_);
                const map = new Map();
                if (ctx && ctx.onCreate)
                  ctx.onCreate(map);
                for (const pair of this.items) {
                  let key, value;
                  if (Node.isPair(pair)) {
                    key = toJS.toJS(pair.key, "", ctx);
                    value = toJS.toJS(pair.value, key, ctx);
                  } else {
                    key = toJS.toJS(pair, "", ctx);
                  }
                  if (map.has(key))
                    throw new Error("Ordered maps must not include duplicate keys");
                  map.set(key, value);
                }
                return map;
              }
            };
            YAMLOMap.tag = "tag:yaml.org,2002:omap";
            var omap = {
              collection: "seq",
              identify: (value) => value instanceof Map,
              nodeClass: YAMLOMap,
              default: false,
              tag: "tag:yaml.org,2002:omap",
              resolve(seq, onError) {
                const pairs$1 = pairs.resolvePairs(seq, onError);
                const seenKeys = [];
                for (const { key } of pairs$1.items) {
                  if (Node.isScalar(key)) {
                    if (seenKeys.includes(key.value)) {
                      onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                    } else {
                      seenKeys.push(key.value);
                    }
                  }
                }
                return Object.assign(new YAMLOMap(), pairs$1);
              },
              createNode(schema, iterable, ctx) {
                const pairs$1 = pairs.createPairs(schema, iterable, ctx);
                const omap2 = new YAMLOMap();
                omap2.items = pairs$1.items;
                return omap2;
              }
            };
            exports22.YAMLOMap = YAMLOMap;
            exports22.omap = omap;
          }
        });
        var require_bool222 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            function boolStringify({ value, source }, ctx) {
              const boolObj = value ? trueTag : falseTag;
              if (source && boolObj.test.test(source))
                return source;
              return value ? ctx.options.trueStr : ctx.options.falseStr;
            }
            var trueTag = {
              identify: (value) => value === true,
              default: true,
              tag: "tag:yaml.org,2002:bool",
              test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
              resolve: () => new Scalar2.Scalar(true),
              stringify: boolStringify
            };
            var falseTag = {
              identify: (value) => value === false,
              default: true,
              tag: "tag:yaml.org,2002:bool",
              test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
              resolve: () => new Scalar2.Scalar(false),
              stringify: boolStringify
            };
            exports22.falseTag = falseTag;
            exports22.trueTag = trueTag;
          }
        });
        var require_float222 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var stringifyNumber = require_stringifyNumber22();
            var floatNaN = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
              resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
              stringify: stringifyNumber.stringifyNumber
            };
            var floatExp = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              format: "EXP",
              test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
              resolve: (str) => parseFloat(str.replace(/_/g, "")),
              stringify: ({ value }) => Number(value).toExponential()
            };
            var float = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
              resolve(str) {
                const node = new Scalar2.Scalar(parseFloat(str.replace(/_/g, "")));
                const dot = str.indexOf(".");
                if (dot !== -1) {
                  const f = str.substring(dot + 1).replace(/_/g, "");
                  if (f[f.length - 1] === "0")
                    node.minFractionDigits = f.length;
                }
                return node;
              },
              stringify: stringifyNumber.stringifyNumber
            };
            exports22.float = float;
            exports22.floatExp = floatExp;
            exports22.floatNaN = floatNaN;
          }
        });
        var require_int222 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports22) {
            "use strict";
            var stringifyNumber = require_stringifyNumber22();
            var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
            function intResolve(str, offset, radix, { intAsBigInt }) {
              const sign = str[0];
              if (sign === "-" || sign === "+")
                offset += 1;
              str = str.substring(offset).replace(/_/g, "");
              if (intAsBigInt) {
                switch (radix) {
                  case 2:
                    str = `0b${str}`;
                    break;
                  case 8:
                    str = `0o${str}`;
                    break;
                  case 16:
                    str = `0x${str}`;
                    break;
                }
                const n2 = BigInt(str);
                return sign === "-" ? BigInt(-1) * n2 : n2;
              }
              const n = parseInt(str, radix);
              return sign === "-" ? -1 * n : n;
            }
            function intStringify(node, radix, prefix) {
              const { value } = node;
              if (intIdentify(value)) {
                const str = value.toString(radix);
                return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
              }
              return stringifyNumber.stringifyNumber(node);
            }
            var intBin = {
              identify: intIdentify,
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "BIN",
              test: /^[-+]?0b[0-1_]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
              stringify: (node) => intStringify(node, 2, "0b")
            };
            var intOct = {
              identify: intIdentify,
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "OCT",
              test: /^[-+]?0[0-7_]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
              stringify: (node) => intStringify(node, 8, "0")
            };
            var int = {
              identify: intIdentify,
              default: true,
              tag: "tag:yaml.org,2002:int",
              test: /^[-+]?[0-9][0-9_]*$/,
              resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
              stringify: stringifyNumber.stringifyNumber
            };
            var intHex = {
              identify: intIdentify,
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "HEX",
              test: /^[-+]?0x[0-9a-fA-F_]+$/,
              resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
              stringify: (node) => intStringify(node, 16, "0x")
            };
            exports22.int = int;
            exports22.intBin = intBin;
            exports22.intHex = intHex;
            exports22.intOct = intOct;
          }
        });
        var require_set22 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Pair = require_Pair22();
            var YAMLMap = require_YAMLMap22();
            var YAMLSet = class extends YAMLMap.YAMLMap {
              constructor(schema) {
                super(schema);
                this.tag = YAMLSet.tag;
              }
              add(key) {
                let pair;
                if (Node.isPair(key))
                  pair = key;
                else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
                  pair = new Pair.Pair(key.key, null);
                else
                  pair = new Pair.Pair(key, null);
                const prev = YAMLMap.findPair(this.items, pair.key);
                if (!prev)
                  this.items.push(pair);
              }
              get(key, keepPair) {
                const pair = YAMLMap.findPair(this.items, key);
                return !keepPair && Node.isPair(pair) ? Node.isScalar(pair.key) ? pair.key.value : pair.key : pair;
              }
              set(key, value) {
                if (typeof value !== "boolean")
                  throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
                const prev = YAMLMap.findPair(this.items, key);
                if (prev && !value) {
                  this.items.splice(this.items.indexOf(prev), 1);
                } else if (!prev && value) {
                  this.items.push(new Pair.Pair(key));
                }
              }
              toJSON(_, ctx) {
                return super.toJSON(_, ctx, Set);
              }
              toString(ctx, onComment, onChompKeep) {
                if (!ctx)
                  return JSON.stringify(this);
                if (this.hasAllNullValues(true))
                  return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
                else
                  throw new Error("Set items must all have null values");
              }
            };
            YAMLSet.tag = "tag:yaml.org,2002:set";
            var set = {
              collection: "map",
              identify: (value) => value instanceof Set,
              nodeClass: YAMLSet,
              default: false,
              tag: "tag:yaml.org,2002:set",
              resolve(map, onError) {
                if (Node.isMap(map)) {
                  if (map.hasAllNullValues(true))
                    return Object.assign(new YAMLSet(), map);
                  else
                    onError("Set items must all have null values");
                } else
                  onError("Expected a mapping for this tag");
                return map;
              },
              createNode(schema, iterable, ctx) {
                const { replacer } = ctx;
                const set2 = new YAMLSet(schema);
                if (iterable && Symbol.iterator in Object(iterable))
                  for (let value of iterable) {
                    if (typeof replacer === "function")
                      value = replacer.call(iterable, value, value);
                    set2.items.push(Pair.createPair(value, null, ctx));
                  }
                return set2;
              }
            };
            exports22.YAMLSet = YAMLSet;
            exports22.set = set;
          }
        });
        var require_timestamp22 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports22) {
            "use strict";
            var stringifyNumber = require_stringifyNumber22();
            function parseSexagesimal(str, asBigInt) {
              const sign = str[0];
              const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
              const num = (n) => asBigInt ? BigInt(n) : Number(n);
              const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
              return sign === "-" ? num(-1) * res : res;
            }
            function stringifySexagesimal(node) {
              let { value } = node;
              let num = (n) => n;
              if (typeof value === "bigint")
                num = (n) => BigInt(n);
              else if (isNaN(value) || !isFinite(value))
                return stringifyNumber.stringifyNumber(node);
              let sign = "";
              if (value < 0) {
                sign = "-";
                value *= num(-1);
              }
              const _60 = num(60);
              const parts = [value % _60];
              if (value < 60) {
                parts.unshift(0);
              } else {
                value = (value - parts[0]) / _60;
                parts.unshift(value % _60);
                if (value >= 60) {
                  value = (value - parts[0]) / _60;
                  parts.unshift(value);
                }
              }
              return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
            }
            var intTime = {
              identify: (value) => typeof value === "bigint" || Number.isInteger(value),
              default: true,
              tag: "tag:yaml.org,2002:int",
              format: "TIME",
              test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
              resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
              stringify: stringifySexagesimal
            };
            var floatTime = {
              identify: (value) => typeof value === "number",
              default: true,
              tag: "tag:yaml.org,2002:float",
              format: "TIME",
              test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
              resolve: (str) => parseSexagesimal(str, false),
              stringify: stringifySexagesimal
            };
            var timestamp = {
              identify: (value) => value instanceof Date,
              default: true,
              tag: "tag:yaml.org,2002:timestamp",
              test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
              resolve(str) {
                const match = str.match(timestamp.test);
                if (!match)
                  throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
                const [, year, month, day, hour, minute, second] = match.map(Number);
                const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
                let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
                const tz = match[8];
                if (tz && tz !== "Z") {
                  let d = parseSexagesimal(tz, false);
                  if (Math.abs(d) < 30)
                    d *= 60;
                  date -= 6e4 * d;
                }
                return new Date(date);
              },
              stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
            };
            exports22.floatTime = floatTime;
            exports22.intTime = intTime;
            exports22.timestamp = timestamp;
          }
        });
        var require_schema322 = __commonJS22({
          "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports22) {
            "use strict";
            var map = require_map22();
            var _null = require_null22();
            var seq = require_seq22();
            var string = require_string22();
            var binary = require_binary22();
            var bool = require_bool222();
            var float = require_float222();
            var int = require_int222();
            var omap = require_omap22();
            var pairs = require_pairs22();
            var set = require_set22();
            var timestamp = require_timestamp22();
            var schema = [
              map.map,
              seq.seq,
              string.string,
              _null.nullTag,
              bool.trueTag,
              bool.falseTag,
              int.intBin,
              int.intOct,
              int.int,
              int.intHex,
              float.floatNaN,
              float.floatExp,
              float.float,
              binary.binary,
              omap.omap,
              pairs.pairs,
              set.set,
              timestamp.intTime,
              timestamp.floatTime,
              timestamp.timestamp
            ];
            exports22.schema = schema;
          }
        });
        var require_tags22 = __commonJS22({
          "node_modules/yaml/dist/schema/tags.js"(exports22) {
            "use strict";
            var map = require_map22();
            var _null = require_null22();
            var seq = require_seq22();
            var string = require_string22();
            var bool = require_bool32();
            var float = require_float32();
            var int = require_int32();
            var schema = require_schema42();
            var schema$1 = require_schema222();
            var binary = require_binary22();
            var omap = require_omap22();
            var pairs = require_pairs22();
            var schema$2 = require_schema322();
            var set = require_set22();
            var timestamp = require_timestamp22();
            var schemas = {
              core: schema.schema,
              failsafe: [map.map, seq.seq, string.string],
              json: schema$1.schema,
              yaml11: schema$2.schema,
              "yaml-1.1": schema$2.schema
            };
            var tagsByName = {
              binary: binary.binary,
              bool: bool.boolTag,
              float: float.float,
              floatExp: float.floatExp,
              floatNaN: float.floatNaN,
              floatTime: timestamp.floatTime,
              int: int.int,
              intHex: int.intHex,
              intOct: int.intOct,
              intTime: timestamp.intTime,
              map: map.map,
              null: _null.nullTag,
              omap: omap.omap,
              pairs: pairs.pairs,
              seq: seq.seq,
              set: set.set,
              timestamp: timestamp.timestamp
            };
            var coreKnownTags = {
              "tag:yaml.org,2002:binary": binary.binary,
              "tag:yaml.org,2002:omap": omap.omap,
              "tag:yaml.org,2002:pairs": pairs.pairs,
              "tag:yaml.org,2002:set": set.set,
              "tag:yaml.org,2002:timestamp": timestamp.timestamp
            };
            function getTags(customTags, schemaName) {
              let tags = schemas[schemaName];
              if (!tags) {
                const keys = Object.keys(schemas).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
                throw new Error(`Unknown schema "${schemaName}"; use one of ${keys}`);
              }
              if (Array.isArray(customTags)) {
                for (const tag of customTags)
                  tags = tags.concat(tag);
              } else if (typeof customTags === "function") {
                tags = customTags(tags.slice());
              }
              return tags.map((tag) => {
                if (typeof tag !== "string")
                  return tag;
                const tagObj = tagsByName[tag];
                if (tagObj)
                  return tagObj;
                const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
                throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
              });
            }
            exports22.coreKnownTags = coreKnownTags;
            exports22.getTags = getTags;
          }
        });
        var require_Schema22 = __commonJS22({
          "node_modules/yaml/dist/schema/Schema.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var map = require_map22();
            var seq = require_seq22();
            var string = require_string22();
            var tags = require_tags22();
            var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
            var Schema = class {
              constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {
                this.merge = !!merge;
                this.name = schema || "core";
                this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
                this.tags = tags.getTags(customTags, this.name);
                Object.defineProperty(this, Node.MAP, { value: map.map });
                Object.defineProperty(this, Node.SCALAR, { value: string.string });
                Object.defineProperty(this, Node.SEQ, { value: seq.seq });
                this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
              }
            };
            exports22.Schema = Schema;
          }
        });
        var require_stringifyDocument22 = __commonJS22({
          "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var stringify2 = require_stringify22();
            var stringifyComment = require_stringifyComment22();
            function stringifyDocument(doc, options) {
              const lines = [];
              let hasDirectives = options.directives === true;
              if (options.directives !== false) {
                const dir = doc.directives.toString(doc);
                if (dir) {
                  lines.push(dir);
                  hasDirectives = true;
                } else if (doc.directives.marker)
                  hasDirectives = true;
              }
              if (hasDirectives)
                lines.push("---");
              if (doc.commentBefore) {
                if (lines.length !== 1)
                  lines.unshift("");
                lines.unshift(stringifyComment.stringifyComment(doc.commentBefore, ""));
              }
              const ctx = stringify2.createStringifyContext(doc, options);
              let chompKeep = false;
              let contentComment = null;
              if (doc.contents) {
                if (Node.isNode(doc.contents)) {
                  if (doc.contents.spaceBefore && hasDirectives)
                    lines.push("");
                  if (doc.contents.commentBefore)
                    lines.push(stringifyComment.stringifyComment(doc.contents.commentBefore, ""));
                  ctx.forceBlockIndent = !!doc.comment;
                  contentComment = doc.contents.comment;
                }
                const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
                let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
                if (contentComment)
                  body = stringifyComment.addComment(body, "", contentComment);
                if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
                  lines[lines.length - 1] = `--- ${body}`;
                } else
                  lines.push(body);
              } else {
                lines.push(stringify2.stringify(doc.contents, ctx));
              }
              let dc = doc.comment;
              if (dc && chompKeep)
                dc = dc.replace(/^\n+/, "");
              if (dc) {
                if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
                  lines.push("");
                lines.push(stringifyComment.stringifyComment(dc, ""));
              }
              return lines.join("\n") + "\n";
            }
            exports22.stringifyDocument = stringifyDocument;
          }
        });
        var require_applyReviver22 = __commonJS22({
          "node_modules/yaml/dist/doc/applyReviver.js"(exports22) {
            "use strict";
            function applyReviver(reviver, obj, key, val) {
              if (val && typeof val === "object") {
                if (Array.isArray(val)) {
                  for (let i = 0, len = val.length; i < len; ++i) {
                    const v0 = val[i];
                    const v1 = applyReviver(reviver, val, String(i), v0);
                    if (v1 === void 0)
                      delete val[i];
                    else if (v1 !== v0)
                      val[i] = v1;
                  }
                } else if (val instanceof Map) {
                  for (const k of Array.from(val.keys())) {
                    const v0 = val.get(k);
                    const v1 = applyReviver(reviver, val, k, v0);
                    if (v1 === void 0)
                      val.delete(k);
                    else if (v1 !== v0)
                      val.set(k, v1);
                  }
                } else if (val instanceof Set) {
                  for (const v0 of Array.from(val)) {
                    const v1 = applyReviver(reviver, val, v0, v0);
                    if (v1 === void 0)
                      val.delete(v0);
                    else if (v1 !== v0) {
                      val.delete(v0);
                      val.add(v1);
                    }
                  }
                } else {
                  for (const [k, v0] of Object.entries(val)) {
                    const v1 = applyReviver(reviver, val, k, v0);
                    if (v1 === void 0)
                      delete val[k];
                    else if (v1 !== v0)
                      val[k] = v1;
                  }
                }
              }
              return reviver.call(obj, key, val);
            }
            exports22.applyReviver = applyReviver;
          }
        });
        var require_Document22 = __commonJS22({
          "node_modules/yaml/dist/doc/Document.js"(exports22) {
            "use strict";
            var Alias = require_Alias22();
            var Collection = require_Collection22();
            var Node = require_Node22();
            var Pair = require_Pair22();
            var toJS = require_toJS22();
            var options = require_options22();
            var Schema = require_Schema22();
            var stringify2 = require_stringify22();
            var stringifyDocument = require_stringifyDocument22();
            var anchors = require_anchors22();
            var applyReviver = require_applyReviver22();
            var createNode = require_createNode22();
            var directives = require_directives22();
            var Document4 = class {
              constructor(value, replacer, options$1) {
                this.commentBefore = null;
                this.comment = null;
                this.errors = [];
                this.warnings = [];
                Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
                let _replacer = null;
                if (typeof replacer === "function" || Array.isArray(replacer)) {
                  _replacer = replacer;
                } else if (options$1 === void 0 && replacer) {
                  options$1 = replacer;
                  replacer = void 0;
                }
                const opt = Object.assign({}, options.defaultOptions, options$1);
                this.options = opt;
                let { version } = opt;
                if (options$1 === null || options$1 === void 0 ? void 0 : options$1.directives) {
                  this.directives = options$1.directives.atDocument();
                  if (this.directives.yaml.explicit)
                    version = this.directives.yaml.version;
                } else
                  this.directives = new directives.Directives({ version });
                this.setSchema(version, options$1);
                if (value === void 0)
                  this.contents = null;
                else {
                  this.contents = this.createNode(value, _replacer, options$1);
                }
              }
              add(value) {
                if (assertCollection(this.contents))
                  this.contents.add(value);
              }
              addIn(path7, value) {
                if (assertCollection(this.contents))
                  this.contents.addIn(path7, value);
              }
              createAlias(node, name) {
                if (!node.anchor) {
                  const prev = anchors.anchorNames(this);
                  node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
                }
                return new Alias.Alias(node.anchor);
              }
              createNode(value, replacer, options2) {
                let _replacer = void 0;
                if (typeof replacer === "function") {
                  value = replacer.call({ "": value }, "", value);
                  _replacer = replacer;
                } else if (Array.isArray(replacer)) {
                  const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
                  const asStr = replacer.filter(keyToStr).map(String);
                  if (asStr.length > 0)
                    replacer = replacer.concat(asStr);
                  _replacer = replacer;
                } else if (options2 === void 0 && replacer) {
                  options2 = replacer;
                  replacer = void 0;
                }
                const { anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 || {};
                const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
                const ctx = {
                  keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
                  onAnchor,
                  onTagObj,
                  replacer: _replacer,
                  schema: this.schema,
                  sourceObjects
                };
                const node = createNode.createNode(value, tag, ctx);
                if (flow && Node.isCollection(node))
                  node.flow = true;
                setAnchors();
                return node;
              }
              createPair(key, value, options2 = {}) {
                const k = this.createNode(key, null, options2);
                const v = this.createNode(value, null, options2);
                return new Pair.Pair(k, v);
              }
              delete(key) {
                return assertCollection(this.contents) ? this.contents.delete(key) : false;
              }
              deleteIn(path7) {
                if (Collection.isEmptyPath(path7)) {
                  if (this.contents == null)
                    return false;
                  this.contents = null;
                  return true;
                }
                return assertCollection(this.contents) ? this.contents.deleteIn(path7) : false;
              }
              get(key, keepScalar) {
                return Node.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
              }
              getIn(path7, keepScalar) {
                if (Collection.isEmptyPath(path7))
                  return !keepScalar && Node.isScalar(this.contents) ? this.contents.value : this.contents;
                return Node.isCollection(this.contents) ? this.contents.getIn(path7, keepScalar) : void 0;
              }
              has(key) {
                return Node.isCollection(this.contents) ? this.contents.has(key) : false;
              }
              hasIn(path7) {
                if (Collection.isEmptyPath(path7))
                  return this.contents !== void 0;
                return Node.isCollection(this.contents) ? this.contents.hasIn(path7) : false;
              }
              set(key, value) {
                if (this.contents == null) {
                  this.contents = Collection.collectionFromPath(this.schema, [key], value);
                } else if (assertCollection(this.contents)) {
                  this.contents.set(key, value);
                }
              }
              setIn(path7, value) {
                if (Collection.isEmptyPath(path7))
                  this.contents = value;
                else if (this.contents == null) {
                  this.contents = Collection.collectionFromPath(this.schema, Array.from(path7), value);
                } else if (assertCollection(this.contents)) {
                  this.contents.setIn(path7, value);
                }
              }
              setSchema(version, options2) {
                let _options;
                switch (String(version)) {
                  case "1.1":
                    this.directives.yaml.version = "1.1";
                    _options = Object.assign({ merge: true, resolveKnownTags: false, schema: "yaml-1.1" }, options2);
                    break;
                  case "1.2":
                    this.directives.yaml.version = "1.2";
                    _options = Object.assign({ merge: false, resolveKnownTags: true, schema: "core" }, options2);
                    break;
                  default: {
                    const sv = JSON.stringify(version);
                    throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);
                  }
                }
                this.schema = new Schema.Schema(_options);
              }
              toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
                const ctx = {
                  anchors: new Map(),
                  doc: this,
                  keep: !json,
                  mapAsMap: mapAsMap === true,
                  mapKeyWarned: false,
                  maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
                  stringify: stringify2.stringify
                };
                const res = toJS.toJS(this.contents, jsonArg || "", ctx);
                if (typeof onAnchor === "function")
                  for (const { count, res: res2 } of ctx.anchors.values())
                    onAnchor(res2, count);
                return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
              }
              toJSON(jsonArg, onAnchor) {
                return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
              }
              toString(options2 = {}) {
                if (this.errors.length > 0)
                  throw new Error("Document with errors cannot be stringified");
                if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
                  const s = JSON.stringify(options2.indent);
                  throw new Error(`"indent" option must be a positive integer, not ${s}`);
                }
                return stringifyDocument.stringifyDocument(this, options2);
              }
            };
            function assertCollection(contents) {
              if (Node.isCollection(contents))
                return true;
              throw new Error("Expected a YAML collection as document contents");
            }
            exports22.Document = Document4;
          }
        });
        var require_errors22 = __commonJS22({
          "node_modules/yaml/dist/errors.js"(exports22) {
            "use strict";
            var YAMLError = class extends Error {
              constructor(name, pos, code, message) {
                super();
                this.name = name;
                this.code = code;
                this.message = message;
                this.pos = pos;
              }
            };
            var YAMLParseError = class extends YAMLError {
              constructor(pos, code, message) {
                super("YAMLParseError", pos, code, message);
              }
            };
            var YAMLWarning = class extends YAMLError {
              constructor(pos, code, message) {
                super("YAMLWarning", pos, code, message);
              }
            };
            var prettifyError = (src, lc) => (error) => {
              if (error.pos[0] === -1)
                return;
              error.linePos = error.pos.map((pos) => lc.linePos(pos));
              const { line, col } = error.linePos[0];
              error.message += ` at line ${line}, column ${col}`;
              let ci = col - 1;
              let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
              if (ci >= 60 && lineStr.length > 80) {
                const trimStart = Math.min(ci - 39, lineStr.length - 79);
                lineStr = "\u2026" + lineStr.substring(trimStart);
                ci -= trimStart - 1;
              }
              if (lineStr.length > 80)
                lineStr = lineStr.substring(0, 79) + "\u2026";
              if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
                let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
                if (prev.length > 80)
                  prev = prev.substring(0, 79) + "\u2026\n";
                lineStr = prev + lineStr;
              }
              if (/[^ ]/.test(lineStr)) {
                let count = 1;
                const end = error.linePos[1];
                if (end && end.line === line && end.col > col) {
                  count = Math.min(end.col - col, 80 - ci);
                }
                const pointer = " ".repeat(ci) + "^".repeat(count);
                error.message += `:

${lineStr}
${pointer}
`;
              }
            };
            exports22.YAMLError = YAMLError;
            exports22.YAMLParseError = YAMLParseError;
            exports22.YAMLWarning = YAMLWarning;
            exports22.prettifyError = prettifyError;
          }
        });
        var require_resolve_props22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-props.js"(exports22) {
            "use strict";
            function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
              let spaceBefore = false;
              let atNewline = startOnNewline;
              let hasSpace = startOnNewline;
              let comment = "";
              let commentSep = "";
              let hasNewline = false;
              let reqSpace = false;
              let anchor = null;
              let tag = null;
              let comma = null;
              let found = null;
              let start = null;
              for (const token of tokens) {
                if (reqSpace) {
                  if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
                    onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
                  reqSpace = false;
                }
                switch (token.type) {
                  case "space":
                    if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
                      onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
                    hasSpace = true;
                    break;
                  case "comment": {
                    if (!hasSpace)
                      onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    const cb = token.source.substring(1) || " ";
                    if (!comment)
                      comment = cb;
                    else
                      comment += commentSep + cb;
                    commentSep = "";
                    atNewline = false;
                    break;
                  }
                  case "newline":
                    if (atNewline) {
                      if (comment)
                        comment += token.source;
                      else
                        spaceBefore = true;
                    } else
                      commentSep += token.source;
                    atNewline = true;
                    hasNewline = true;
                    hasSpace = true;
                    break;
                  case "anchor":
                    if (anchor)
                      onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
                    anchor = token;
                    if (start === null)
                      start = token.offset;
                    atNewline = false;
                    hasSpace = false;
                    reqSpace = true;
                    break;
                  case "tag": {
                    if (tag)
                      onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
                    tag = token;
                    if (start === null)
                      start = token.offset;
                    atNewline = false;
                    hasSpace = false;
                    reqSpace = true;
                    break;
                  }
                  case indicator:
                    if (anchor || tag)
                      onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
                    found = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                  case "comma":
                    if (flow) {
                      if (comma)
                        onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
                      comma = token;
                      atNewline = false;
                      hasSpace = false;
                      break;
                    }
                  default:
                    onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
                    atNewline = false;
                    hasSpace = false;
                }
              }
              const last = tokens[tokens.length - 1];
              const end = last ? last.offset + last.source.length : offset;
              if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
                onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
              return {
                comma,
                found,
                spaceBefore,
                comment,
                hasNewline,
                anchor,
                tag,
                end,
                start: start !== null && start !== void 0 ? start : end
              };
            }
            exports22.resolveProps = resolveProps;
          }
        });
        var require_util_contains_newline22 = __commonJS22({
          "node_modules/yaml/dist/compose/util-contains-newline.js"(exports22) {
            "use strict";
            function containsNewline(key) {
              if (!key)
                return null;
              switch (key.type) {
                case "alias":
                case "scalar":
                case "double-quoted-scalar":
                case "single-quoted-scalar":
                  if (key.source.includes("\n"))
                    return true;
                  if (key.end) {
                    for (const st of key.end)
                      if (st.type === "newline")
                        return true;
                  }
                  return false;
                case "flow-collection":
                  for (const it of key.items) {
                    for (const st of it.start)
                      if (st.type === "newline")
                        return true;
                    if (it.sep) {
                      for (const st of it.sep)
                        if (st.type === "newline")
                          return true;
                    }
                    if (containsNewline(it.key) || containsNewline(it.value))
                      return true;
                  }
                  return false;
                default:
                  return true;
              }
            }
            exports22.containsNewline = containsNewline;
          }
        });
        var require_util_map_includes22 = __commonJS22({
          "node_modules/yaml/dist/compose/util-map-includes.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            function mapIncludes(ctx, items, search) {
              const { uniqueKeys } = ctx.options;
              if (uniqueKeys === false)
                return false;
              const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || Node.isScalar(a) && Node.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
              return items.some((pair) => isEqual(pair.key, search));
            }
            exports22.mapIncludes = mapIncludes;
          }
        });
        var require_resolve_block_map22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-block-map.js"(exports22) {
            "use strict";
            var Pair = require_Pair22();
            var YAMLMap = require_YAMLMap22();
            var resolveProps = require_resolve_props22();
            var utilContainsNewline = require_util_contains_newline22();
            var utilMapIncludes = require_util_map_includes22();
            var startColMsg = "All mapping items must start at the same column";
            function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
              var _a;
              const map = new YAMLMap.YAMLMap(ctx.schema);
              let offset = bm.offset;
              for (const { start, key, sep, value } of bm.items) {
                const keyProps = resolveProps.resolveProps(start, {
                  indicator: "explicit-key-ind",
                  next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
                  offset,
                  onError,
                  startOnNewline: true
                });
                const implicitKey = !keyProps.found;
                if (implicitKey) {
                  if (key) {
                    if (key.type === "block-seq")
                      onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
                    else if ("indent" in key && key.indent !== bm.indent)
                      onError(offset, "BAD_INDENT", startColMsg);
                  }
                  if (!keyProps.anchor && !keyProps.tag && !sep) {
                    if (keyProps.comment) {
                      if (map.comment)
                        map.comment += "\n" + keyProps.comment;
                      else
                        map.comment = keyProps.comment;
                    }
                    continue;
                  }
                } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
                  onError(offset, "BAD_INDENT", startColMsg);
                if (implicitKey && utilContainsNewline.containsNewline(key))
                  onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
                const keyStart = keyProps.end;
                const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                  onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
                const valueProps = resolveProps.resolveProps(sep || [], {
                  indicator: "map-value-ind",
                  next: value,
                  offset: keyNode.range[2],
                  onError,
                  startOnNewline: !key || key.type === "block-scalar"
                });
                offset = valueProps.end;
                if (valueProps.found) {
                  if (implicitKey) {
                    if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
                      onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
                    if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
                      onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
                  }
                  const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
                  offset = valueNode.range[2];
                  map.items.push(new Pair.Pair(keyNode, valueNode));
                } else {
                  if (implicitKey)
                    onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
                  if (valueProps.comment) {
                    if (keyNode.comment)
                      keyNode.comment += "\n" + valueProps.comment;
                    else
                      keyNode.comment = valueProps.comment;
                  }
                  map.items.push(new Pair.Pair(keyNode));
                }
              }
              map.range = [bm.offset, offset, offset];
              return map;
            }
            exports22.resolveBlockMap = resolveBlockMap;
          }
        });
        var require_resolve_block_seq22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports22) {
            "use strict";
            var YAMLSeq = require_YAMLSeq22();
            var resolveProps = require_resolve_props22();
            function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
              const seq = new YAMLSeq.YAMLSeq(ctx.schema);
              let offset = bs.offset;
              for (const { start, value } of bs.items) {
                const props = resolveProps.resolveProps(start, {
                  indicator: "seq-item-ind",
                  next: value,
                  offset,
                  onError,
                  startOnNewline: true
                });
                offset = props.end;
                if (!props.found) {
                  if (props.anchor || props.tag || value) {
                    if (value && value.type === "block-seq")
                      onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
                    else
                      onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
                  } else {
                    if (props.comment)
                      seq.comment = props.comment;
                    continue;
                  }
                }
                const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, offset, start, null, props, onError);
                offset = node.range[2];
                seq.items.push(node);
              }
              seq.range = [bs.offset, offset, offset];
              return seq;
            }
            exports22.resolveBlockSeq = resolveBlockSeq;
          }
        });
        var require_resolve_end22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-end.js"(exports22) {
            "use strict";
            function resolveEnd(end, offset, reqSpace, onError) {
              let comment = "";
              if (end) {
                let hasSpace = false;
                let sep = "";
                for (const token of end) {
                  const { source, type } = token;
                  switch (type) {
                    case "space":
                      hasSpace = true;
                      break;
                    case "comment": {
                      if (reqSpace && !hasSpace)
                        onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                      const cb = source.substring(1) || " ";
                      if (!comment)
                        comment = cb;
                      else
                        comment += sep + cb;
                      sep = "";
                      break;
                    }
                    case "newline":
                      if (comment)
                        sep += source;
                      hasSpace = true;
                      break;
                    default:
                      onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
                  }
                  offset += source.length;
                }
              }
              return { comment, offset };
            }
            exports22.resolveEnd = resolveEnd;
          }
        });
        var require_resolve_flow_collection22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Pair = require_Pair22();
            var YAMLMap = require_YAMLMap22();
            var YAMLSeq = require_YAMLSeq22();
            var resolveEnd = require_resolve_end22();
            var resolveProps = require_resolve_props22();
            var utilContainsNewline = require_util_contains_newline22();
            var utilMapIncludes = require_util_map_includes22();
            var blockMsg = "Block collections are not allowed within flow collections";
            var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
            function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
              const isMap2 = fc.start.source === "{";
              const fcName = isMap2 ? "flow map" : "flow sequence";
              const coll = isMap2 ? new YAMLMap.YAMLMap(ctx.schema) : new YAMLSeq.YAMLSeq(ctx.schema);
              coll.flow = true;
              let offset = fc.offset;
              for (let i = 0; i < fc.items.length; ++i) {
                const { start, key, sep, value } = fc.items[i];
                const props = resolveProps.resolveProps(start, {
                  flow: fcName,
                  indicator: "explicit-key-ind",
                  next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
                  offset,
                  onError,
                  startOnNewline: false
                });
                if (!props.found) {
                  if (!props.anchor && !props.tag && !sep && !value) {
                    if (i === 0 && props.comma)
                      onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
                    else if (i < fc.items.length - 1)
                      onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
                    if (props.comment) {
                      if (coll.comment)
                        coll.comment += "\n" + props.comment;
                      else
                        coll.comment = props.comment;
                    }
                    continue;
                  }
                  if (!isMap2 && ctx.options.strict && utilContainsNewline.containsNewline(key))
                    onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                }
                if (i === 0) {
                  if (props.comma)
                    onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
                } else {
                  if (!props.comma)
                    onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
                  if (props.comment) {
                    let prevItemComment = "";
                    loop:
                      for (const st of start) {
                        switch (st.type) {
                          case "comma":
                          case "space":
                            break;
                          case "comment":
                            prevItemComment = st.source.substring(1);
                            break loop;
                          default:
                            break loop;
                        }
                      }
                    if (prevItemComment) {
                      let prev = coll.items[coll.items.length - 1];
                      if (Node.isPair(prev))
                        prev = prev.value || prev.key;
                      if (prev.comment)
                        prev.comment += "\n" + prevItemComment;
                      else
                        prev.comment = prevItemComment;
                      props.comment = props.comment.substring(prevItemComment.length + 1);
                    }
                  }
                }
                if (!isMap2 && !sep && !props.found) {
                  const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
                  coll.items.push(valueNode);
                  offset = valueNode.range[2];
                  if (isBlock(value))
                    onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
                } else {
                  const keyStart = props.end;
                  const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
                  if (isBlock(key))
                    onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
                  const valueProps = resolveProps.resolveProps(sep || [], {
                    flow: fcName,
                    indicator: "map-value-ind",
                    next: value,
                    offset: keyNode.range[2],
                    onError,
                    startOnNewline: false
                  });
                  if (valueProps.found) {
                    if (!isMap2 && !props.found && ctx.options.strict) {
                      if (sep)
                        for (const st of sep) {
                          if (st === valueProps.found)
                            break;
                          if (st.type === "newline") {
                            onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                            break;
                          }
                        }
                      if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                    }
                  } else if (value) {
                    if ("source" in value && value.source && value.source[0] === ":")
                      onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
                    else
                      onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
                  }
                  const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
                  if (valueNode) {
                    if (isBlock(value))
                      onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
                  } else if (valueProps.comment) {
                    if (keyNode.comment)
                      keyNode.comment += "\n" + valueProps.comment;
                    else
                      keyNode.comment = valueProps.comment;
                  }
                  const pair = new Pair.Pair(keyNode, valueNode);
                  if (isMap2) {
                    const map = coll;
                    if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
                    map.items.push(pair);
                  } else {
                    const map = new YAMLMap.YAMLMap(ctx.schema);
                    map.flow = true;
                    map.items.push(pair);
                    coll.items.push(map);
                  }
                  offset = valueNode ? valueNode.range[2] : valueProps.end;
                }
              }
              const expectedEnd = isMap2 ? "}" : "]";
              const [ce, ...ee] = fc.end;
              let cePos = offset;
              if (ce && ce.source === expectedEnd)
                cePos = ce.offset + ce.source.length;
              else {
                onError(offset + 1, "MISSING_CHAR", `Expected ${fcName} to end with ${expectedEnd}`);
                if (ce && ce.source.length !== 1)
                  ee.unshift(ce);
              }
              if (ee.length > 0) {
                const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
                if (end.comment) {
                  if (coll.comment)
                    coll.comment += "\n" + end.comment;
                  else
                    coll.comment = end.comment;
                }
                coll.range = [fc.offset, cePos, end.offset];
              } else {
                coll.range = [fc.offset, cePos, cePos];
              }
              return coll;
            }
            exports22.resolveFlowCollection = resolveFlowCollection;
          }
        });
        var require_compose_collection22 = __commonJS22({
          "node_modules/yaml/dist/compose/compose-collection.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var resolveBlockMap = require_resolve_block_map22();
            var resolveBlockSeq = require_resolve_block_seq22();
            var resolveFlowCollection = require_resolve_flow_collection22();
            function composeCollection(CN, ctx, token, tagToken, onError) {
              let coll;
              switch (token.type) {
                case "block-map": {
                  coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
                  break;
                }
                case "block-seq": {
                  coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
                  break;
                }
                case "flow-collection": {
                  coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
                  break;
                }
              }
              if (!tagToken)
                return coll;
              const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
              if (!tagName)
                return coll;
              const Coll = coll.constructor;
              if (tagName === "!" || tagName === Coll.tagName) {
                coll.tag = Coll.tagName;
                return coll;
              }
              const expType = Node.isMap(coll) ? "map" : "seq";
              let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
              if (!tag) {
                const kt = ctx.schema.knownTags[tagName];
                if (kt && kt.collection === expType) {
                  ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
                  tag = kt;
                } else {
                  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
                  coll.tag = tagName;
                  return coll;
                }
              }
              const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
              const node = Node.isNode(res) ? res : new Scalar2.Scalar(res);
              node.range = coll.range;
              node.tag = tagName;
              if (tag === null || tag === void 0 ? void 0 : tag.format)
                node.format = tag.format;
              return node;
            }
            exports22.composeCollection = composeCollection;
          }
        });
        var require_resolve_block_scalar22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            function resolveBlockScalar(scalar, strict, onError) {
              const start = scalar.offset;
              const header = parseBlockScalarHeader(scalar, strict, onError);
              if (!header)
                return { value: "", type: null, comment: "", range: [start, start, start] };
              const type = header.mode === ">" ? Scalar2.Scalar.BLOCK_FOLDED : Scalar2.Scalar.BLOCK_LITERAL;
              const lines = scalar.source ? splitLines(scalar.source) : [];
              let chompStart = lines.length;
              for (let i = lines.length - 1; i >= 0; --i) {
                const content = lines[i][1];
                if (content === "" || content === "\r")
                  chompStart = i;
                else
                  break;
              }
              if (!scalar.source || chompStart === 0) {
                const value2 = header.chomp === "+" ? lines.map((line) => line[0]).join("\n") : "";
                let end2 = start + header.length;
                if (scalar.source)
                  end2 += scalar.source.length;
                return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
              }
              let trimIndent = scalar.indent + header.indent;
              let offset = scalar.offset + header.length;
              let contentStart = 0;
              for (let i = 0; i < chompStart; ++i) {
                const [indent, content] = lines[i];
                if (content === "" || content === "\r") {
                  if (header.indent === 0 && indent.length > trimIndent)
                    trimIndent = indent.length;
                } else {
                  if (indent.length < trimIndent) {
                    const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                    onError(offset + indent.length, "MISSING_CHAR", message);
                  }
                  if (header.indent === 0)
                    trimIndent = indent.length;
                  contentStart = i;
                  break;
                }
                offset += indent.length + content.length + 1;
              }
              let value = "";
              let sep = "";
              let prevMoreIndented = false;
              for (let i = 0; i < contentStart; ++i)
                value += lines[i][0].slice(trimIndent) + "\n";
              for (let i = contentStart; i < chompStart; ++i) {
                let [indent, content] = lines[i];
                offset += indent.length + content.length + 1;
                const crlf = content[content.length - 1] === "\r";
                if (crlf)
                  content = content.slice(0, -1);
                if (content && indent.length < trimIndent) {
                  const src = header.indent ? "explicit indentation indicator" : "first line";
                  const message = `Block scalar lines must not be less indented than their ${src}`;
                  onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
                  indent = "";
                }
                if (type === Scalar2.Scalar.BLOCK_LITERAL) {
                  value += sep + indent.slice(trimIndent) + content;
                  sep = "\n";
                } else if (indent.length > trimIndent || content[0] === "	") {
                  if (sep === " ")
                    sep = "\n";
                  else if (!prevMoreIndented && sep === "\n")
                    sep = "\n\n";
                  value += sep + indent.slice(trimIndent) + content;
                  sep = "\n";
                  prevMoreIndented = true;
                } else if (content === "") {
                  if (sep === "\n")
                    value += "\n";
                  else
                    sep = "\n";
                } else {
                  value += sep + content;
                  sep = " ";
                  prevMoreIndented = false;
                }
              }
              switch (header.chomp) {
                case "-":
                  break;
                case "+":
                  for (let i = chompStart; i < lines.length; ++i)
                    value += "\n" + lines[i][0].slice(trimIndent);
                  if (value[value.length - 1] !== "\n")
                    value += "\n";
                  break;
                default:
                  value += "\n";
              }
              const end = start + header.length + scalar.source.length;
              return { value, type, comment: header.comment, range: [start, end, end] };
            }
            function parseBlockScalarHeader({ offset, props }, strict, onError) {
              if (props[0].type !== "block-scalar-header") {
                onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
                return null;
              }
              const { source } = props[0];
              const mode = source[0];
              let indent = 0;
              let chomp = "";
              let error = -1;
              for (let i = 1; i < source.length; ++i) {
                const ch = source[i];
                if (!chomp && (ch === "-" || ch === "+"))
                  chomp = ch;
                else {
                  const n = Number(ch);
                  if (!indent && n)
                    indent = n;
                  else if (error === -1)
                    error = offset + i;
                }
              }
              if (error !== -1)
                onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
              let hasSpace = false;
              let comment = "";
              let length = source.length;
              for (let i = 1; i < props.length; ++i) {
                const token = props[i];
                switch (token.type) {
                  case "space":
                    hasSpace = true;
                  case "newline":
                    length += token.source.length;
                    break;
                  case "comment":
                    if (strict && !hasSpace) {
                      const message = "Comments must be separated from other tokens by white space characters";
                      onError(token, "MISSING_CHAR", message);
                    }
                    length += token.source.length;
                    comment = token.source.substring(1);
                    break;
                  case "error":
                    onError(token, "UNEXPECTED_TOKEN", token.message);
                    length += token.source.length;
                    break;
                  default: {
                    const message = `Unexpected token in block scalar header: ${token.type}`;
                    onError(token, "UNEXPECTED_TOKEN", message);
                    const ts = token.source;
                    if (ts && typeof ts === "string")
                      length += ts.length;
                  }
                }
              }
              return { mode, indent, chomp, comment, length };
            }
            function splitLines(source) {
              const split = source.split(/\n( *)/);
              const first = split[0];
              const m = first.match(/^( *)/);
              const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
              const lines = [line0];
              for (let i = 1; i < split.length; i += 2)
                lines.push([split[i], split[i + 1]]);
              return lines;
            }
            exports22.resolveBlockScalar = resolveBlockScalar;
          }
        });
        var require_resolve_flow_scalar22 = __commonJS22({
          "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports22) {
            "use strict";
            var Scalar2 = require_Scalar22();
            var resolveEnd = require_resolve_end22();
            function resolveFlowScalar(scalar, strict, onError) {
              const { offset, type, source, end } = scalar;
              let _type;
              let value;
              const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
              switch (type) {
                case "scalar":
                  _type = Scalar2.Scalar.PLAIN;
                  value = plainValue(source, _onError);
                  break;
                case "single-quoted-scalar":
                  _type = Scalar2.Scalar.QUOTE_SINGLE;
                  value = singleQuotedValue(source, _onError);
                  break;
                case "double-quoted-scalar":
                  _type = Scalar2.Scalar.QUOTE_DOUBLE;
                  value = doubleQuotedValue(source, _onError);
                  break;
                default:
                  onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
                  return {
                    value: "",
                    type: null,
                    comment: "",
                    range: [offset, offset + source.length, offset + source.length]
                  };
              }
              const valueEnd = offset + source.length;
              const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
              return {
                value,
                type: _type,
                comment: re.comment,
                range: [offset, valueEnd, re.offset]
              };
            }
            function plainValue(source, onError) {
              let message = "";
              switch (source[0]) {
                case "	":
                  message = "Plain value cannot start with a tab character";
                  break;
                case "|":
                case ">": {
                  message = `Plain value cannot start with block scalar indicator ${source[0]}`;
                  break;
                }
                case "@":
                case "`": {
                  message = `Plain value cannot start with reserved character ${source[0]}`;
                  break;
                }
              }
              if (message)
                onError(0, "BAD_SCALAR_START", message);
              return foldLines(source);
            }
            function singleQuotedValue(source, onError) {
              if (source[source.length - 1] !== "'" || source.length === 1)
                onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
              return foldLines(source.slice(1, -1)).replace(/''/g, "'");
            }
            function foldLines(source) {
              let first, line;
              try {
                first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
                line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
              } catch (_) {
                first = /(.*?)[ \t]*\r?\n/sy;
                line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
              }
              let match = first.exec(source);
              if (!match)
                return source;
              let res = match[1];
              let sep = " ";
              let pos = first.lastIndex;
              line.lastIndex = pos;
              while (match = line.exec(source)) {
                if (match[1] === "") {
                  if (sep === "\n")
                    res += sep;
                  else
                    sep = "\n";
                } else {
                  res += sep + match[1];
                  sep = " ";
                }
                pos = line.lastIndex;
              }
              const last = /[ \t]*(.*)/sy;
              last.lastIndex = pos;
              match = last.exec(source);
              return res + sep + (match && match[1] || "");
            }
            function doubleQuotedValue(source, onError) {
              let res = "";
              for (let i = 1; i < source.length - 1; ++i) {
                const ch = source[i];
                if (ch === "\r" && source[i + 1] === "\n")
                  continue;
                if (ch === "\n") {
                  const { fold, offset } = foldNewline(source, i);
                  res += fold;
                  i = offset;
                } else if (ch === "\\") {
                  let next = source[++i];
                  const cc = escapeCodes[next];
                  if (cc)
                    res += cc;
                  else if (next === "\n") {
                    next = source[i + 1];
                    while (next === " " || next === "	")
                      next = source[++i + 1];
                  } else if (next === "x" || next === "u" || next === "U") {
                    const length = { x: 2, u: 4, U: 8 }[next];
                    res += parseCharCode(source, i + 1, length, onError);
                    i += length;
                  } else {
                    const raw = source.substr(i - 1, 2);
                    onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
                    res += raw;
                  }
                } else if (ch === " " || ch === "	") {
                  const wsStart = i;
                  let next = source[i + 1];
                  while (next === " " || next === "	")
                    next = source[++i + 1];
                  if (next !== "\n")
                    res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
                } else {
                  res += ch;
                }
              }
              if (source[source.length - 1] !== '"' || source.length === 1)
                onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
              return res;
            }
            function foldNewline(source, offset) {
              let fold = "";
              let ch = source[offset + 1];
              while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
                if (ch === "\r" && source[offset + 2] !== "\n")
                  break;
                if (ch === "\n")
                  fold += "\n";
                offset += 1;
                ch = source[offset + 1];
              }
              if (!fold)
                fold = " ";
              return { fold, offset };
            }
            var escapeCodes = {
              "0": "\0",
              a: "\x07",
              b: "\b",
              e: "",
              f: "\f",
              n: "\n",
              r: "\r",
              t: "	",
              v: "\v",
              N: "\x85",
              _: "\xA0",
              L: "\u2028",
              P: "\u2029",
              " ": " ",
              '"': '"',
              "/": "/",
              "\\": "\\",
              "	": "	"
            };
            function parseCharCode(source, offset, length, onError) {
              const cc = source.substr(offset, length);
              const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
              const code = ok ? parseInt(cc, 16) : NaN;
              if (isNaN(code)) {
                const raw = source.substr(offset - 2, length + 2);
                onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
                return raw;
              }
              return String.fromCodePoint(code);
            }
            exports22.resolveFlowScalar = resolveFlowScalar;
          }
        });
        var require_compose_scalar22 = __commonJS22({
          "node_modules/yaml/dist/compose/compose-scalar.js"(exports22) {
            "use strict";
            var Node = require_Node22();
            var Scalar2 = require_Scalar22();
            var resolveBlockScalar = require_resolve_block_scalar22();
            var resolveFlowScalar = require_resolve_flow_scalar22();
            function composeScalar(ctx, token, tagToken, onError) {
              const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
              const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
              const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : findScalarTagByTest(ctx.schema, value, token.type === "scalar");
              let scalar;
              try {
                const res = tag.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
                scalar = Node.isScalar(res) ? res : new Scalar2.Scalar(res);
              } catch (error) {
                onError(tagToken || token, "TAG_RESOLVE_FAILED", error.message);
                scalar = new Scalar2.Scalar(value);
              }
              scalar.range = range;
              scalar.source = value;
              if (type)
                scalar.type = type;
              if (tagName)
                scalar.tag = tagName;
              if (tag.format)
                scalar.format = tag.format;
              if (comment)
                scalar.comment = comment;
              return scalar;
            }
            function findScalarTagByName(schema, value, tagName, tagToken, onError) {
              var _a;
              if (tagName === "!")
                return schema[Node.SCALAR];
              const matchWithTest = [];
              for (const tag of schema.tags) {
                if (!tag.collection && tag.tag === tagName) {
                  if (tag.default && tag.test)
                    matchWithTest.push(tag);
                  else
                    return tag;
                }
              }
              for (const tag of matchWithTest)
                if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
                  return tag;
              const kt = schema.knownTags[tagName];
              if (kt && !kt.collection) {
                schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
                return kt;
              }
              onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
              return schema[Node.SCALAR];
            }
            function findScalarTagByTest(schema, value, apply) {
              var _a;
              if (apply) {
                for (const tag of schema.tags) {
                  if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))
                    return tag;
                }
              }
              return schema[Node.SCALAR];
            }
            exports22.composeScalar = composeScalar;
          }
        });
        var require_util_empty_scalar_position22 = __commonJS22({
          "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports22) {
            "use strict";
            function emptyScalarPosition(offset, before, pos) {
              if (before) {
                if (pos === null)
                  pos = before.length;
                for (let i = pos - 1; i >= 0; --i) {
                  let st = before[i];
                  switch (st.type) {
                    case "space":
                    case "comment":
                    case "newline":
                      offset -= st.source.length;
                      continue;
                  }
                  st = before[++i];
                  while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
                    offset += st.source.length;
                    st = before[++i];
                  }
                  break;
                }
              }
              return offset;
            }
            exports22.emptyScalarPosition = emptyScalarPosition;
          }
        });
        var require_compose_node22 = __commonJS22({
          "node_modules/yaml/dist/compose/compose-node.js"(exports22) {
            "use strict";
            var Alias = require_Alias22();
            var composeCollection = require_compose_collection22();
            var composeScalar = require_compose_scalar22();
            var resolveEnd = require_resolve_end22();
            var utilEmptyScalarPosition = require_util_empty_scalar_position22();
            var CN = { composeNode, composeEmptyNode };
            function composeNode(ctx, token, props, onError) {
              const { spaceBefore, comment, anchor, tag } = props;
              let node;
              switch (token.type) {
                case "alias":
                  node = composeAlias(ctx, token, onError);
                  if (anchor || tag)
                    onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
                  break;
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                case "block-scalar":
                  node = composeScalar.composeScalar(ctx, token, tag, onError);
                  if (anchor)
                    node.anchor = anchor.source.substring(1);
                  break;
                case "block-map":
                case "block-seq":
                case "flow-collection":
                  node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
                  if (anchor)
                    node.anchor = anchor.source.substring(1);
                  break;
                default:
                  console.log(token);
                  throw new Error(`Unsupporten token type: ${token.type}`);
              }
              if (spaceBefore)
                node.spaceBefore = true;
              if (comment) {
                if (token.type === "scalar" && token.source === "")
                  node.comment = comment;
                else
                  node.commentBefore = comment;
              }
              return node;
            }
            function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
              const token = {
                type: "scalar",
                offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
                indent: -1,
                source: ""
              };
              const node = composeScalar.composeScalar(ctx, token, tag, onError);
              if (anchor)
                node.anchor = anchor.source.substring(1);
              if (spaceBefore)
                node.spaceBefore = true;
              if (comment)
                node.comment = comment;
              return node;
            }
            function composeAlias({ options }, { offset, source, end }, onError) {
              const alias = new Alias.Alias(source.substring(1));
              const valueEnd = offset + source.length;
              const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
              alias.range = [offset, valueEnd, re.offset];
              if (re.comment)
                alias.comment = re.comment;
              return alias;
            }
            exports22.composeEmptyNode = composeEmptyNode;
            exports22.composeNode = composeNode;
          }
        });
        var require_compose_doc22 = __commonJS22({
          "node_modules/yaml/dist/compose/compose-doc.js"(exports22) {
            "use strict";
            var Document4 = require_Document22();
            var composeNode = require_compose_node22();
            var resolveEnd = require_resolve_end22();
            var resolveProps = require_resolve_props22();
            function composeDoc(options, directives, { offset, start, value, end }, onError) {
              const opts = Object.assign({ directives }, options);
              const doc = new Document4.Document(void 0, opts);
              const ctx = {
                directives: doc.directives,
                options: doc.options,
                schema: doc.schema
              };
              const props = resolveProps.resolveProps(start, {
                indicator: "doc-start",
                next: value || (end === null || end === void 0 ? void 0 : end[0]),
                offset,
                onError,
                startOnNewline: true
              });
              if (props.found) {
                doc.directives.marker = true;
                if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
                  onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
              }
              doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
              const contentEnd = doc.contents.range[2];
              const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
              if (re.comment)
                doc.comment = re.comment;
              doc.range = [offset, contentEnd, re.offset];
              return doc;
            }
            exports22.composeDoc = composeDoc;
          }
        });
        var require_composer22 = __commonJS22({
          "node_modules/yaml/dist/compose/composer.js"(exports22) {
            "use strict";
            var directives = require_directives22();
            var Document4 = require_Document22();
            var errors = require_errors22();
            var Node = require_Node22();
            var options = require_options22();
            var composeDoc = require_compose_doc22();
            var resolveEnd = require_resolve_end22();
            function getErrorPos(src) {
              if (typeof src === "number")
                return [src, src + 1];
              if (Array.isArray(src))
                return src.length === 2 ? src : [src[0], src[1]];
              const { offset, source } = src;
              return [offset, offset + (typeof source === "string" ? source.length : 1)];
            }
            function parsePrelude(prelude) {
              let comment = "";
              let atComment = false;
              let afterEmptyLine = false;
              for (let i = 0; i < prelude.length; ++i) {
                const source = prelude[i];
                switch (source[0]) {
                  case "#":
                    comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
                    atComment = true;
                    afterEmptyLine = false;
                    break;
                  case "%":
                    if (prelude[i + 1][0] !== "#")
                      i += 1;
                    atComment = false;
                    break;
                  default:
                    if (!atComment)
                      afterEmptyLine = true;
                    atComment = false;
                }
              }
              return { comment, afterEmptyLine };
            }
            var Composer = class {
              constructor(options$1 = {}) {
                this.doc = null;
                this.atDirectives = false;
                this.prelude = [];
                this.errors = [];
                this.warnings = [];
                this.onError = (source, code, message, warning) => {
                  const pos = getErrorPos(source);
                  if (warning)
                    this.warnings.push(new errors.YAMLWarning(pos, code, message));
                  else
                    this.errors.push(new errors.YAMLParseError(pos, code, message));
                };
                this.directives = new directives.Directives({
                  version: options$1.version || options.defaultOptions.version
                });
                this.options = options$1;
              }
              decorate(doc, afterDoc) {
                const { comment, afterEmptyLine } = parsePrelude(this.prelude);
                if (comment) {
                  const dc = doc.contents;
                  if (afterDoc) {
                    doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
                  } else if (afterEmptyLine || doc.directives.marker || !dc) {
                    doc.commentBefore = comment;
                  } else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                    let it = dc.items[0];
                    if (Node.isPair(it))
                      it = it.key;
                    const cb = it.commentBefore;
                    it.commentBefore = cb ? `${comment}
${cb}` : comment;
                  } else {
                    const cb = dc.commentBefore;
                    dc.commentBefore = cb ? `${comment}
${cb}` : comment;
                  }
                }
                if (afterDoc) {
                  Array.prototype.push.apply(doc.errors, this.errors);
                  Array.prototype.push.apply(doc.warnings, this.warnings);
                } else {
                  doc.errors = this.errors;
                  doc.warnings = this.warnings;
                }
                this.prelude = [];
                this.errors = [];
                this.warnings = [];
              }
              streamInfo() {
                return {
                  comment: parsePrelude(this.prelude).comment,
                  directives: this.directives,
                  errors: this.errors,
                  warnings: this.warnings
                };
              }
              *compose(tokens, forceDoc = false, endOffset = -1) {
                for (const token of tokens)
                  yield* this.next(token);
                yield* this.end(forceDoc, endOffset);
              }
              *next(token) {
                if (process.env.LOG_STREAM)
                  console.dir(token, { depth: null });
                switch (token.type) {
                  case "directive":
                    this.directives.add(token.source, (offset, message, warning) => {
                      const pos = getErrorPos(token);
                      pos[0] += offset;
                      this.onError(pos, "BAD_DIRECTIVE", message, warning);
                    });
                    this.prelude.push(token.source);
                    this.atDirectives = true;
                    break;
                  case "document": {
                    const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                    if (this.atDirectives && !doc.directives.marker)
                      this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
                    this.decorate(doc, false);
                    if (this.doc)
                      yield this.doc;
                    this.doc = doc;
                    this.atDirectives = false;
                    break;
                  }
                  case "byte-order-mark":
                  case "space":
                    break;
                  case "comment":
                  case "newline":
                    this.prelude.push(token.source);
                    break;
                  case "error": {
                    const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
                    const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
                    if (this.atDirectives || !this.doc)
                      this.errors.push(error);
                    else
                      this.doc.errors.push(error);
                    break;
                  }
                  case "doc-end": {
                    if (!this.doc) {
                      const msg = "Unexpected doc-end without preceding document";
                      this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                      break;
                    }
                    const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                    this.decorate(this.doc, true);
                    if (end.comment) {
                      const dc = this.doc.comment;
                      this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
                    }
                    this.doc.range[2] = end.offset;
                    break;
                  }
                  default:
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
                }
              }
              *end(forceDoc = false, endOffset = -1) {
                if (this.doc) {
                  this.decorate(this.doc, true);
                  yield this.doc;
                  this.doc = null;
                } else if (forceDoc) {
                  const opts = Object.assign({ directives: this.directives }, this.options);
                  const doc = new Document4.Document(void 0, opts);
                  if (this.atDirectives)
                    this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
                  doc.range = [0, endOffset, endOffset];
                  this.decorate(doc, false);
                  yield doc;
                }
              }
            };
            exports22.Composer = Composer;
          }
        });
        var require_cst_scalar22 = __commonJS22({
          "node_modules/yaml/dist/parse/cst-scalar.js"(exports22) {
            "use strict";
            var resolveBlockScalar = require_resolve_block_scalar22();
            var resolveFlowScalar = require_resolve_flow_scalar22();
            var errors = require_errors22();
            var stringifyString = require_stringifyString22();
            function resolveAsScalar(token, strict = true, onError) {
              if (token) {
                const _onError = (pos, code, message) => {
                  const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
                  if (onError)
                    onError(offset, code, message);
                  else
                    throw new errors.YAMLParseError([offset, offset + 1], code, message);
                };
                switch (token.type) {
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
                  case "block-scalar":
                    return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
                }
              }
              return null;
            }
            function createScalarToken(value, context) {
              var _a;
              const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
              const source = stringifyString.stringifyString({ type, value }, {
                implicitKey,
                indent: indent > 0 ? " ".repeat(indent) : "",
                inFlow,
                options: { lineWidth: -1 }
              });
              const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
                { type: "newline", offset: -1, indent, source: "\n" }
              ];
              switch (source[0]) {
                case "|":
                case ">": {
                  const he = source.indexOf("\n");
                  const head = source.substring(0, he);
                  const body = source.substring(he + 1) + "\n";
                  const props = [
                    { type: "block-scalar-header", offset, indent, source: head }
                  ];
                  if (!addEndtoBlockProps(props, end))
                    props.push({ type: "newline", offset: -1, indent, source: "\n" });
                  return { type: "block-scalar", offset, indent, props, source: body };
                }
                case '"':
                  return { type: "double-quoted-scalar", offset, indent, source, end };
                case "'":
                  return { type: "single-quoted-scalar", offset, indent, source, end };
                default:
                  return { type: "scalar", offset, indent, source, end };
              }
            }
            function setScalarValue(token, value, context = {}) {
              let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
              let indent = "indent" in token ? token.indent : null;
              if (afterKey && typeof indent === "number")
                indent += 2;
              if (!type)
                switch (token.type) {
                  case "single-quoted-scalar":
                    type = "QUOTE_SINGLE";
                    break;
                  case "double-quoted-scalar":
                    type = "QUOTE_DOUBLE";
                    break;
                  case "block-scalar": {
                    const header = token.props[0];
                    if (header.type !== "block-scalar-header")
                      throw new Error("Invalid block scalar header");
                    type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                    break;
                  }
                  default:
                    type = "PLAIN";
                }
              const source = stringifyString.stringifyString({ type, value }, {
                implicitKey: implicitKey || indent === null,
                indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
                inFlow,
                options: { lineWidth: -1 }
              });
              switch (source[0]) {
                case "|":
                case ">":
                  setBlockScalarValue(token, source);
                  break;
                case '"':
                  setFlowScalarValue(token, source, "double-quoted-scalar");
                  break;
                case "'":
                  setFlowScalarValue(token, source, "single-quoted-scalar");
                  break;
                default:
                  setFlowScalarValue(token, source, "scalar");
              }
            }
            function setBlockScalarValue(token, source) {
              const he = source.indexOf("\n");
              const head = source.substring(0, he);
              const body = source.substring(he + 1) + "\n";
              if (token.type === "block-scalar") {
                const header = token.props[0];
                if (header.type !== "block-scalar-header")
                  throw new Error("Invalid block scalar header");
                header.source = head;
                token.source = body;
              } else {
                const { offset } = token;
                const indent = "indent" in token ? token.indent : -1;
                const props = [
                  { type: "block-scalar-header", offset, indent, source: head }
                ];
                if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
                  props.push({ type: "newline", offset: -1, indent, source: "\n" });
                for (const key of Object.keys(token))
                  if (key !== "type" && key !== "offset")
                    delete token[key];
                Object.assign(token, { type: "block-scalar", indent, props, source: body });
              }
            }
            function addEndtoBlockProps(props, end) {
              if (end)
                for (const st of end)
                  switch (st.type) {
                    case "space":
                    case "comment":
                      props.push(st);
                      break;
                    case "newline":
                      props.push(st);
                      return true;
                  }
              return false;
            }
            function setFlowScalarValue(token, source, type) {
              switch (token.type) {
                case "scalar":
                case "double-quoted-scalar":
                case "single-quoted-scalar":
                  token.type = type;
                  token.source = source;
                  break;
                case "block-scalar": {
                  const end = token.props.slice(1);
                  let oa = source.length;
                  if (token.props[0].type === "block-scalar-header")
                    oa -= token.props[0].source.length;
                  for (const tok of end)
                    tok.offset += oa;
                  delete token.props;
                  Object.assign(token, { type, source, end });
                  break;
                }
                case "block-map":
                case "block-seq": {
                  const offset = token.offset + source.length;
                  const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
                  delete token.items;
                  Object.assign(token, { type, source, end: [nl] });
                  break;
                }
                default: {
                  const indent = "indent" in token ? token.indent : -1;
                  const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
                  for (const key of Object.keys(token))
                    if (key !== "type" && key !== "offset")
                      delete token[key];
                  Object.assign(token, { type, indent, source, end });
                }
              }
            }
            exports22.createScalarToken = createScalarToken;
            exports22.resolveAsScalar = resolveAsScalar;
            exports22.setScalarValue = setScalarValue;
          }
        });
        var require_cst_stringify22 = __commonJS22({
          "node_modules/yaml/dist/parse/cst-stringify.js"(exports22) {
            "use strict";
            var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
            function stringifyToken(token) {
              switch (token.type) {
                case "block-scalar": {
                  let res = "";
                  for (const tok of token.props)
                    res += stringifyToken(tok);
                  return res + token.source;
                }
                case "block-map":
                case "block-seq": {
                  let res = "";
                  for (const item of token.items)
                    res += stringifyItem(item);
                  return res;
                }
                case "flow-collection": {
                  let res = token.start.source;
                  for (const item of token.items)
                    res += stringifyItem(item);
                  for (const st of token.end)
                    res += st.source;
                  return res;
                }
                case "document": {
                  let res = stringifyItem(token);
                  if (token.end)
                    for (const st of token.end)
                      res += st.source;
                  return res;
                }
                default: {
                  let res = token.source;
                  if ("end" in token && token.end)
                    for (const st of token.end)
                      res += st.source;
                  return res;
                }
              }
            }
            function stringifyItem({ start, key, sep, value }) {
              let res = "";
              for (const st of start)
                res += st.source;
              if (key)
                res += stringifyToken(key);
              if (sep)
                for (const st of sep)
                  res += st.source;
              if (value)
                res += stringifyToken(value);
              return res;
            }
            exports22.stringify = stringify2;
          }
        });
        var require_cst_visit22 = __commonJS22({
          "node_modules/yaml/dist/parse/cst-visit.js"(exports22) {
            "use strict";
            var BREAK = Symbol("break visit");
            var SKIP = Symbol("skip children");
            var REMOVE = Symbol("remove item");
            function visit(cst, visitor) {
              if ("type" in cst && cst.type === "document")
                cst = { start: cst.start, value: cst.value };
              _visit(Object.freeze([]), cst, visitor);
            }
            visit.BREAK = BREAK;
            visit.SKIP = SKIP;
            visit.REMOVE = REMOVE;
            visit.itemAtPath = (cst, path7) => {
              let item = cst;
              for (const [field, index] of path7) {
                const tok = item && item[field];
                if (tok && "items" in tok) {
                  item = tok.items[index];
                } else
                  return void 0;
              }
              return item;
            };
            visit.parentCollection = (cst, path7) => {
              const parent = visit.itemAtPath(cst, path7.slice(0, -1));
              const field = path7[path7.length - 1][0];
              const coll = parent && parent[field];
              if (coll && "items" in coll)
                return coll;
              throw new Error("Parent collection not found");
            };
            function _visit(path7, item, visitor) {
              let ctrl = visitor(item, path7);
              if (typeof ctrl === "symbol")
                return ctrl;
              for (const field of ["key", "value"]) {
                const token = item[field];
                if (token && "items" in token) {
                  for (let i = 0; i < token.items.length; ++i) {
                    const ci = _visit(Object.freeze(path7.concat([[field, i]])), token.items[i], visitor);
                    if (typeof ci === "number")
                      i = ci - 1;
                    else if (ci === BREAK)
                      return BREAK;
                    else if (ci === REMOVE) {
                      token.items.splice(i, 1);
                      i -= 1;
                    }
                  }
                  if (typeof ctrl === "function" && field === "key")
                    ctrl = ctrl(item, path7);
                }
              }
              return typeof ctrl === "function" ? ctrl(item, path7) : ctrl;
            }
            exports22.visit = visit;
          }
        });
        var require_cst22 = __commonJS22({
          "node_modules/yaml/dist/parse/cst.js"(exports22) {
            "use strict";
            var cstScalar = require_cst_scalar22();
            var cstStringify = require_cst_stringify22();
            var cstVisit = require_cst_visit22();
            var BOM = "\uFEFF";
            var DOCUMENT = "";
            var FLOW_END = "";
            var SCALAR = "";
            var isCollection = (token) => !!token && "items" in token;
            var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
            function prettyToken(token) {
              switch (token) {
                case BOM:
                  return "<BOM>";
                case DOCUMENT:
                  return "<DOC>";
                case FLOW_END:
                  return "<FLOW_END>";
                case SCALAR:
                  return "<SCALAR>";
                default:
                  return JSON.stringify(token);
              }
            }
            function tokenType(source) {
              switch (source) {
                case BOM:
                  return "byte-order-mark";
                case DOCUMENT:
                  return "doc-mode";
                case FLOW_END:
                  return "flow-error-end";
                case SCALAR:
                  return "scalar";
                case "---":
                  return "doc-start";
                case "...":
                  return "doc-end";
                case "":
                case "\n":
                case "\r\n":
                  return "newline";
                case "-":
                  return "seq-item-ind";
                case "?":
                  return "explicit-key-ind";
                case ":":
                  return "map-value-ind";
                case "{":
                  return "flow-map-start";
                case "}":
                  return "flow-map-end";
                case "[":
                  return "flow-seq-start";
                case "]":
                  return "flow-seq-end";
                case ",":
                  return "comma";
              }
              switch (source[0]) {
                case " ":
                case "	":
                  return "space";
                case "#":
                  return "comment";
                case "%":
                  return "directive-line";
                case "*":
                  return "alias";
                case "&":
                  return "anchor";
                case "!":
                  return "tag";
                case "'":
                  return "single-quoted-scalar";
                case '"':
                  return "double-quoted-scalar";
                case "|":
                case ">":
                  return "block-scalar-header";
              }
              return null;
            }
            exports22.createScalarToken = cstScalar.createScalarToken;
            exports22.resolveAsScalar = cstScalar.resolveAsScalar;
            exports22.setScalarValue = cstScalar.setScalarValue;
            exports22.stringify = cstStringify.stringify;
            exports22.visit = cstVisit.visit;
            exports22.BOM = BOM;
            exports22.DOCUMENT = DOCUMENT;
            exports22.FLOW_END = FLOW_END;
            exports22.SCALAR = SCALAR;
            exports22.isCollection = isCollection;
            exports22.isScalar = isScalar;
            exports22.prettyToken = prettyToken;
            exports22.tokenType = tokenType;
          }
        });
        var require_lexer22 = __commonJS22({
          "node_modules/yaml/dist/parse/lexer.js"(exports22) {
            "use strict";
            var cst = require_cst22();
            function isEmpty(ch) {
              switch (ch) {
                case void 0:
                case " ":
                case "\n":
                case "\r":
                case "	":
                  return true;
                default:
                  return false;
              }
            }
            var invalidFlowScalarChars = [",", "[", "]", "{", "}"];
            var invalidIdentifierChars = [" ", ",", "[", "]", "{", "}", "\n", "\r", "	"];
            var isNotIdentifierChar = (ch) => !ch || invalidIdentifierChars.includes(ch);
            var Lexer = class {
              constructor() {
                this.atEnd = false;
                this.blockScalarIndent = -1;
                this.blockScalarKeep = false;
                this.buffer = "";
                this.flowKey = false;
                this.flowLevel = 0;
                this.indentNext = 0;
                this.indentValue = 0;
                this.next = null;
                this.pos = 0;
              }
              *lex(source, incomplete = false) {
                if (source)
                  this.buffer = this.buffer ? this.buffer + source : source;
                this.atEnd = !incomplete;
                let next = this.next || "stream";
                while (next && (incomplete || this.hasChars(1)))
                  next = yield* this.parseNext(next);
              }
              atLineEnd() {
                let i = this.pos;
                let ch = this.buffer[i];
                while (ch === " " || ch === "	")
                  ch = this.buffer[++i];
                if (!ch || ch === "#" || ch === "\n")
                  return true;
                if (ch === "\r")
                  return this.buffer[i + 1] === "\n";
                return false;
              }
              charAt(n) {
                return this.buffer[this.pos + n];
              }
              continueScalar(offset) {
                let ch = this.buffer[offset];
                if (this.indentNext > 0) {
                  let indent = 0;
                  while (ch === " ")
                    ch = this.buffer[++indent + offset];
                  if (ch === "\r") {
                    const next = this.buffer[indent + offset + 1];
                    if (next === "\n" || !next && !this.atEnd)
                      return offset + indent + 1;
                  }
                  return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
                }
                if (ch === "-" || ch === ".") {
                  const dt = this.buffer.substr(offset, 3);
                  if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
                    return -1;
                }
                return offset;
              }
              getLine() {
                let end = this.buffer.indexOf("\n", this.pos);
                if (end === -1)
                  return this.atEnd ? this.buffer.substring(this.pos) : null;
                if (this.buffer[end - 1] === "\r")
                  end -= 1;
                return this.buffer.substring(this.pos, end);
              }
              hasChars(n) {
                return this.pos + n <= this.buffer.length;
              }
              setNext(state) {
                this.buffer = this.buffer.substring(this.pos);
                this.pos = 0;
                this.next = state;
                return null;
              }
              peek(n) {
                return this.buffer.substr(this.pos, n);
              }
              *parseNext(next) {
                switch (next) {
                  case "stream":
                    return yield* this.parseStream();
                  case "line-start":
                    return yield* this.parseLineStart();
                  case "block-start":
                    return yield* this.parseBlockStart();
                  case "doc":
                    return yield* this.parseDocument();
                  case "flow":
                    return yield* this.parseFlowCollection();
                  case "quoted-scalar":
                    return yield* this.parseQuotedScalar();
                  case "block-scalar":
                    return yield* this.parseBlockScalar();
                  case "plain-scalar":
                    return yield* this.parsePlainScalar();
                }
              }
              *parseStream() {
                let line = this.getLine();
                if (line === null)
                  return this.setNext("stream");
                if (line[0] === cst.BOM) {
                  yield* this.pushCount(1);
                  line = line.substring(1);
                }
                if (line[0] === "%") {
                  let dirEnd = line.length;
                  const cs = line.indexOf("#");
                  if (cs !== -1) {
                    const ch = line[cs - 1];
                    if (ch === " " || ch === "	")
                      dirEnd = cs - 1;
                  }
                  while (true) {
                    const ch = line[dirEnd - 1];
                    if (ch === " " || ch === "	")
                      dirEnd -= 1;
                    else
                      break;
                  }
                  const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
                  yield* this.pushCount(line.length - n);
                  this.pushNewline();
                  return "stream";
                }
                if (this.atLineEnd()) {
                  const sp = yield* this.pushSpaces(true);
                  yield* this.pushCount(line.length - sp);
                  yield* this.pushNewline();
                  return "stream";
                }
                yield cst.DOCUMENT;
                return yield* this.parseLineStart();
              }
              *parseLineStart() {
                const ch = this.charAt(0);
                if (!ch && !this.atEnd)
                  return this.setNext("line-start");
                if (ch === "-" || ch === ".") {
                  if (!this.atEnd && !this.hasChars(4))
                    return this.setNext("line-start");
                  const s = this.peek(3);
                  if (s === "---" && isEmpty(this.charAt(3))) {
                    yield* this.pushCount(3);
                    this.indentValue = 0;
                    this.indentNext = 0;
                    return "doc";
                  } else if (s === "..." && isEmpty(this.charAt(3))) {
                    yield* this.pushCount(3);
                    return "stream";
                  }
                }
                this.indentValue = yield* this.pushSpaces(false);
                if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
                  this.indentNext = this.indentValue;
                return yield* this.parseBlockStart();
              }
              *parseBlockStart() {
                const [ch0, ch1] = this.peek(2);
                if (!ch1 && !this.atEnd)
                  return this.setNext("block-start");
                if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
                  const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
                  this.indentNext = this.indentValue + 1;
                  this.indentValue += n;
                  return yield* this.parseBlockStart();
                }
                return "doc";
              }
              *parseDocument() {
                yield* this.pushSpaces(true);
                const line = this.getLine();
                if (line === null)
                  return this.setNext("doc");
                let n = yield* this.pushIndicators();
                switch (line[n]) {
                  case "#":
                    yield* this.pushCount(line.length - n);
                  case void 0:
                    yield* this.pushNewline();
                    return yield* this.parseLineStart();
                  case "{":
                  case "[":
                    yield* this.pushCount(1);
                    this.flowKey = false;
                    this.flowLevel = 1;
                    return "flow";
                  case "}":
                  case "]":
                    yield* this.pushCount(1);
                    return "doc";
                  case "*":
                    yield* this.pushUntil(isNotIdentifierChar);
                    return "doc";
                  case '"':
                  case "'":
                    return yield* this.parseQuotedScalar();
                  case "|":
                  case ">":
                    n += yield* this.parseBlockScalarHeader();
                    n += yield* this.pushSpaces(true);
                    yield* this.pushCount(line.length - n);
                    yield* this.pushNewline();
                    return yield* this.parseBlockScalar();
                  default:
                    return yield* this.parsePlainScalar();
                }
              }
              *parseFlowCollection() {
                let nl, sp;
                let indent = -1;
                do {
                  nl = yield* this.pushNewline();
                  sp = yield* this.pushSpaces(true);
                  if (nl > 0)
                    this.indentValue = indent = sp;
                } while (nl + sp > 0);
                const line = this.getLine();
                if (line === null)
                  return this.setNext("flow");
                if (indent !== -1 && indent < this.indentNext || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
                  const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
                  if (!atFlowEndMarker) {
                    this.flowLevel = 0;
                    yield cst.FLOW_END;
                    return yield* this.parseLineStart();
                  }
                }
                let n = 0;
                while (line[n] === ",")
                  n += (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
                n += yield* this.pushIndicators();
                switch (line[n]) {
                  case void 0:
                    return "flow";
                  case "#":
                    yield* this.pushCount(line.length - n);
                    return "flow";
                  case "{":
                  case "[":
                    yield* this.pushCount(1);
                    this.flowKey = false;
                    this.flowLevel += 1;
                    return "flow";
                  case "}":
                  case "]":
                    yield* this.pushCount(1);
                    this.flowKey = true;
                    this.flowLevel -= 1;
                    return this.flowLevel ? "flow" : "doc";
                  case "*":
                    yield* this.pushUntil(isNotIdentifierChar);
                    return "flow";
                  case '"':
                  case "'":
                    this.flowKey = true;
                    return yield* this.parseQuotedScalar();
                  case ":": {
                    const next = this.charAt(1);
                    if (this.flowKey || isEmpty(next) || next === ",") {
                      yield* this.pushCount(1);
                      yield* this.pushSpaces(true);
                      return "flow";
                    }
                  }
                  default:
                    this.flowKey = false;
                    return yield* this.parsePlainScalar();
                }
              }
              *parseQuotedScalar() {
                const quote = this.charAt(0);
                let end = this.buffer.indexOf(quote, this.pos + 1);
                if (quote === "'") {
                  while (end !== -1 && this.buffer[end + 1] === "'")
                    end = this.buffer.indexOf("'", end + 2);
                } else {
                  while (end !== -1) {
                    let n = 0;
                    while (this.buffer[end - 1 - n] === "\\")
                      n += 1;
                    if (n % 2 === 0)
                      break;
                    end = this.buffer.indexOf('"', end + 1);
                  }
                }
                let nl = this.buffer.indexOf("\n", this.pos);
                if (nl !== -1 && nl < end) {
                  while (nl !== -1 && nl < end) {
                    const cs = this.continueScalar(nl + 1);
                    if (cs === -1)
                      break;
                    nl = this.buffer.indexOf("\n", cs);
                  }
                  if (nl !== -1 && nl < end) {
                    end = nl - 1;
                  }
                }
                if (end === -1) {
                  if (!this.atEnd)
                    return this.setNext("quoted-scalar");
                  end = this.buffer.length;
                }
                yield* this.pushToIndex(end + 1, false);
                return this.flowLevel ? "flow" : "doc";
              }
              *parseBlockScalarHeader() {
                this.blockScalarIndent = -1;
                this.blockScalarKeep = false;
                let i = this.pos;
                while (true) {
                  const ch = this.buffer[++i];
                  if (ch === "+")
                    this.blockScalarKeep = true;
                  else if (ch > "0" && ch <= "9")
                    this.blockScalarIndent = Number(ch) - 1;
                  else if (ch !== "-")
                    break;
                }
                return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
              }
              *parseBlockScalar() {
                let nl = this.pos - 1;
                let indent = 0;
                let ch;
                loop:
                  for (let i = this.pos; ch = this.buffer[i]; ++i) {
                    switch (ch) {
                      case " ":
                        indent += 1;
                        break;
                      case "\n":
                        nl = i;
                        indent = 0;
                        break;
                      case "\r": {
                        const next = this.buffer[i + 1];
                        if (!next && !this.atEnd)
                          return this.setNext("block-scalar");
                        if (next === "\n")
                          break;
                      }
                      default:
                        break loop;
                    }
                  }
                if (!ch && !this.atEnd)
                  return this.setNext("block-scalar");
                if (indent >= this.indentNext) {
                  if (this.blockScalarIndent === -1)
                    this.indentNext = indent;
                  else
                    this.indentNext += this.blockScalarIndent;
                  do {
                    const cs = this.continueScalar(nl + 1);
                    if (cs === -1)
                      break;
                    nl = this.buffer.indexOf("\n", cs);
                  } while (nl !== -1);
                  if (nl === -1) {
                    if (!this.atEnd)
                      return this.setNext("block-scalar");
                    nl = this.buffer.length;
                  }
                }
                if (!this.blockScalarKeep) {
                  do {
                    let i = nl - 1;
                    let ch2 = this.buffer[i];
                    if (ch2 === "\r")
                      ch2 = this.buffer[--i];
                    while (ch2 === " " || ch2 === "	")
                      ch2 = this.buffer[--i];
                    if (ch2 === "\n" && i >= this.pos)
                      nl = i;
                    else
                      break;
                  } while (true);
                }
                yield cst.SCALAR;
                yield* this.pushToIndex(nl + 1, true);
                return yield* this.parseLineStart();
              }
              *parsePlainScalar() {
                const inFlow = this.flowLevel > 0;
                let end = this.pos - 1;
                let i = this.pos - 1;
                let ch;
                while (ch = this.buffer[++i]) {
                  if (ch === ":") {
                    const next = this.buffer[i + 1];
                    if (isEmpty(next) || inFlow && next === ",")
                      break;
                    end = i;
                  } else if (isEmpty(ch)) {
                    const next = this.buffer[i + 1];
                    if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
                      break;
                    if (ch === "\r") {
                      if (next === "\n") {
                        i += 1;
                        ch = "\n";
                      } else
                        end = i;
                    }
                    if (ch === "\n") {
                      const cs = this.continueScalar(i + 1);
                      if (cs === -1)
                        break;
                      i = Math.max(i, cs - 2);
                    }
                  } else {
                    if (inFlow && invalidFlowScalarChars.includes(ch))
                      break;
                    end = i;
                  }
                }
                if (!ch && !this.atEnd)
                  return this.setNext("plain-scalar");
                yield cst.SCALAR;
                yield* this.pushToIndex(end + 1, true);
                return inFlow ? "flow" : "doc";
              }
              *pushCount(n) {
                if (n > 0) {
                  yield this.buffer.substr(this.pos, n);
                  this.pos += n;
                  return n;
                }
                return 0;
              }
              *pushToIndex(i, allowEmpty) {
                const s = this.buffer.slice(this.pos, i);
                if (s) {
                  yield s;
                  this.pos += s.length;
                  return s.length;
                } else if (allowEmpty)
                  yield "";
                return 0;
              }
              *pushIndicators() {
                switch (this.charAt(0)) {
                  case "!":
                    if (this.charAt(1) === "<")
                      return (yield* this.pushVerbatimTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                  case "&":
                    return (yield* this.pushUntil(isNotIdentifierChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                  case ":":
                  case "?":
                  case "-":
                    if (isEmpty(this.charAt(1))) {
                      if (this.flowLevel === 0)
                        this.indentNext = this.indentValue + 1;
                      return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                    }
                }
                return 0;
              }
              *pushVerbatimTag() {
                let i = this.pos + 2;
                let ch = this.buffer[i];
                while (!isEmpty(ch) && ch !== ">")
                  ch = this.buffer[++i];
                return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
              }
              *pushNewline() {
                const ch = this.buffer[this.pos];
                if (ch === "\n")
                  return yield* this.pushCount(1);
                else if (ch === "\r" && this.charAt(1) === "\n")
                  return yield* this.pushCount(2);
                else
                  return 0;
              }
              *pushSpaces(allowTabs) {
                let i = this.pos - 1;
                let ch;
                do {
                  ch = this.buffer[++i];
                } while (ch === " " || allowTabs && ch === "	");
                const n = i - this.pos;
                if (n > 0) {
                  yield this.buffer.substr(this.pos, n);
                  this.pos = i;
                }
                return n;
              }
              *pushUntil(test) {
                let i = this.pos;
                let ch = this.buffer[i];
                while (!test(ch))
                  ch = this.buffer[++i];
                return yield* this.pushToIndex(i, false);
              }
            };
            exports22.Lexer = Lexer;
          }
        });
        var require_line_counter22 = __commonJS22({
          "node_modules/yaml/dist/parse/line-counter.js"(exports22) {
            "use strict";
            var LineCounter = class {
              constructor() {
                this.lineStarts = [];
                this.addNewLine = (offset) => this.lineStarts.push(offset);
                this.linePos = (offset) => {
                  let low = 0;
                  let high = this.lineStarts.length;
                  while (low < high) {
                    const mid = low + high >> 1;
                    if (this.lineStarts[mid] < offset)
                      low = mid + 1;
                    else
                      high = mid;
                  }
                  if (this.lineStarts[low] === offset)
                    return { line: low + 1, col: 1 };
                  if (low === 0)
                    return { line: 0, col: offset };
                  const start = this.lineStarts[low - 1];
                  return { line: low, col: offset - start + 1 };
                };
              }
            };
            exports22.LineCounter = LineCounter;
          }
        });
        var require_parser22 = __commonJS22({
          "node_modules/yaml/dist/parse/parser.js"(exports22) {
            "use strict";
            var cst = require_cst22();
            var lexer = require_lexer22();
            function includesToken(list, type) {
              for (let i = 0; i < list.length; ++i)
                if (list[i].type === type)
                  return true;
              return false;
            }
            function includesNonEmpty(list) {
              for (let i = 0; i < list.length; ++i) {
                switch (list[i].type) {
                  case "space":
                  case "comment":
                  case "newline":
                    break;
                  default:
                    return true;
                }
              }
              return false;
            }
            function isFlowToken(token) {
              switch (token === null || token === void 0 ? void 0 : token.type) {
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                case "flow-collection":
                  return true;
                default:
                  return false;
              }
            }
            function getPrevProps(parent) {
              switch (parent.type) {
                case "document":
                  return parent.start;
                case "block-map": {
                  const it = parent.items[parent.items.length - 1];
                  return it.sep || it.start;
                }
                case "block-seq":
                  return parent.items[parent.items.length - 1].start;
                default:
                  return [];
              }
            }
            function getFirstKeyStartProps(prev) {
              var _a;
              if (prev.length === 0)
                return [];
              let i = prev.length;
              loop:
                while (--i >= 0) {
                  switch (prev[i].type) {
                    case "doc-start":
                    case "explicit-key-ind":
                    case "map-value-ind":
                    case "seq-item-ind":
                    case "newline":
                      break loop;
                  }
                }
              while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
              }
              return prev.splice(i, prev.length);
            }
            function fixFlowSeqItems(fc) {
              if (fc.start.type === "flow-seq-start") {
                for (const it of fc.items) {
                  if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
                    if (it.key)
                      it.value = it.key;
                    delete it.key;
                    if (isFlowToken(it.value)) {
                      if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                      else
                        it.value.end = it.sep;
                    } else
                      Array.prototype.push.apply(it.start, it.sep);
                    delete it.sep;
                  }
                }
              }
            }
            var Parser = class {
              constructor(onNewLine) {
                this.atNewLine = true;
                this.atScalar = false;
                this.indent = 0;
                this.offset = 0;
                this.onKeyLine = false;
                this.stack = [];
                this.source = "";
                this.type = "";
                this.lexer = new lexer.Lexer();
                this.onNewLine = onNewLine;
              }
              *parse(source, incomplete = false) {
                if (this.onNewLine && this.offset === 0)
                  this.onNewLine(0);
                for (const lexeme of this.lexer.lex(source, incomplete))
                  yield* this.next(lexeme);
                if (!incomplete)
                  yield* this.end();
              }
              *next(source) {
                this.source = source;
                if (process.env.LOG_TOKENS)
                  console.log("|", cst.prettyToken(source));
                if (this.atScalar) {
                  this.atScalar = false;
                  yield* this.step();
                  this.offset += source.length;
                  return;
                }
                const type = cst.tokenType(source);
                if (!type) {
                  const message = `Not a YAML token: ${source}`;
                  yield* this.pop({ type: "error", offset: this.offset, message, source });
                  this.offset += source.length;
                } else if (type === "scalar") {
                  this.atNewLine = false;
                  this.atScalar = true;
                  this.type = "scalar";
                } else {
                  this.type = type;
                  yield* this.step();
                  switch (type) {
                    case "newline":
                      this.atNewLine = true;
                      this.indent = 0;
                      if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                      break;
                    case "space":
                      if (this.atNewLine && source[0] === " ")
                        this.indent += source.length;
                      break;
                    case "explicit-key-ind":
                    case "map-value-ind":
                    case "seq-item-ind":
                      if (this.atNewLine)
                        this.indent += source.length;
                      break;
                    case "doc-mode":
                      return;
                    default:
                      this.atNewLine = false;
                  }
                  this.offset += source.length;
                }
              }
              *end() {
                while (this.stack.length > 0)
                  yield* this.pop();
              }
              get sourceToken() {
                const st = {
                  type: this.type,
                  offset: this.offset,
                  indent: this.indent,
                  source: this.source
                };
                return st;
              }
              *step() {
                const top = this.peek(1);
                if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
                  while (this.stack.length > 0)
                    yield* this.pop();
                  this.stack.push({
                    type: "doc-end",
                    offset: this.offset,
                    source: this.source
                  });
                  return;
                }
                if (!top)
                  return yield* this.stream();
                switch (top.type) {
                  case "document":
                    return yield* this.document(top);
                  case "alias":
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    return yield* this.scalar(top);
                  case "block-scalar":
                    return yield* this.blockScalar(top);
                  case "block-map":
                    return yield* this.blockMap(top);
                  case "block-seq":
                    return yield* this.blockSequence(top);
                  case "flow-collection":
                    return yield* this.flowCollection(top);
                  case "doc-end":
                    return yield* this.documentEnd(top);
                }
                yield* this.pop();
              }
              peek(n) {
                return this.stack[this.stack.length - n];
              }
              *pop(error) {
                const token = error || this.stack.pop();
                if (!token) {
                  const message = "Tried to pop an empty stack";
                  yield { type: "error", offset: this.offset, source: "", message };
                } else if (this.stack.length === 0) {
                  yield token;
                } else {
                  const top = this.peek(1);
                  if (token.type === "block-scalar" || token.type === "flow-collection")
                    token.indent = "indent" in top ? top.indent : -1;
                  if (token.type === "flow-collection")
                    fixFlowSeqItems(token);
                  switch (top.type) {
                    case "document":
                      top.value = token;
                      break;
                    case "block-scalar":
                      top.props.push(token);
                      break;
                    case "block-map": {
                      const it = top.items[top.items.length - 1];
                      if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                      } else if (it.sep) {
                        it.value = token;
                      } else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                        return;
                      }
                      break;
                    }
                    case "block-seq": {
                      const it = top.items[top.items.length - 1];
                      if (it.value)
                        top.items.push({ start: [], value: token });
                      else
                        it.value = token;
                      break;
                    }
                    case "flow-collection": {
                      const it = top.items[top.items.length - 1];
                      if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                      else if (it.sep)
                        it.value = token;
                      else
                        Object.assign(it, { key: token, sep: [] });
                      return;
                    }
                    default:
                      yield* this.pop();
                      yield* this.pop(token);
                  }
                  if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
                    const last = token.items[token.items.length - 1];
                    if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
                      if (top.type === "document")
                        top.end = last.start;
                      else
                        top.items.push({ start: last.start });
                      token.items.splice(-1, 1);
                    }
                  }
                }
              }
              *stream() {
                switch (this.type) {
                  case "directive-line":
                    yield { type: "directive", offset: this.offset, source: this.source };
                    return;
                  case "byte-order-mark":
                  case "space":
                  case "comment":
                  case "newline":
                    yield this.sourceToken;
                    return;
                  case "doc-mode":
                  case "doc-start": {
                    const doc = {
                      type: "document",
                      offset: this.offset,
                      start: []
                    };
                    if (this.type === "doc-start")
                      doc.start.push(this.sourceToken);
                    this.stack.push(doc);
                    return;
                  }
                }
                yield {
                  type: "error",
                  offset: this.offset,
                  message: `Unexpected ${this.type} token in YAML stream`,
                  source: this.source
                };
              }
              *document(doc) {
                if (doc.value)
                  return yield* this.lineEnd(doc);
                switch (this.type) {
                  case "doc-start": {
                    if (includesNonEmpty(doc.start)) {
                      yield* this.pop();
                      yield* this.step();
                    } else
                      doc.start.push(this.sourceToken);
                    return;
                  }
                  case "anchor":
                  case "tag":
                  case "space":
                  case "comment":
                  case "newline":
                    doc.start.push(this.sourceToken);
                    return;
                }
                const bv = this.startBlockValue(doc);
                if (bv)
                  this.stack.push(bv);
                else {
                  yield {
                    type: "error",
                    offset: this.offset,
                    message: `Unexpected ${this.type} token in YAML document`,
                    source: this.source
                  };
                }
              }
              *scalar(scalar) {
                if (this.type === "map-value-ind") {
                  const prev = getPrevProps(this.peek(2));
                  const start = getFirstKeyStartProps(prev);
                  let sep;
                  if (scalar.end) {
                    sep = scalar.end;
                    sep.push(this.sourceToken);
                    delete scalar.end;
                  } else
                    sep = [this.sourceToken];
                  const map = {
                    type: "block-map",
                    offset: scalar.offset,
                    indent: scalar.indent,
                    items: [{ start, key: scalar, sep }]
                  };
                  this.onKeyLine = true;
                  this.stack[this.stack.length - 1] = map;
                } else
                  yield* this.lineEnd(scalar);
              }
              *blockScalar(scalar) {
                switch (this.type) {
                  case "space":
                  case "comment":
                  case "newline":
                    scalar.props.push(this.sourceToken);
                    return;
                  case "scalar":
                    scalar.source = this.source;
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine) {
                      let nl = this.source.indexOf("\n") + 1;
                      while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf("\n", nl) + 1;
                      }
                    }
                    yield* this.pop();
                    break;
                  default:
                    yield* this.pop();
                    yield* this.step();
                }
              }
              *blockMap(map) {
                var _a;
                const it = map.items[map.items.length - 1];
                switch (this.type) {
                  case "newline":
                    this.onKeyLine = false;
                    if (it.value) {
                      const end = "end" in it.value ? it.value.end : void 0;
                      const last = Array.isArray(end) ? end[end.length - 1] : void 0;
                      if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                      else
                        map.items.push({ start: [this.sourceToken] });
                    } else if (it.sep)
                      it.sep.push(this.sourceToken);
                    else
                      it.start.push(this.sourceToken);
                    return;
                  case "space":
                  case "comment":
                    if (it.value)
                      map.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                      it.sep.push(this.sourceToken);
                    else {
                      if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                        if (Array.isArray(end)) {
                          Array.prototype.push.apply(end, it.start);
                          end.push(this.sourceToken);
                          map.items.pop();
                          return;
                        }
                      }
                      it.start.push(this.sourceToken);
                    }
                    return;
                }
                if (this.indent >= map.indent) {
                  const atNextItem = !this.onKeyLine && this.indent === map.indent && (it.sep || includesNonEmpty(it.start));
                  switch (this.type) {
                    case "anchor":
                    case "tag":
                      if (atNextItem || it.value) {
                        map.items.push({ start: [this.sourceToken] });
                        this.onKeyLine = true;
                      } else if (it.sep)
                        it.sep.push(this.sourceToken);
                      else
                        it.start.push(this.sourceToken);
                      return;
                    case "explicit-key-ind":
                      if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
                        it.start.push(this.sourceToken);
                      else if (atNextItem || it.value)
                        map.items.push({ start: [this.sourceToken] });
                      else
                        this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [{ start: [this.sourceToken] }]
                        });
                      this.onKeyLine = true;
                      return;
                    case "map-value-ind":
                      if (!it.sep)
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                      else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
                        map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                      else if (includesToken(it.sep, "map-value-ind"))
                        this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [{ start: [], key: null, sep: [this.sourceToken] }]
                        });
                      else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                        const start = getFirstKeyStartProps(it.start);
                        const key = it.key;
                        const sep = it.sep;
                        sep.push(this.sourceToken);
                        delete it.key, delete it.sep;
                        this.stack.push({
                          type: "block-map",
                          offset: this.offset,
                          indent: this.indent,
                          items: [{ start, key, sep }]
                        });
                      } else
                        it.sep.push(this.sourceToken);
                      this.onKeyLine = true;
                      return;
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar": {
                      const fs3 = this.flowScalar(this.type);
                      if (atNextItem || it.value) {
                        map.items.push({ start: [], key: fs3, sep: [] });
                        this.onKeyLine = true;
                      } else if (it.sep) {
                        this.stack.push(fs3);
                      } else {
                        Object.assign(it, { key: fs3, sep: [] });
                        this.onKeyLine = true;
                      }
                      return;
                    }
                    default: {
                      const bv = this.startBlockValue(map);
                      if (bv) {
                        if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
                          map.items.push({ start: [] });
                        this.stack.push(bv);
                        return;
                      }
                    }
                  }
                }
                yield* this.pop();
                yield* this.step();
              }
              *blockSequence(seq) {
                var _a;
                const it = seq.items[seq.items.length - 1];
                switch (this.type) {
                  case "newline":
                    if (it.value) {
                      const end = "end" in it.value ? it.value.end : void 0;
                      const last = Array.isArray(end) ? end[end.length - 1] : void 0;
                      if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                      else
                        seq.items.push({ start: [this.sourceToken] });
                    } else
                      it.start.push(this.sourceToken);
                    return;
                  case "space":
                  case "comment":
                    if (it.value)
                      seq.items.push({ start: [this.sourceToken] });
                    else {
                      if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                        if (Array.isArray(end)) {
                          Array.prototype.push.apply(end, it.start);
                          end.push(this.sourceToken);
                          seq.items.pop();
                          return;
                        }
                      }
                      it.start.push(this.sourceToken);
                    }
                    return;
                  case "anchor":
                  case "tag":
                    if (it.value || this.indent <= seq.indent)
                      break;
                    it.start.push(this.sourceToken);
                    return;
                  case "seq-item-ind":
                    if (this.indent !== seq.indent)
                      break;
                    if (it.value || includesToken(it.start, "seq-item-ind"))
                      seq.items.push({ start: [this.sourceToken] });
                    else
                      it.start.push(this.sourceToken);
                    return;
                }
                if (this.indent > seq.indent) {
                  const bv = this.startBlockValue(seq);
                  if (bv) {
                    this.stack.push(bv);
                    return;
                  }
                }
                yield* this.pop();
                yield* this.step();
              }
              *flowCollection(fc) {
                const it = fc.items[fc.items.length - 1];
                if (this.type === "flow-error-end") {
                  let top;
                  do {
                    yield* this.pop();
                    top = this.peek(1);
                  } while (top && top.type === "flow-collection");
                } else if (fc.end.length === 0) {
                  switch (this.type) {
                    case "comma":
                    case "explicit-key-ind":
                      if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                      else
                        it.start.push(this.sourceToken);
                      return;
                    case "map-value-ind":
                      if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                      else if (it.sep)
                        it.sep.push(this.sourceToken);
                      else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                      return;
                    case "space":
                    case "comment":
                    case "newline":
                    case "anchor":
                    case "tag":
                      if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                      else if (it.sep)
                        it.sep.push(this.sourceToken);
                      else
                        it.start.push(this.sourceToken);
                      return;
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar": {
                      const fs3 = this.flowScalar(this.type);
                      if (!it || it.value)
                        fc.items.push({ start: [], key: fs3, sep: [] });
                      else if (it.sep)
                        this.stack.push(fs3);
                      else
                        Object.assign(it, { key: fs3, sep: [] });
                      return;
                    }
                    case "flow-map-end":
                    case "flow-seq-end":
                      fc.end.push(this.sourceToken);
                      return;
                  }
                  const bv = this.startBlockValue(fc);
                  if (bv)
                    this.stack.push(bv);
                  else {
                    yield* this.pop();
                    yield* this.step();
                  }
                } else {
                  const parent = this.peek(2);
                  if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
                    yield* this.pop();
                    yield* this.step();
                  } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    fixFlowSeqItems(fc);
                    const sep = fc.end.splice(1, fc.end.length);
                    sep.push(this.sourceToken);
                    const map = {
                      type: "block-map",
                      offset: fc.offset,
                      indent: fc.indent,
                      items: [{ start, key: fc, sep }]
                    };
                    this.onKeyLine = true;
                    this.stack[this.stack.length - 1] = map;
                  } else {
                    yield* this.lineEnd(fc);
                  }
                }
              }
              flowScalar(type) {
                if (this.onNewLine) {
                  let nl = this.source.indexOf("\n") + 1;
                  while (nl !== 0) {
                    this.onNewLine(this.offset + nl);
                    nl = this.source.indexOf("\n", nl) + 1;
                  }
                }
                return {
                  type,
                  offset: this.offset,
                  indent: this.indent,
                  source: this.source
                };
              }
              startBlockValue(parent) {
                switch (this.type) {
                  case "alias":
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    return this.flowScalar(this.type);
                  case "block-scalar-header":
                    return {
                      type: "block-scalar",
                      offset: this.offset,
                      indent: this.indent,
                      props: [this.sourceToken],
                      source: ""
                    };
                  case "flow-map-start":
                  case "flow-seq-start":
                    return {
                      type: "flow-collection",
                      offset: this.offset,
                      indent: this.indent,
                      start: this.sourceToken,
                      items: [],
                      end: []
                    };
                  case "seq-item-ind":
                    return {
                      type: "block-seq",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: [this.sourceToken] }]
                    };
                  case "explicit-key-ind": {
                    this.onKeyLine = true;
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    start.push(this.sourceToken);
                    return {
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start }]
                    };
                  }
                  case "map-value-ind": {
                    this.onKeyLine = true;
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    return {
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key: null, sep: [this.sourceToken] }]
                    };
                  }
                }
                return null;
              }
              atIndentedComment(start, indent) {
                if (this.type !== "comment")
                  return false;
                if (this.indent <= indent)
                  return false;
                return start.every((st) => st.type === "newline" || st.type === "space");
              }
              *documentEnd(docEnd) {
                if (this.type !== "doc-mode") {
                  if (docEnd.end)
                    docEnd.end.push(this.sourceToken);
                  else
                    docEnd.end = [this.sourceToken];
                  if (this.type === "newline")
                    yield* this.pop();
                }
              }
              *lineEnd(token) {
                switch (this.type) {
                  case "comma":
                  case "doc-start":
                  case "doc-end":
                  case "flow-seq-end":
                  case "flow-map-end":
                  case "map-value-ind":
                    yield* this.pop();
                    yield* this.step();
                    break;
                  case "newline":
                    this.onKeyLine = false;
                  case "space":
                  case "comment":
                  default:
                    if (token.end)
                      token.end.push(this.sourceToken);
                    else
                      token.end = [this.sourceToken];
                    if (this.type === "newline")
                      yield* this.pop();
                }
              }
            };
            exports22.Parser = Parser;
          }
        });
        var require_public_api22 = __commonJS22({
          "node_modules/yaml/dist/public-api.js"(exports22) {
            "use strict";
            var composer = require_composer22();
            var Document4 = require_Document22();
            var errors = require_errors22();
            var log2 = require_log22();
            var lineCounter = require_line_counter22();
            var parser = require_parser22();
            function parseOptions(options) {
              const prettyErrors = !options || options.prettyErrors !== false;
              const lineCounter$1 = options && options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
              return { lineCounter: lineCounter$1, prettyErrors };
            }
            function parseAllDocuments(source, options = {}) {
              const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
              const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
              const composer$1 = new composer.Composer(options);
              const docs = Array.from(composer$1.compose(parser$1.parse(source)));
              if (prettyErrors && lineCounter2)
                for (const doc of docs) {
                  doc.errors.forEach(errors.prettifyError(source, lineCounter2));
                  doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
                }
              if (docs.length > 0)
                return docs;
              return Object.assign([], { empty: true }, composer$1.streamInfo());
            }
            function parseDocument(source, options = {}) {
              const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
              const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
              const composer$1 = new composer.Composer(options);
              let doc = null;
              for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
                if (!doc)
                  doc = _doc;
                else if (doc.options.logLevel !== "silent") {
                  doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
                  break;
                }
              }
              if (prettyErrors && lineCounter2) {
                doc.errors.forEach(errors.prettifyError(source, lineCounter2));
                doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
              }
              return doc;
            }
            function parse(src, reviver, options) {
              let _reviver = void 0;
              if (typeof reviver === "function") {
                _reviver = reviver;
              } else if (options === void 0 && reviver && typeof reviver === "object") {
                options = reviver;
              }
              const doc = parseDocument(src, options);
              if (!doc)
                return null;
              doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning));
              if (doc.errors.length > 0) {
                if (doc.options.logLevel !== "silent")
                  throw doc.errors[0];
                else
                  doc.errors = [];
              }
              return doc.toJS(Object.assign({ reviver: _reviver }, options));
            }
            function stringify2(value, replacer, options) {
              let _replacer = null;
              if (typeof replacer === "function" || Array.isArray(replacer)) {
                _replacer = replacer;
              } else if (options === void 0 && replacer) {
                options = replacer;
              }
              if (typeof options === "string")
                options = options.length;
              if (typeof options === "number") {
                const indent = Math.round(options);
                options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
              }
              if (value === void 0) {
                const { keepUndefined } = options || replacer || {};
                if (!keepUndefined)
                  return void 0;
              }
              return new Document4.Document(value, _replacer, options).toString(options);
            }
            exports22.parse = parse;
            exports22.parseAllDocuments = parseAllDocuments;
            exports22.parseDocument = parseDocument;
            exports22.stringify = stringify2;
          }
        });
        var require_dist222 = __commonJS22({
          "node_modules/yaml/dist/index.js"(exports22) {
            "use strict";
            var composer = require_composer22();
            var Document4 = require_Document22();
            var Schema = require_Schema22();
            var errors = require_errors22();
            var Alias = require_Alias22();
            var Node = require_Node22();
            var Pair = require_Pair22();
            var Scalar2 = require_Scalar22();
            var YAMLMap = require_YAMLMap22();
            var YAMLSeq = require_YAMLSeq22();
            var options = require_options22();
            var cst = require_cst22();
            var lexer = require_lexer22();
            var lineCounter = require_line_counter22();
            var parser = require_parser22();
            var publicApi = require_public_api22();
            var visit = require_visit22();
            exports22.Composer = composer.Composer;
            exports22.Document = Document4.Document;
            exports22.Schema = Schema.Schema;
            exports22.YAMLError = errors.YAMLError;
            exports22.YAMLParseError = errors.YAMLParseError;
            exports22.YAMLWarning = errors.YAMLWarning;
            exports22.Alias = Alias.Alias;
            exports22.isAlias = Node.isAlias;
            exports22.isCollection = Node.isCollection;
            exports22.isDocument = Node.isDocument;
            exports22.isMap = Node.isMap;
            exports22.isNode = Node.isNode;
            exports22.isPair = Node.isPair;
            exports22.isScalar = Node.isScalar;
            exports22.isSeq = Node.isSeq;
            exports22.Pair = Pair.Pair;
            exports22.Scalar = Scalar2.Scalar;
            exports22.YAMLMap = YAMLMap.YAMLMap;
            exports22.YAMLSeq = YAMLSeq.YAMLSeq;
            exports22.defaultOptions = options.defaultOptions;
            exports22.CST = cst;
            exports22.Lexer = lexer.Lexer;
            exports22.LineCounter = lineCounter.LineCounter;
            exports22.Parser = parser.Parser;
            exports22.parse = publicApi.parse;
            exports22.parseAllDocuments = publicApi.parseAllDocuments;
            exports22.parseDocument = publicApi.parseDocument;
            exports22.stringify = publicApi.stringify;
            exports22.visit = visit.visit;
          }
        });
        var require_array_union = __commonJS22({
          "node_modules/array-union/index.js"(exports22, module22) {
            "use strict";
            module22.exports = (...arguments_) => {
              return [...new Set([].concat(...arguments_))];
            };
          }
        });
        var require_merge2 = __commonJS22({
          "node_modules/merge2/index.js"(exports22, module22) {
            "use strict";
            var Stream = require("stream");
            var PassThrough = Stream.PassThrough;
            var slice = Array.prototype.slice;
            module22.exports = merge2;
            function merge2() {
              const streamsQueue = [];
              const args = slice.call(arguments);
              let merging = false;
              let options = args[args.length - 1];
              if (options && !Array.isArray(options) && options.pipe == null) {
                args.pop();
              } else {
                options = {};
              }
              const doEnd = options.end !== false;
              const doPipeError = options.pipeError === true;
              if (options.objectMode == null) {
                options.objectMode = true;
              }
              if (options.highWaterMark == null) {
                options.highWaterMark = 64 * 1024;
              }
              const mergedStream = PassThrough(options);
              function addStream() {
                for (let i = 0, len = arguments.length; i < len; i++) {
                  streamsQueue.push(pauseStreams(arguments[i], options));
                }
                mergeStream();
                return this;
              }
              function mergeStream() {
                if (merging) {
                  return;
                }
                merging = true;
                let streams = streamsQueue.shift();
                if (!streams) {
                  process.nextTick(endStream);
                  return;
                }
                if (!Array.isArray(streams)) {
                  streams = [streams];
                }
                let pipesCount = streams.length + 1;
                function next() {
                  if (--pipesCount > 0) {
                    return;
                  }
                  merging = false;
                  mergeStream();
                }
                function pipe(stream) {
                  function onend() {
                    stream.removeListener("merge2UnpipeEnd", onend);
                    stream.removeListener("end", onend);
                    if (doPipeError) {
                      stream.removeListener("error", onerror);
                    }
                    next();
                  }
                  function onerror(err) {
                    mergedStream.emit("error", err);
                  }
                  if (stream._readableState.endEmitted) {
                    return next();
                  }
                  stream.on("merge2UnpipeEnd", onend);
                  stream.on("end", onend);
                  if (doPipeError) {
                    stream.on("error", onerror);
                  }
                  stream.pipe(mergedStream, { end: false });
                  stream.resume();
                }
                for (let i = 0; i < streams.length; i++) {
                  pipe(streams[i]);
                }
                next();
              }
              function endStream() {
                merging = false;
                mergedStream.emit("queueDrain");
                if (doEnd) {
                  mergedStream.end();
                }
              }
              mergedStream.setMaxListeners(0);
              mergedStream.add = addStream;
              mergedStream.on("unpipe", function(stream) {
                stream.emit("merge2UnpipeEnd");
              });
              if (args.length) {
                addStream.apply(null, args);
              }
              return mergedStream;
            }
            function pauseStreams(streams, options) {
              if (!Array.isArray(streams)) {
                if (!streams._readableState && streams.pipe) {
                  streams = streams.pipe(PassThrough(options));
                }
                if (!streams._readableState || !streams.pause || !streams.pipe) {
                  throw new Error("Only readable stream can be merged.");
                }
                streams.pause();
              } else {
                for (let i = 0, len = streams.length; i < len; i++) {
                  streams[i] = pauseStreams(streams[i], options);
                }
              }
              return streams;
            }
          }
        });
        var require_old = __commonJS22({
          "node_modules/fs.realpath/old.js"(exports22) {
            var pathModule = require("path");
            var isWindows = process.platform === "win32";
            var fs3 = require("fs");
            var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
            function rethrow() {
              var callback;
              if (DEBUG) {
                var backtrace = new Error();
                callback = debugCallback;
              } else
                callback = missingCallback;
              return callback;
              function debugCallback(err) {
                if (err) {
                  backtrace.message = err.message;
                  err = backtrace;
                  missingCallback(err);
                }
              }
              function missingCallback(err) {
                if (err) {
                  if (process.throwDeprecation)
                    throw err;
                  else if (!process.noDeprecation) {
                    var msg = "fs: missing callback " + (err.stack || err.message);
                    if (process.traceDeprecation)
                      console.trace(msg);
                    else
                      console.error(msg);
                  }
                }
              }
            }
            function maybeCallback(cb) {
              return typeof cb === "function" ? cb : rethrow();
            }
            var normalize = pathModule.normalize;
            if (isWindows) {
              nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
            } else {
              nextPartRe = /(.*?)(?:[\/]+|$)/g;
            }
            var nextPartRe;
            if (isWindows) {
              splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
            } else {
              splitRootRe = /^[\/]*/;
            }
            var splitRootRe;
            exports22.realpathSync = function realpathSync(p, cache) {
              p = pathModule.resolve(p);
              if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
                return cache[p];
              }
              var original = p, seenLinks = {}, knownHard = {};
              var pos;
              var current;
              var base;
              var previous;
              start();
              function start() {
                var m = splitRootRe.exec(p);
                pos = m[0].length;
                current = m[0];
                base = m[0];
                previous = "";
                if (isWindows && !knownHard[base]) {
                  fs3.lstatSync(base);
                  knownHard[base] = true;
                }
              }
              while (pos < p.length) {
                nextPartRe.lastIndex = pos;
                var result = nextPartRe.exec(p);
                previous = current;
                current += result[0];
                base = previous + result[1];
                pos = nextPartRe.lastIndex;
                if (knownHard[base] || cache && cache[base] === base) {
                  continue;
                }
                var resolvedLink;
                if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                  resolvedLink = cache[base];
                } else {
                  var stat = fs3.lstatSync(base);
                  if (!stat.isSymbolicLink()) {
                    knownHard[base] = true;
                    if (cache)
                      cache[base] = base;
                    continue;
                  }
                  var linkTarget = null;
                  if (!isWindows) {
                    var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
                    if (seenLinks.hasOwnProperty(id)) {
                      linkTarget = seenLinks[id];
                    }
                  }
                  if (linkTarget === null) {
                    fs3.statSync(base);
                    linkTarget = fs3.readlinkSync(base);
                  }
                  resolvedLink = pathModule.resolve(previous, linkTarget);
                  if (cache)
                    cache[base] = resolvedLink;
                  if (!isWindows)
                    seenLinks[id] = linkTarget;
                }
                p = pathModule.resolve(resolvedLink, p.slice(pos));
                start();
              }
              if (cache)
                cache[original] = p;
              return p;
            };
            exports22.realpath = function realpath(p, cache, cb) {
              if (typeof cb !== "function") {
                cb = maybeCallback(cache);
                cache = null;
              }
              p = pathModule.resolve(p);
              if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
                return process.nextTick(cb.bind(null, null, cache[p]));
              }
              var original = p, seenLinks = {}, knownHard = {};
              var pos;
              var current;
              var base;
              var previous;
              start();
              function start() {
                var m = splitRootRe.exec(p);
                pos = m[0].length;
                current = m[0];
                base = m[0];
                previous = "";
                if (isWindows && !knownHard[base]) {
                  fs3.lstat(base, function(err) {
                    if (err)
                      return cb(err);
                    knownHard[base] = true;
                    LOOP();
                  });
                } else {
                  process.nextTick(LOOP);
                }
              }
              function LOOP() {
                if (pos >= p.length) {
                  if (cache)
                    cache[original] = p;
                  return cb(null, p);
                }
                nextPartRe.lastIndex = pos;
                var result = nextPartRe.exec(p);
                previous = current;
                current += result[0];
                base = previous + result[1];
                pos = nextPartRe.lastIndex;
                if (knownHard[base] || cache && cache[base] === base) {
                  return process.nextTick(LOOP);
                }
                if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                  return gotResolvedLink(cache[base]);
                }
                return fs3.lstat(base, gotStat);
              }
              function gotStat(err, stat) {
                if (err)
                  return cb(err);
                if (!stat.isSymbolicLink()) {
                  knownHard[base] = true;
                  if (cache)
                    cache[base] = base;
                  return process.nextTick(LOOP);
                }
                if (!isWindows) {
                  var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
                  if (seenLinks.hasOwnProperty(id)) {
                    return gotTarget(null, seenLinks[id], base);
                  }
                }
                fs3.stat(base, function(err2) {
                  if (err2)
                    return cb(err2);
                  fs3.readlink(base, function(err3, target) {
                    if (!isWindows)
                      seenLinks[id] = target;
                    gotTarget(err3, target);
                  });
                });
              }
              function gotTarget(err, target, base2) {
                if (err)
                  return cb(err);
                var resolvedLink = pathModule.resolve(previous, target);
                if (cache)
                  cache[base2] = resolvedLink;
                gotResolvedLink(resolvedLink);
              }
              function gotResolvedLink(resolvedLink) {
                p = pathModule.resolve(resolvedLink, p.slice(pos));
                start();
              }
            };
          }
        });
        var require_fs2 = __commonJS22({
          "node_modules/fs.realpath/index.js"(exports22, module22) {
            module22.exports = realpath;
            realpath.realpath = realpath;
            realpath.sync = realpathSync;
            realpath.realpathSync = realpathSync;
            realpath.monkeypatch = monkeypatch;
            realpath.unmonkeypatch = unmonkeypatch;
            var fs3 = require("fs");
            var origRealpath = fs3.realpath;
            var origRealpathSync = fs3.realpathSync;
            var version = process.version;
            var ok = /^v[0-5]\./.test(version);
            var old = require_old();
            function newError(er) {
              return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
            }
            function realpath(p, cache, cb) {
              if (ok) {
                return origRealpath(p, cache, cb);
              }
              if (typeof cache === "function") {
                cb = cache;
                cache = null;
              }
              origRealpath(p, cache, function(er, result) {
                if (newError(er)) {
                  old.realpath(p, cache, cb);
                } else {
                  cb(er, result);
                }
              });
            }
            function realpathSync(p, cache) {
              if (ok) {
                return origRealpathSync(p, cache);
              }
              try {
                return origRealpathSync(p, cache);
              } catch (er) {
                if (newError(er)) {
                  return old.realpathSync(p, cache);
                } else {
                  throw er;
                }
              }
            }
            function monkeypatch() {
              fs3.realpath = realpath;
              fs3.realpathSync = realpathSync;
            }
            function unmonkeypatch() {
              fs3.realpath = origRealpath;
              fs3.realpathSync = origRealpathSync;
            }
          }
        });
        var require_concat_map = __commonJS22({
          "node_modules/concat-map/index.js"(exports22, module22) {
            module22.exports = function(xs, fn) {
              var res = [];
              for (var i = 0; i < xs.length; i++) {
                var x = fn(xs[i], i);
                if (isArray(x))
                  res.push.apply(res, x);
                else
                  res.push(x);
              }
              return res;
            };
            var isArray = Array.isArray || function(xs) {
              return Object.prototype.toString.call(xs) === "[object Array]";
            };
          }
        });
        var require_balanced_match = __commonJS22({
          "node_modules/balanced-match/index.js"(exports22, module22) {
            "use strict";
            module22.exports = balanced;
            function balanced(a, b, str) {
              if (a instanceof RegExp)
                a = maybeMatch(a, str);
              if (b instanceof RegExp)
                b = maybeMatch(b, str);
              var r = range(a, b, str);
              return r && {
                start: r[0],
                end: r[1],
                pre: str.slice(0, r[0]),
                body: str.slice(r[0] + a.length, r[1]),
                post: str.slice(r[1] + b.length)
              };
            }
            function maybeMatch(reg, str) {
              var m = str.match(reg);
              return m ? m[0] : null;
            }
            balanced.range = range;
            function range(a, b, str) {
              var begs, beg, left, right, result;
              var ai = str.indexOf(a);
              var bi = str.indexOf(b, ai + 1);
              var i = ai;
              if (ai >= 0 && bi > 0) {
                if (a === b) {
                  return [ai, bi];
                }
                begs = [];
                left = str.length;
                while (i >= 0 && !result) {
                  if (i == ai) {
                    begs.push(i);
                    ai = str.indexOf(a, i + 1);
                  } else if (begs.length == 1) {
                    result = [begs.pop(), bi];
                  } else {
                    beg = begs.pop();
                    if (beg < left) {
                      left = beg;
                      right = bi;
                    }
                    bi = str.indexOf(b, i + 1);
                  }
                  i = ai < bi && ai >= 0 ? ai : bi;
                }
                if (begs.length) {
                  result = [left, right];
                }
              }
              return result;
            }
          }
        });
        var require_brace_expansion = __commonJS22({
          "node_modules/brace-expansion/index.js"(exports22, module22) {
            var concatMap = require_concat_map();
            var balanced = require_balanced_match();
            module22.exports = expandTop;
            var escSlash = "\0SLASH" + Math.random() + "\0";
            var escOpen = "\0OPEN" + Math.random() + "\0";
            var escClose = "\0CLOSE" + Math.random() + "\0";
            var escComma = "\0COMMA" + Math.random() + "\0";
            var escPeriod = "\0PERIOD" + Math.random() + "\0";
            function numeric(str) {
              return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
            }
            function escapeBraces(str) {
              return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
            }
            function unescapeBraces(str) {
              return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
            }
            function parseCommaParts(str) {
              if (!str)
                return [""];
              var parts = [];
              var m = balanced("{", "}", str);
              if (!m)
                return str.split(",");
              var pre = m.pre;
              var body = m.body;
              var post = m.post;
              var p = pre.split(",");
              p[p.length - 1] += "{" + body + "}";
              var postParts = parseCommaParts(post);
              if (post.length) {
                p[p.length - 1] += postParts.shift();
                p.push.apply(p, postParts);
              }
              parts.push.apply(parts, p);
              return parts;
            }
            function expandTop(str) {
              if (!str)
                return [];
              if (str.substr(0, 2) === "{}") {
                str = "\\{\\}" + str.substr(2);
              }
              return expand(escapeBraces(str), true).map(unescapeBraces);
            }
            function embrace(str) {
              return "{" + str + "}";
            }
            function isPadded(el) {
              return /^-?0\d/.test(el);
            }
            function lte(i, y) {
              return i <= y;
            }
            function gte(i, y) {
              return i >= y;
            }
            function expand(str, isTop) {
              var expansions = [];
              var m = balanced("{", "}", str);
              if (!m || /\$$/.test(m.pre))
                return [str];
              var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
              var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
              var isSequence = isNumericSequence || isAlphaSequence;
              var isOptions = m.body.indexOf(",") >= 0;
              if (!isSequence && !isOptions) {
                if (m.post.match(/,.*\}/)) {
                  str = m.pre + "{" + m.body + escClose + m.post;
                  return expand(str);
                }
                return [str];
              }
              var n;
              if (isSequence) {
                n = m.body.split(/\.\./);
              } else {
                n = parseCommaParts(m.body);
                if (n.length === 1) {
                  n = expand(n[0], false).map(embrace);
                  if (n.length === 1) {
                    var post = m.post.length ? expand(m.post, false) : [""];
                    return post.map(function(p) {
                      return m.pre + n[0] + p;
                    });
                  }
                }
              }
              var pre = m.pre;
              var post = m.post.length ? expand(m.post, false) : [""];
              var N;
              if (isSequence) {
                var x = numeric(n[0]);
                var y = numeric(n[1]);
                var width = Math.max(n[0].length, n[1].length);
                var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
                var test = lte;
                var reverse = y < x;
                if (reverse) {
                  incr *= -1;
                  test = gte;
                }
                var pad = n.some(isPadded);
                N = [];
                for (var i = x; test(i, y); i += incr) {
                  var c2;
                  if (isAlphaSequence) {
                    c2 = String.fromCharCode(i);
                    if (c2 === "\\")
                      c2 = "";
                  } else {
                    c2 = String(i);
                    if (pad) {
                      var need = width - c2.length;
                      if (need > 0) {
                        var z = new Array(need + 1).join("0");
                        if (i < 0)
                          c2 = "-" + z + c2.slice(1);
                        else
                          c2 = z + c2;
                      }
                    }
                  }
                  N.push(c2);
                }
              } else {
                N = concatMap(n, function(el) {
                  return expand(el, false);
                });
              }
              for (var j = 0; j < N.length; j++) {
                for (var k = 0; k < post.length; k++) {
                  var expansion = pre + N[j] + post[k];
                  if (!isTop || isSequence || expansion)
                    expansions.push(expansion);
                }
              }
              return expansions;
            }
          }
        });
        var require_minimatch = __commonJS22({
          "node_modules/minimatch/minimatch.js"(exports22, module22) {
            module22.exports = minimatch2;
            minimatch2.Minimatch = Minimatch;
            var path7 = { sep: "/" };
            try {
              path7 = require("path");
            } catch (er) {
            }
            var GLOBSTAR = minimatch2.GLOBSTAR = Minimatch.GLOBSTAR = {};
            var expand = require_brace_expansion();
            var plTypes = {
              "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
              "?": { open: "(?:", close: ")?" },
              "+": { open: "(?:", close: ")+" },
              "*": { open: "(?:", close: ")*" },
              "@": { open: "(?:", close: ")" }
            };
            var qmark = "[^/]";
            var star = qmark + "*?";
            var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
            var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
            var reSpecials = charSet("().*{}+?[]^$\\!");
            function charSet(s) {
              return s.split("").reduce(function(set, c2) {
                set[c2] = true;
                return set;
              }, {});
            }
            var slashSplit = /\/+/;
            minimatch2.filter = filter;
            function filter(pattern, options) {
              options = options || {};
              return function(p, i, list) {
                return minimatch2(p, pattern, options);
              };
            }
            function ext(a, b) {
              a = a || {};
              b = b || {};
              var t = {};
              Object.keys(b).forEach(function(k) {
                t[k] = b[k];
              });
              Object.keys(a).forEach(function(k) {
                t[k] = a[k];
              });
              return t;
            }
            minimatch2.defaults = function(def) {
              if (!def || !Object.keys(def).length)
                return minimatch2;
              var orig = minimatch2;
              var m = function minimatch3(p, pattern, options) {
                return orig.minimatch(p, pattern, ext(def, options));
              };
              m.Minimatch = function Minimatch2(pattern, options) {
                return new orig.Minimatch(pattern, ext(def, options));
              };
              return m;
            };
            Minimatch.defaults = function(def) {
              if (!def || !Object.keys(def).length)
                return Minimatch;
              return minimatch2.defaults(def).Minimatch;
            };
            function minimatch2(p, pattern, options) {
              if (typeof pattern !== "string") {
                throw new TypeError("glob pattern string required");
              }
              if (!options)
                options = {};
              if (!options.nocomment && pattern.charAt(0) === "#") {
                return false;
              }
              if (pattern.trim() === "")
                return p === "";
              return new Minimatch(pattern, options).match(p);
            }
            function Minimatch(pattern, options) {
              if (!(this instanceof Minimatch)) {
                return new Minimatch(pattern, options);
              }
              if (typeof pattern !== "string") {
                throw new TypeError("glob pattern string required");
              }
              if (!options)
                options = {};
              pattern = pattern.trim();
              if (path7.sep !== "/") {
                pattern = pattern.split(path7.sep).join("/");
              }
              this.options = options;
              this.set = [];
              this.pattern = pattern;
              this.regexp = null;
              this.negate = false;
              this.comment = false;
              this.empty = false;
              this.make();
            }
            Minimatch.prototype.debug = function() {
            };
            Minimatch.prototype.make = make;
            function make() {
              if (this._made)
                return;
              var pattern = this.pattern;
              var options = this.options;
              if (!options.nocomment && pattern.charAt(0) === "#") {
                this.comment = true;
                return;
              }
              if (!pattern) {
                this.empty = true;
                return;
              }
              this.parseNegate();
              var set = this.globSet = this.braceExpand();
              if (options.debug)
                this.debug = console.error;
              this.debug(this.pattern, set);
              set = this.globParts = set.map(function(s) {
                return s.split(slashSplit);
              });
              this.debug(this.pattern, set);
              set = set.map(function(s, si, set2) {
                return s.map(this.parse, this);
              }, this);
              this.debug(this.pattern, set);
              set = set.filter(function(s) {
                return s.indexOf(false) === -1;
              });
              this.debug(this.pattern, set);
              this.set = set;
            }
            Minimatch.prototype.parseNegate = parseNegate;
            function parseNegate() {
              var pattern = this.pattern;
              var negate = false;
              var options = this.options;
              var negateOffset = 0;
              if (options.nonegate)
                return;
              for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
                negate = !negate;
                negateOffset++;
              }
              if (negateOffset)
                this.pattern = pattern.substr(negateOffset);
              this.negate = negate;
            }
            minimatch2.braceExpand = function(pattern, options) {
              return braceExpand(pattern, options);
            };
            Minimatch.prototype.braceExpand = braceExpand;
            function braceExpand(pattern, options) {
              if (!options) {
                if (this instanceof Minimatch) {
                  options = this.options;
                } else {
                  options = {};
                }
              }
              pattern = typeof pattern === "undefined" ? this.pattern : pattern;
              if (typeof pattern === "undefined") {
                throw new TypeError("undefined pattern");
              }
              if (options.nobrace || !pattern.match(/\{.*\}/)) {
                return [pattern];
              }
              return expand(pattern);
            }
            Minimatch.prototype.parse = parse;
            var SUBPARSE = {};
            function parse(pattern, isSub) {
              if (pattern.length > 1024 * 64) {
                throw new TypeError("pattern is too long");
              }
              var options = this.options;
              if (!options.noglobstar && pattern === "**")
                return GLOBSTAR;
              if (pattern === "")
                return "";
              var re = "";
              var hasMagic = !!options.nocase;
              var escaping = false;
              var patternListStack = [];
              var negativeLists = [];
              var stateChar;
              var inClass = false;
              var reClassStart = -1;
              var classStart = -1;
              var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
              var self2 = this;
              function clearStateChar() {
                if (stateChar) {
                  switch (stateChar) {
                    case "*":
                      re += star;
                      hasMagic = true;
                      break;
                    case "?":
                      re += qmark;
                      hasMagic = true;
                      break;
                    default:
                      re += "\\" + stateChar;
                      break;
                  }
                  self2.debug("clearStateChar %j %j", stateChar, re);
                  stateChar = false;
                }
              }
              for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {
                this.debug("%s	%s %s %j", pattern, i, re, c2);
                if (escaping && reSpecials[c2]) {
                  re += "\\" + c2;
                  escaping = false;
                  continue;
                }
                switch (c2) {
                  case "/":
                    return false;
                  case "\\":
                    clearStateChar();
                    escaping = true;
                    continue;
                  case "?":
                  case "*":
                  case "+":
                  case "@":
                  case "!":
                    this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2);
                    if (inClass) {
                      this.debug("  in class");
                      if (c2 === "!" && i === classStart + 1)
                        c2 = "^";
                      re += c2;
                      continue;
                    }
                    self2.debug("call clearStateChar %j", stateChar);
                    clearStateChar();
                    stateChar = c2;
                    if (options.noext)
                      clearStateChar();
                    continue;
                  case "(":
                    if (inClass) {
                      re += "(";
                      continue;
                    }
                    if (!stateChar) {
                      re += "\\(";
                      continue;
                    }
                    patternListStack.push({
                      type: stateChar,
                      start: i - 1,
                      reStart: re.length,
                      open: plTypes[stateChar].open,
                      close: plTypes[stateChar].close
                    });
                    re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
                    this.debug("plType %j %j", stateChar, re);
                    stateChar = false;
                    continue;
                  case ")":
                    if (inClass || !patternListStack.length) {
                      re += "\\)";
                      continue;
                    }
                    clearStateChar();
                    hasMagic = true;
                    var pl = patternListStack.pop();
                    re += pl.close;
                    if (pl.type === "!") {
                      negativeLists.push(pl);
                    }
                    pl.reEnd = re.length;
                    continue;
                  case "|":
                    if (inClass || !patternListStack.length || escaping) {
                      re += "\\|";
                      escaping = false;
                      continue;
                    }
                    clearStateChar();
                    re += "|";
                    continue;
                  case "[":
                    clearStateChar();
                    if (inClass) {
                      re += "\\" + c2;
                      continue;
                    }
                    inClass = true;
                    classStart = i;
                    reClassStart = re.length;
                    re += c2;
                    continue;
                  case "]":
                    if (i === classStart + 1 || !inClass) {
                      re += "\\" + c2;
                      escaping = false;
                      continue;
                    }
                    if (inClass) {
                      var cs = pattern.substring(classStart + 1, i);
                      try {
                        RegExp("[" + cs + "]");
                      } catch (er) {
                        var sp = this.parse(cs, SUBPARSE);
                        re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                        hasMagic = hasMagic || sp[1];
                        inClass = false;
                        continue;
                      }
                    }
                    hasMagic = true;
                    inClass = false;
                    re += c2;
                    continue;
                  default:
                    clearStateChar();
                    if (escaping) {
                      escaping = false;
                    } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
                      re += "\\";
                    }
                    re += c2;
                }
              }
              if (inClass) {
                cs = pattern.substr(classStart + 1);
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0];
                hasMagic = hasMagic || sp[1];
              }
              for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
                var tail = re.slice(pl.reStart + pl.open.length);
                this.debug("setting tail", re, pl);
                tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
                  if (!$2) {
                    $2 = "\\";
                  }
                  return $1 + $1 + $2 + "|";
                });
                this.debug("tail=%j\n   %s", tail, tail, pl, re);
                var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
                hasMagic = true;
                re = re.slice(0, pl.reStart) + t + "\\(" + tail;
              }
              clearStateChar();
              if (escaping) {
                re += "\\\\";
              }
              var addPatternStart = false;
              switch (re.charAt(0)) {
                case ".":
                case "[":
                case "(":
                  addPatternStart = true;
              }
              for (var n = negativeLists.length - 1; n > -1; n--) {
                var nl = negativeLists[n];
                var nlBefore = re.slice(0, nl.reStart);
                var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
                var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
                var nlAfter = re.slice(nl.reEnd);
                nlLast += nlAfter;
                var openParensBefore = nlBefore.split("(").length - 1;
                var cleanAfter = nlAfter;
                for (i = 0; i < openParensBefore; i++) {
                  cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
                }
                nlAfter = cleanAfter;
                var dollar = "";
                if (nlAfter === "" && isSub !== SUBPARSE) {
                  dollar = "$";
                }
                var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
                re = newRe;
              }
              if (re !== "" && hasMagic) {
                re = "(?=.)" + re;
              }
              if (addPatternStart) {
                re = patternStart + re;
              }
              if (isSub === SUBPARSE) {
                return [re, hasMagic];
              }
              if (!hasMagic) {
                return globUnescape(pattern);
              }
              var flags = options.nocase ? "i" : "";
              try {
                var regExp = new RegExp("^" + re + "$", flags);
              } catch (er) {
                return new RegExp("$.");
              }
              regExp._glob = pattern;
              regExp._src = re;
              return regExp;
            }
            minimatch2.makeRe = function(pattern, options) {
              return new Minimatch(pattern, options || {}).makeRe();
            };
            Minimatch.prototype.makeRe = makeRe;
            function makeRe() {
              if (this.regexp || this.regexp === false)
                return this.regexp;
              var set = this.set;
              if (!set.length) {
                this.regexp = false;
                return this.regexp;
              }
              var options = this.options;
              var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
              var flags = options.nocase ? "i" : "";
              var re = set.map(function(pattern) {
                return pattern.map(function(p) {
                  return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
                }).join("\\/");
              }).join("|");
              re = "^(?:" + re + ")$";
              if (this.negate)
                re = "^(?!" + re + ").*$";
              try {
                this.regexp = new RegExp(re, flags);
              } catch (ex) {
                this.regexp = false;
              }
              return this.regexp;
            }
            minimatch2.match = function(list, pattern, options) {
              options = options || {};
              var mm = new Minimatch(pattern, options);
              list = list.filter(function(f) {
                return mm.match(f);
              });
              if (mm.options.nonull && !list.length) {
                list.push(pattern);
              }
              return list;
            };
            Minimatch.prototype.match = match;
            function match(f, partial) {
              this.debug("match", f, this.pattern);
              if (this.comment)
                return false;
              if (this.empty)
                return f === "";
              if (f === "/" && partial)
                return true;
              var options = this.options;
              if (path7.sep !== "/") {
                f = f.split(path7.sep).join("/");
              }
              f = f.split(slashSplit);
              this.debug(this.pattern, "split", f);
              var set = this.set;
              this.debug(this.pattern, "set", set);
              var filename;
              var i;
              for (i = f.length - 1; i >= 0; i--) {
                filename = f[i];
                if (filename)
                  break;
              }
              for (i = 0; i < set.length; i++) {
                var pattern = set[i];
                var file = f;
                if (options.matchBase && pattern.length === 1) {
                  file = [filename];
                }
                var hit = this.matchOne(file, pattern, partial);
                if (hit) {
                  if (options.flipNegate)
                    return true;
                  return !this.negate;
                }
              }
              if (options.flipNegate)
                return false;
              return this.negate;
            }
            Minimatch.prototype.matchOne = function(file, pattern, partial) {
              var options = this.options;
              this.debug("matchOne", { "this": this, file, pattern });
              this.debug("matchOne", file.length, pattern.length);
              for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
                this.debug("matchOne loop");
                var p = pattern[pi];
                var f = file[fi];
                this.debug(pattern, p, f);
                if (p === false)
                  return false;
                if (p === GLOBSTAR) {
                  this.debug("GLOBSTAR", [pattern, p, f]);
                  var fr = fi;
                  var pr = pi + 1;
                  if (pr === pl) {
                    this.debug("** at the end");
                    for (; fi < fl; fi++) {
                      if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                        return false;
                    }
                    return true;
                  }
                  while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                      this.debug("globstar found match!", fr, fl, swallowee);
                      return true;
                    } else {
                      if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                        this.debug("dot detected!", file, fr, pattern, pr);
                        break;
                      }
                      this.debug("globstar swallow a segment, and continue");
                      fr++;
                    }
                  }
                  if (partial) {
                    this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                    if (fr === fl)
                      return true;
                  }
                  return false;
                }
                var hit;
                if (typeof p === "string") {
                  if (options.nocase) {
                    hit = f.toLowerCase() === p.toLowerCase();
                  } else {
                    hit = f === p;
                  }
                  this.debug("string match", p, f, hit);
                } else {
                  hit = f.match(p);
                  this.debug("pattern match", p, f, hit);
                }
                if (!hit)
                  return false;
              }
              if (fi === fl && pi === pl) {
                return true;
              } else if (fi === fl) {
                return partial;
              } else if (pi === pl) {
                var emptyFileEnd = fi === fl - 1 && file[fi] === "";
                return emptyFileEnd;
              }
              throw new Error("wtf?");
            };
            function globUnescape(s) {
              return s.replace(/\\(.)/g, "$1");
            }
            function regExpEscape(s) {
              return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            }
          }
        });
        var require_inherits_browser = __commonJS22({
          "node_modules/inherits/inherits_browser.js"(exports22, module22) {
            if (typeof Object.create === "function") {
              module22.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                }
              };
            } else {
              module22.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  var TempCtor = function() {
                  };
                  TempCtor.prototype = superCtor.prototype;
                  ctor.prototype = new TempCtor();
                  ctor.prototype.constructor = ctor;
                }
              };
            }
          }
        });
        var require_inherits = __commonJS22({
          "node_modules/inherits/inherits.js"(exports22, module22) {
            try {
              util = require("util");
              if (typeof util.inherits !== "function")
                throw "";
              module22.exports = util.inherits;
            } catch (e) {
              module22.exports = require_inherits_browser();
            }
            var util;
          }
        });
        var require_path_is_absolute = __commonJS22({
          "node_modules/path-is-absolute/index.js"(exports22, module22) {
            "use strict";
            function posix(path7) {
              return path7.charAt(0) === "/";
            }
            function win32(path7) {
              var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
              var result = splitDeviceRe.exec(path7);
              var device = result[1] || "";
              var isUnc = Boolean(device && device.charAt(1) !== ":");
              return Boolean(result[2] || isUnc);
            }
            module22.exports = process.platform === "win32" ? win32 : posix;
            module22.exports.posix = posix;
            module22.exports.win32 = win32;
          }
        });
        var require_common2 = __commonJS22({
          "node_modules/glob/common.js"(exports22) {
            exports22.setopts = setopts;
            exports22.ownProp = ownProp;
            exports22.makeAbs = makeAbs;
            exports22.finish = finish;
            exports22.mark = mark;
            exports22.isIgnored = isIgnored;
            exports22.childrenIgnored = childrenIgnored;
            function ownProp(obj, field) {
              return Object.prototype.hasOwnProperty.call(obj, field);
            }
            var path7 = require("path");
            var minimatch2 = require_minimatch();
            var isAbsolute2 = require_path_is_absolute();
            var Minimatch = minimatch2.Minimatch;
            function alphasort(a, b) {
              return a.localeCompare(b, "en");
            }
            function setupIgnores(self2, options) {
              self2.ignore = options.ignore || [];
              if (!Array.isArray(self2.ignore))
                self2.ignore = [self2.ignore];
              if (self2.ignore.length) {
                self2.ignore = self2.ignore.map(ignoreMap);
              }
            }
            function ignoreMap(pattern) {
              var gmatcher = null;
              if (pattern.slice(-3) === "/**") {
                var gpattern = pattern.replace(/(\/\*\*)+$/, "");
                gmatcher = new Minimatch(gpattern, { dot: true });
              }
              return {
                matcher: new Minimatch(pattern, { dot: true }),
                gmatcher
              };
            }
            function setopts(self2, pattern, options) {
              if (!options)
                options = {};
              if (options.matchBase && pattern.indexOf("/") === -1) {
                if (options.noglobstar) {
                  throw new Error("base matching requires globstar");
                }
                pattern = "**/" + pattern;
              }
              self2.silent = !!options.silent;
              self2.pattern = pattern;
              self2.strict = options.strict !== false;
              self2.realpath = !!options.realpath;
              self2.realpathCache = options.realpathCache || Object.create(null);
              self2.follow = !!options.follow;
              self2.dot = !!options.dot;
              self2.mark = !!options.mark;
              self2.nodir = !!options.nodir;
              if (self2.nodir)
                self2.mark = true;
              self2.sync = !!options.sync;
              self2.nounique = !!options.nounique;
              self2.nonull = !!options.nonull;
              self2.nosort = !!options.nosort;
              self2.nocase = !!options.nocase;
              self2.stat = !!options.stat;
              self2.noprocess = !!options.noprocess;
              self2.absolute = !!options.absolute;
              self2.maxLength = options.maxLength || Infinity;
              self2.cache = options.cache || Object.create(null);
              self2.statCache = options.statCache || Object.create(null);
              self2.symlinks = options.symlinks || Object.create(null);
              setupIgnores(self2, options);
              self2.changedCwd = false;
              var cwd = process.cwd();
              if (!ownProp(options, "cwd"))
                self2.cwd = cwd;
              else {
                self2.cwd = path7.resolve(options.cwd);
                self2.changedCwd = self2.cwd !== cwd;
              }
              self2.root = options.root || path7.resolve(self2.cwd, "/");
              self2.root = path7.resolve(self2.root);
              if (process.platform === "win32")
                self2.root = self2.root.replace(/\\/g, "/");
              self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
              if (process.platform === "win32")
                self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
              self2.nomount = !!options.nomount;
              options.nonegate = true;
              options.nocomment = true;
              self2.minimatch = new Minimatch(pattern, options);
              self2.options = self2.minimatch.options;
            }
            function finish(self2) {
              var nou = self2.nounique;
              var all = nou ? [] : Object.create(null);
              for (var i = 0, l = self2.matches.length; i < l; i++) {
                var matches = self2.matches[i];
                if (!matches || Object.keys(matches).length === 0) {
                  if (self2.nonull) {
                    var literal = self2.minimatch.globSet[i];
                    if (nou)
                      all.push(literal);
                    else
                      all[literal] = true;
                  }
                } else {
                  var m = Object.keys(matches);
                  if (nou)
                    all.push.apply(all, m);
                  else
                    m.forEach(function(m2) {
                      all[m2] = true;
                    });
                }
              }
              if (!nou)
                all = Object.keys(all);
              if (!self2.nosort)
                all = all.sort(alphasort);
              if (self2.mark) {
                for (var i = 0; i < all.length; i++) {
                  all[i] = self2._mark(all[i]);
                }
                if (self2.nodir) {
                  all = all.filter(function(e) {
                    var notDir = !/\/$/.test(e);
                    var c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
                    if (notDir && c2)
                      notDir = c2 !== "DIR" && !Array.isArray(c2);
                    return notDir;
                  });
                }
              }
              if (self2.ignore.length)
                all = all.filter(function(m2) {
                  return !isIgnored(self2, m2);
                });
              self2.found = all;
            }
            function mark(self2, p) {
              var abs = makeAbs(self2, p);
              var c2 = self2.cache[abs];
              var m = p;
              if (c2) {
                var isDir = c2 === "DIR" || Array.isArray(c2);
                var slash = p.slice(-1) === "/";
                if (isDir && !slash)
                  m += "/";
                else if (!isDir && slash)
                  m = m.slice(0, -1);
                if (m !== p) {
                  var mabs = makeAbs(self2, m);
                  self2.statCache[mabs] = self2.statCache[abs];
                  self2.cache[mabs] = self2.cache[abs];
                }
              }
              return m;
            }
            function makeAbs(self2, f) {
              var abs = f;
              if (f.charAt(0) === "/") {
                abs = path7.join(self2.root, f);
              } else if (isAbsolute2(f) || f === "") {
                abs = f;
              } else if (self2.changedCwd) {
                abs = path7.resolve(self2.cwd, f);
              } else {
                abs = path7.resolve(f);
              }
              if (process.platform === "win32")
                abs = abs.replace(/\\/g, "/");
              return abs;
            }
            function isIgnored(self2, path8) {
              if (!self2.ignore.length)
                return false;
              return self2.ignore.some(function(item) {
                return item.matcher.match(path8) || !!(item.gmatcher && item.gmatcher.match(path8));
              });
            }
            function childrenIgnored(self2, path8) {
              if (!self2.ignore.length)
                return false;
              return self2.ignore.some(function(item) {
                return !!(item.gmatcher && item.gmatcher.match(path8));
              });
            }
          }
        });
        var require_sync = __commonJS22({
          "node_modules/glob/sync.js"(exports22, module22) {
            module22.exports = globSync;
            globSync.GlobSync = GlobSync;
            var fs3 = require("fs");
            var rp = require_fs2();
            var minimatch2 = require_minimatch();
            var Minimatch = minimatch2.Minimatch;
            var Glob = require_glob().Glob;
            var util = require("util");
            var path7 = require("path");
            var assert = require("assert");
            var isAbsolute2 = require_path_is_absolute();
            var common = require_common2();
            var setopts = common.setopts;
            var ownProp = common.ownProp;
            var childrenIgnored = common.childrenIgnored;
            var isIgnored = common.isIgnored;
            function globSync(pattern, options) {
              if (typeof options === "function" || arguments.length === 3)
                throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
              return new GlobSync(pattern, options).found;
            }
            function GlobSync(pattern, options) {
              if (!pattern)
                throw new Error("must provide pattern");
              if (typeof options === "function" || arguments.length === 3)
                throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
              if (!(this instanceof GlobSync))
                return new GlobSync(pattern, options);
              setopts(this, pattern, options);
              if (this.noprocess)
                return this;
              var n = this.minimatch.set.length;
              this.matches = new Array(n);
              for (var i = 0; i < n; i++) {
                this._process(this.minimatch.set[i], i, false);
              }
              this._finish();
            }
            GlobSync.prototype._finish = function() {
              assert(this instanceof GlobSync);
              if (this.realpath) {
                var self2 = this;
                this.matches.forEach(function(matchset, index) {
                  var set = self2.matches[index] = Object.create(null);
                  for (var p in matchset) {
                    try {
                      p = self2._makeAbs(p);
                      var real = rp.realpathSync(p, self2.realpathCache);
                      set[real] = true;
                    } catch (er) {
                      if (er.syscall === "stat")
                        set[self2._makeAbs(p)] = true;
                      else
                        throw er;
                    }
                  }
                });
              }
              common.finish(this);
            };
            GlobSync.prototype._process = function(pattern, index, inGlobStar) {
              assert(this instanceof GlobSync);
              var n = 0;
              while (typeof pattern[n] === "string") {
                n++;
              }
              var prefix;
              switch (n) {
                case pattern.length:
                  this._processSimple(pattern.join("/"), index);
                  return;
                case 0:
                  prefix = null;
                  break;
                default:
                  prefix = pattern.slice(0, n).join("/");
                  break;
              }
              var remain = pattern.slice(n);
              var read;
              if (prefix === null)
                read = ".";
              else if (isAbsolute2(prefix) || isAbsolute2(pattern.join("/"))) {
                if (!prefix || !isAbsolute2(prefix))
                  prefix = "/" + prefix;
                read = prefix;
              } else
                read = prefix;
              var abs = this._makeAbs(read);
              if (childrenIgnored(this, read))
                return;
              var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
              if (isGlobStar)
                this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
              else
                this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
            };
            GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
              var entries3 = this._readdir(abs, inGlobStar);
              if (!entries3)
                return;
              var pn = remain[0];
              var negate = !!this.minimatch.negate;
              var rawGlob = pn._glob;
              var dotOk = this.dot || rawGlob.charAt(0) === ".";
              var matchedEntries = [];
              for (var i = 0; i < entries3.length; i++) {
                var e = entries3[i];
                if (e.charAt(0) !== "." || dotOk) {
                  var m;
                  if (negate && !prefix) {
                    m = !e.match(pn);
                  } else {
                    m = e.match(pn);
                  }
                  if (m)
                    matchedEntries.push(e);
                }
              }
              var len = matchedEntries.length;
              if (len === 0)
                return;
              if (remain.length === 1 && !this.mark && !this.stat) {
                if (!this.matches[index])
                  this.matches[index] = Object.create(null);
                for (var i = 0; i < len; i++) {
                  var e = matchedEntries[i];
                  if (prefix) {
                    if (prefix.slice(-1) !== "/")
                      e = prefix + "/" + e;
                    else
                      e = prefix + e;
                  }
                  if (e.charAt(0) === "/" && !this.nomount) {
                    e = path7.join(this.root, e);
                  }
                  this._emitMatch(index, e);
                }
                return;
              }
              remain.shift();
              for (var i = 0; i < len; i++) {
                var e = matchedEntries[i];
                var newPattern;
                if (prefix)
                  newPattern = [prefix, e];
                else
                  newPattern = [e];
                this._process(newPattern.concat(remain), index, inGlobStar);
              }
            };
            GlobSync.prototype._emitMatch = function(index, e) {
              if (isIgnored(this, e))
                return;
              var abs = this._makeAbs(e);
              if (this.mark)
                e = this._mark(e);
              if (this.absolute) {
                e = abs;
              }
              if (this.matches[index][e])
                return;
              if (this.nodir) {
                var c2 = this.cache[abs];
                if (c2 === "DIR" || Array.isArray(c2))
                  return;
              }
              this.matches[index][e] = true;
              if (this.stat)
                this._stat(e);
            };
            GlobSync.prototype._readdirInGlobStar = function(abs) {
              if (this.follow)
                return this._readdir(abs, false);
              var entries3;
              var lstat;
              var stat;
              try {
                lstat = fs3.lstatSync(abs);
              } catch (er) {
                if (er.code === "ENOENT") {
                  return null;
                }
              }
              var isSym = lstat && lstat.isSymbolicLink();
              this.symlinks[abs] = isSym;
              if (!isSym && lstat && !lstat.isDirectory())
                this.cache[abs] = "FILE";
              else
                entries3 = this._readdir(abs, false);
              return entries3;
            };
            GlobSync.prototype._readdir = function(abs, inGlobStar) {
              var entries3;
              if (inGlobStar && !ownProp(this.symlinks, abs))
                return this._readdirInGlobStar(abs);
              if (ownProp(this.cache, abs)) {
                var c2 = this.cache[abs];
                if (!c2 || c2 === "FILE")
                  return null;
                if (Array.isArray(c2))
                  return c2;
              }
              try {
                return this._readdirEntries(abs, fs3.readdirSync(abs));
              } catch (er) {
                this._readdirError(abs, er);
                return null;
              }
            };
            GlobSync.prototype._readdirEntries = function(abs, entries3) {
              if (!this.mark && !this.stat) {
                for (var i = 0; i < entries3.length; i++) {
                  var e = entries3[i];
                  if (abs === "/")
                    e = abs + e;
                  else
                    e = abs + "/" + e;
                  this.cache[e] = true;
                }
              }
              this.cache[abs] = entries3;
              return entries3;
            };
            GlobSync.prototype._readdirError = function(f, er) {
              switch (er.code) {
                case "ENOTSUP":
                case "ENOTDIR":
                  var abs = this._makeAbs(f);
                  this.cache[abs] = "FILE";
                  if (abs === this.cwdAbs) {
                    var error = new Error(er.code + " invalid cwd " + this.cwd);
                    error.path = this.cwd;
                    error.code = er.code;
                    throw error;
                  }
                  break;
                case "ENOENT":
                case "ELOOP":
                case "ENAMETOOLONG":
                case "UNKNOWN":
                  this.cache[this._makeAbs(f)] = false;
                  break;
                default:
                  this.cache[this._makeAbs(f)] = false;
                  if (this.strict)
                    throw er;
                  if (!this.silent)
                    console.error("glob error", er);
                  break;
              }
            };
            GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
              var entries3 = this._readdir(abs, inGlobStar);
              if (!entries3)
                return;
              var remainWithoutGlobStar = remain.slice(1);
              var gspref = prefix ? [prefix] : [];
              var noGlobStar = gspref.concat(remainWithoutGlobStar);
              this._process(noGlobStar, index, false);
              var len = entries3.length;
              var isSym = this.symlinks[abs];
              if (isSym && inGlobStar)
                return;
              for (var i = 0; i < len; i++) {
                var e = entries3[i];
                if (e.charAt(0) === "." && !this.dot)
                  continue;
                var instead = gspref.concat(entries3[i], remainWithoutGlobStar);
                this._process(instead, index, true);
                var below = gspref.concat(entries3[i], remain);
                this._process(below, index, true);
              }
            };
            GlobSync.prototype._processSimple = function(prefix, index) {
              var exists = this._stat(prefix);
              if (!this.matches[index])
                this.matches[index] = Object.create(null);
              if (!exists)
                return;
              if (prefix && isAbsolute2(prefix) && !this.nomount) {
                var trail = /[\/\\]$/.test(prefix);
                if (prefix.charAt(0) === "/") {
                  prefix = path7.join(this.root, prefix);
                } else {
                  prefix = path7.resolve(this.root, prefix);
                  if (trail)
                    prefix += "/";
                }
              }
              if (process.platform === "win32")
                prefix = prefix.replace(/\\/g, "/");
              this._emitMatch(index, prefix);
            };
            GlobSync.prototype._stat = function(f) {
              var abs = this._makeAbs(f);
              var needDir = f.slice(-1) === "/";
              if (f.length > this.maxLength)
                return false;
              if (!this.stat && ownProp(this.cache, abs)) {
                var c2 = this.cache[abs];
                if (Array.isArray(c2))
                  c2 = "DIR";
                if (!needDir || c2 === "DIR")
                  return c2;
                if (needDir && c2 === "FILE")
                  return false;
              }
              var exists;
              var stat = this.statCache[abs];
              if (!stat) {
                var lstat;
                try {
                  lstat = fs3.lstatSync(abs);
                } catch (er) {
                  if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
                    this.statCache[abs] = false;
                    return false;
                  }
                }
                if (lstat && lstat.isSymbolicLink()) {
                  try {
                    stat = fs3.statSync(abs);
                  } catch (er) {
                    stat = lstat;
                  }
                } else {
                  stat = lstat;
                }
              }
              this.statCache[abs] = stat;
              var c2 = true;
              if (stat)
                c2 = stat.isDirectory() ? "DIR" : "FILE";
              this.cache[abs] = this.cache[abs] || c2;
              if (needDir && c2 === "FILE")
                return false;
              return c2;
            };
            GlobSync.prototype._mark = function(p) {
              return common.mark(this, p);
            };
            GlobSync.prototype._makeAbs = function(f) {
              return common.makeAbs(this, f);
            };
          }
        });
        var require_wrappy = __commonJS22({
          "node_modules/wrappy/wrappy.js"(exports22, module22) {
            module22.exports = wrappy;
            function wrappy(fn, cb) {
              if (fn && cb)
                return wrappy(fn)(cb);
              if (typeof fn !== "function")
                throw new TypeError("need wrapper function");
              Object.keys(fn).forEach(function(k) {
                wrapper[k] = fn[k];
              });
              return wrapper;
              function wrapper() {
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; i++) {
                  args[i] = arguments[i];
                }
                var ret = fn.apply(this, args);
                var cb2 = args[args.length - 1];
                if (typeof ret === "function" && ret !== cb2) {
                  Object.keys(cb2).forEach(function(k) {
                    ret[k] = cb2[k];
                  });
                }
                return ret;
              }
            }
          }
        });
        var require_once = __commonJS22({
          "node_modules/once/once.js"(exports22, module22) {
            var wrappy = require_wrappy();
            module22.exports = wrappy(once);
            module22.exports.strict = wrappy(onceStrict);
            once.proto = once(function() {
              Object.defineProperty(Function.prototype, "once", {
                value: function() {
                  return once(this);
                },
                configurable: true
              });
              Object.defineProperty(Function.prototype, "onceStrict", {
                value: function() {
                  return onceStrict(this);
                },
                configurable: true
              });
            });
            function once(fn) {
              var f = function() {
                if (f.called)
                  return f.value;
                f.called = true;
                return f.value = fn.apply(this, arguments);
              };
              f.called = false;
              return f;
            }
            function onceStrict(fn) {
              var f = function() {
                if (f.called)
                  throw new Error(f.onceError);
                f.called = true;
                return f.value = fn.apply(this, arguments);
              };
              var name = fn.name || "Function wrapped with `once`";
              f.onceError = name + " shouldn't be called more than once";
              f.called = false;
              return f;
            }
          }
        });
        var require_inflight = __commonJS22({
          "node_modules/inflight/inflight.js"(exports22, module22) {
            var wrappy = require_wrappy();
            var reqs = Object.create(null);
            var once = require_once();
            module22.exports = wrappy(inflight);
            function inflight(key, cb) {
              if (reqs[key]) {
                reqs[key].push(cb);
                return null;
              } else {
                reqs[key] = [cb];
                return makeres(key);
              }
            }
            function makeres(key) {
              return once(function RES() {
                var cbs = reqs[key];
                var len = cbs.length;
                var args = slice(arguments);
                try {
                  for (var i = 0; i < len; i++) {
                    cbs[i].apply(null, args);
                  }
                } finally {
                  if (cbs.length > len) {
                    cbs.splice(0, len);
                    process.nextTick(function() {
                      RES.apply(null, args);
                    });
                  } else {
                    delete reqs[key];
                  }
                }
              });
            }
            function slice(args) {
              var length = args.length;
              var array2 = [];
              for (var i = 0; i < length; i++)
                array2[i] = args[i];
              return array2;
            }
          }
        });
        var require_glob = __commonJS22({
          "node_modules/glob/glob.js"(exports22, module22) {
            module22.exports = glob;
            var fs3 = require("fs");
            var rp = require_fs2();
            var minimatch2 = require_minimatch();
            var Minimatch = minimatch2.Minimatch;
            var inherits = require_inherits();
            var EE = require("events").EventEmitter;
            var path7 = require("path");
            var assert = require("assert");
            var isAbsolute2 = require_path_is_absolute();
            var globSync = require_sync();
            var common = require_common2();
            var setopts = common.setopts;
            var ownProp = common.ownProp;
            var inflight = require_inflight();
            var util = require("util");
            var childrenIgnored = common.childrenIgnored;
            var isIgnored = common.isIgnored;
            var once = require_once();
            function glob(pattern, options, cb) {
              if (typeof options === "function")
                cb = options, options = {};
              if (!options)
                options = {};
              if (options.sync) {
                if (cb)
                  throw new TypeError("callback provided to sync glob");
                return globSync(pattern, options);
              }
              return new Glob(pattern, options, cb);
            }
            glob.sync = globSync;
            var GlobSync = glob.GlobSync = globSync.GlobSync;
            glob.glob = glob;
            function extend(origin, add) {
              if (add === null || typeof add !== "object") {
                return origin;
              }
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            }
            glob.hasMagic = function(pattern, options_) {
              var options = extend({}, options_);
              options.noprocess = true;
              var g = new Glob(pattern, options);
              var set = g.minimatch.set;
              if (!pattern)
                return false;
              if (set.length > 1)
                return true;
              for (var j = 0; j < set[0].length; j++) {
                if (typeof set[0][j] !== "string")
                  return true;
              }
              return false;
            };
            glob.Glob = Glob;
            inherits(Glob, EE);
            function Glob(pattern, options, cb) {
              if (typeof options === "function") {
                cb = options;
                options = null;
              }
              if (options && options.sync) {
                if (cb)
                  throw new TypeError("callback provided to sync glob");
                return new GlobSync(pattern, options);
              }
              if (!(this instanceof Glob))
                return new Glob(pattern, options, cb);
              setopts(this, pattern, options);
              this._didRealPath = false;
              var n = this.minimatch.set.length;
              this.matches = new Array(n);
              if (typeof cb === "function") {
                cb = once(cb);
                this.on("error", cb);
                this.on("end", function(matches) {
                  cb(null, matches);
                });
              }
              var self2 = this;
              this._processing = 0;
              this._emitQueue = [];
              this._processQueue = [];
              this.paused = false;
              if (this.noprocess)
                return this;
              if (n === 0)
                return done();
              var sync = true;
              for (var i = 0; i < n; i++) {
                this._process(this.minimatch.set[i], i, false, done);
              }
              sync = false;
              function done() {
                --self2._processing;
                if (self2._processing <= 0) {
                  if (sync) {
                    process.nextTick(function() {
                      self2._finish();
                    });
                  } else {
                    self2._finish();
                  }
                }
              }
            }
            Glob.prototype._finish = function() {
              assert(this instanceof Glob);
              if (this.aborted)
                return;
              if (this.realpath && !this._didRealpath)
                return this._realpath();
              common.finish(this);
              this.emit("end", this.found);
            };
            Glob.prototype._realpath = function() {
              if (this._didRealpath)
                return;
              this._didRealpath = true;
              var n = this.matches.length;
              if (n === 0)
                return this._finish();
              var self2 = this;
              for (var i = 0; i < this.matches.length; i++)
                this._realpathSet(i, next);
              function next() {
                if (--n === 0)
                  self2._finish();
              }
            };
            Glob.prototype._realpathSet = function(index, cb) {
              var matchset = this.matches[index];
              if (!matchset)
                return cb();
              var found = Object.keys(matchset);
              var self2 = this;
              var n = found.length;
              if (n === 0)
                return cb();
              var set = this.matches[index] = Object.create(null);
              found.forEach(function(p, i) {
                p = self2._makeAbs(p);
                rp.realpath(p, self2.realpathCache, function(er, real) {
                  if (!er)
                    set[real] = true;
                  else if (er.syscall === "stat")
                    set[p] = true;
                  else
                    self2.emit("error", er);
                  if (--n === 0) {
                    self2.matches[index] = set;
                    cb();
                  }
                });
              });
            };
            Glob.prototype._mark = function(p) {
              return common.mark(this, p);
            };
            Glob.prototype._makeAbs = function(f) {
              return common.makeAbs(this, f);
            };
            Glob.prototype.abort = function() {
              this.aborted = true;
              this.emit("abort");
            };
            Glob.prototype.pause = function() {
              if (!this.paused) {
                this.paused = true;
                this.emit("pause");
              }
            };
            Glob.prototype.resume = function() {
              if (this.paused) {
                this.emit("resume");
                this.paused = false;
                if (this._emitQueue.length) {
                  var eq = this._emitQueue.slice(0);
                  this._emitQueue.length = 0;
                  for (var i = 0; i < eq.length; i++) {
                    var e = eq[i];
                    this._emitMatch(e[0], e[1]);
                  }
                }
                if (this._processQueue.length) {
                  var pq = this._processQueue.slice(0);
                  this._processQueue.length = 0;
                  for (var i = 0; i < pq.length; i++) {
                    var p = pq[i];
                    this._processing--;
                    this._process(p[0], p[1], p[2], p[3]);
                  }
                }
              }
            };
            Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
              assert(this instanceof Glob);
              assert(typeof cb === "function");
              if (this.aborted)
                return;
              this._processing++;
              if (this.paused) {
                this._processQueue.push([pattern, index, inGlobStar, cb]);
                return;
              }
              var n = 0;
              while (typeof pattern[n] === "string") {
                n++;
              }
              var prefix;
              switch (n) {
                case pattern.length:
                  this._processSimple(pattern.join("/"), index, cb);
                  return;
                case 0:
                  prefix = null;
                  break;
                default:
                  prefix = pattern.slice(0, n).join("/");
                  break;
              }
              var remain = pattern.slice(n);
              var read;
              if (prefix === null)
                read = ".";
              else if (isAbsolute2(prefix) || isAbsolute2(pattern.join("/"))) {
                if (!prefix || !isAbsolute2(prefix))
                  prefix = "/" + prefix;
                read = prefix;
              } else
                read = prefix;
              var abs = this._makeAbs(read);
              if (childrenIgnored(this, read))
                return cb();
              var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
              if (isGlobStar)
                this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
              else
                this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
            };
            Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
              var self2 = this;
              this._readdir(abs, inGlobStar, function(er, entries3) {
                return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries3, cb);
              });
            };
            Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries3, cb) {
              if (!entries3)
                return cb();
              var pn = remain[0];
              var negate = !!this.minimatch.negate;
              var rawGlob = pn._glob;
              var dotOk = this.dot || rawGlob.charAt(0) === ".";
              var matchedEntries = [];
              for (var i = 0; i < entries3.length; i++) {
                var e = entries3[i];
                if (e.charAt(0) !== "." || dotOk) {
                  var m;
                  if (negate && !prefix) {
                    m = !e.match(pn);
                  } else {
                    m = e.match(pn);
                  }
                  if (m)
                    matchedEntries.push(e);
                }
              }
              var len = matchedEntries.length;
              if (len === 0)
                return cb();
              if (remain.length === 1 && !this.mark && !this.stat) {
                if (!this.matches[index])
                  this.matches[index] = Object.create(null);
                for (var i = 0; i < len; i++) {
                  var e = matchedEntries[i];
                  if (prefix) {
                    if (prefix !== "/")
                      e = prefix + "/" + e;
                    else
                      e = prefix + e;
                  }
                  if (e.charAt(0) === "/" && !this.nomount) {
                    e = path7.join(this.root, e);
                  }
                  this._emitMatch(index, e);
                }
                return cb();
              }
              remain.shift();
              for (var i = 0; i < len; i++) {
                var e = matchedEntries[i];
                var newPattern;
                if (prefix) {
                  if (prefix !== "/")
                    e = prefix + "/" + e;
                  else
                    e = prefix + e;
                }
                this._process([e].concat(remain), index, inGlobStar, cb);
              }
              cb();
            };
            Glob.prototype._emitMatch = function(index, e) {
              if (this.aborted)
                return;
              if (isIgnored(this, e))
                return;
              if (this.paused) {
                this._emitQueue.push([index, e]);
                return;
              }
              var abs = isAbsolute2(e) ? e : this._makeAbs(e);
              if (this.mark)
                e = this._mark(e);
              if (this.absolute)
                e = abs;
              if (this.matches[index][e])
                return;
              if (this.nodir) {
                var c2 = this.cache[abs];
                if (c2 === "DIR" || Array.isArray(c2))
                  return;
              }
              this.matches[index][e] = true;
              var st = this.statCache[abs];
              if (st)
                this.emit("stat", e, st);
              this.emit("match", e);
            };
            Glob.prototype._readdirInGlobStar = function(abs, cb) {
              if (this.aborted)
                return;
              if (this.follow)
                return this._readdir(abs, false, cb);
              var lstatkey = "lstat\0" + abs;
              var self2 = this;
              var lstatcb = inflight(lstatkey, lstatcb_);
              if (lstatcb)
                fs3.lstat(abs, lstatcb);
              function lstatcb_(er, lstat) {
                if (er && er.code === "ENOENT")
                  return cb();
                var isSym = lstat && lstat.isSymbolicLink();
                self2.symlinks[abs] = isSym;
                if (!isSym && lstat && !lstat.isDirectory()) {
                  self2.cache[abs] = "FILE";
                  cb();
                } else
                  self2._readdir(abs, false, cb);
              }
            };
            Glob.prototype._readdir = function(abs, inGlobStar, cb) {
              if (this.aborted)
                return;
              cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
              if (!cb)
                return;
              if (inGlobStar && !ownProp(this.symlinks, abs))
                return this._readdirInGlobStar(abs, cb);
              if (ownProp(this.cache, abs)) {
                var c2 = this.cache[abs];
                if (!c2 || c2 === "FILE")
                  return cb();
                if (Array.isArray(c2))
                  return cb(null, c2);
              }
              var self2 = this;
              fs3.readdir(abs, readdirCb(this, abs, cb));
            };
            function readdirCb(self2, abs, cb) {
              return function(er, entries3) {
                if (er)
                  self2._readdirError(abs, er, cb);
                else
                  self2._readdirEntries(abs, entries3, cb);
              };
            }
            Glob.prototype._readdirEntries = function(abs, entries3, cb) {
              if (this.aborted)
                return;
              if (!this.mark && !this.stat) {
                for (var i = 0; i < entries3.length; i++) {
                  var e = entries3[i];
                  if (abs === "/")
                    e = abs + e;
                  else
                    e = abs + "/" + e;
                  this.cache[e] = true;
                }
              }
              this.cache[abs] = entries3;
              return cb(null, entries3);
            };
            Glob.prototype._readdirError = function(f, er, cb) {
              if (this.aborted)
                return;
              switch (er.code) {
                case "ENOTSUP":
                case "ENOTDIR":
                  var abs = this._makeAbs(f);
                  this.cache[abs] = "FILE";
                  if (abs === this.cwdAbs) {
                    var error = new Error(er.code + " invalid cwd " + this.cwd);
                    error.path = this.cwd;
                    error.code = er.code;
                    this.emit("error", error);
                    this.abort();
                  }
                  break;
                case "ENOENT":
                case "ELOOP":
                case "ENAMETOOLONG":
                case "UNKNOWN":
                  this.cache[this._makeAbs(f)] = false;
                  break;
                default:
                  this.cache[this._makeAbs(f)] = false;
                  if (this.strict) {
                    this.emit("error", er);
                    this.abort();
                  }
                  if (!this.silent)
                    console.error("glob error", er);
                  break;
              }
              return cb();
            };
            Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
              var self2 = this;
              this._readdir(abs, inGlobStar, function(er, entries3) {
                self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries3, cb);
              });
            };
            Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries3, cb) {
              if (!entries3)
                return cb();
              var remainWithoutGlobStar = remain.slice(1);
              var gspref = prefix ? [prefix] : [];
              var noGlobStar = gspref.concat(remainWithoutGlobStar);
              this._process(noGlobStar, index, false, cb);
              var isSym = this.symlinks[abs];
              var len = entries3.length;
              if (isSym && inGlobStar)
                return cb();
              for (var i = 0; i < len; i++) {
                var e = entries3[i];
                if (e.charAt(0) === "." && !this.dot)
                  continue;
                var instead = gspref.concat(entries3[i], remainWithoutGlobStar);
                this._process(instead, index, true, cb);
                var below = gspref.concat(entries3[i], remain);
                this._process(below, index, true, cb);
              }
              cb();
            };
            Glob.prototype._processSimple = function(prefix, index, cb) {
              var self2 = this;
              this._stat(prefix, function(er, exists) {
                self2._processSimple2(prefix, index, er, exists, cb);
              });
            };
            Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
              if (!this.matches[index])
                this.matches[index] = Object.create(null);
              if (!exists)
                return cb();
              if (prefix && isAbsolute2(prefix) && !this.nomount) {
                var trail = /[\/\\]$/.test(prefix);
                if (prefix.charAt(0) === "/") {
                  prefix = path7.join(this.root, prefix);
                } else {
                  prefix = path7.resolve(this.root, prefix);
                  if (trail)
                    prefix += "/";
                }
              }
              if (process.platform === "win32")
                prefix = prefix.replace(/\\/g, "/");
              this._emitMatch(index, prefix);
              cb();
            };
            Glob.prototype._stat = function(f, cb) {
              var abs = this._makeAbs(f);
              var needDir = f.slice(-1) === "/";
              if (f.length > this.maxLength)
                return cb();
              if (!this.stat && ownProp(this.cache, abs)) {
                var c2 = this.cache[abs];
                if (Array.isArray(c2))
                  c2 = "DIR";
                if (!needDir || c2 === "DIR")
                  return cb(null, c2);
                if (needDir && c2 === "FILE")
                  return cb();
              }
              var exists;
              var stat = this.statCache[abs];
              if (stat !== void 0) {
                if (stat === false)
                  return cb(null, stat);
                else {
                  var type = stat.isDirectory() ? "DIR" : "FILE";
                  if (needDir && type === "FILE")
                    return cb();
                  else
                    return cb(null, type, stat);
                }
              }
              var self2 = this;
              var statcb = inflight("stat\0" + abs, lstatcb_);
              if (statcb)
                fs3.lstat(abs, statcb);
              function lstatcb_(er, lstat) {
                if (lstat && lstat.isSymbolicLink()) {
                  return fs3.stat(abs, function(er2, stat2) {
                    if (er2)
                      self2._stat2(f, abs, null, lstat, cb);
                    else
                      self2._stat2(f, abs, er2, stat2, cb);
                  });
                } else {
                  self2._stat2(f, abs, er, lstat, cb);
                }
              }
            };
            Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
              if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
                this.statCache[abs] = false;
                return cb();
              }
              var needDir = f.slice(-1) === "/";
              this.statCache[abs] = stat;
              if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
                return cb(null, false, stat);
              var c2 = true;
              if (stat)
                c2 = stat.isDirectory() ? "DIR" : "FILE";
              this.cache[abs] = this.cache[abs] || c2;
              if (needDir && c2 === "FILE")
                return cb();
              return cb(null, c2, stat);
            };
          }
        });
        var require_array = __commonJS22({
          "node_modules/fast-glob/out/utils/array.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.splitWhen = exports22.flatten = void 0;
            function flatten2(items) {
              return items.reduce((collection, item) => [].concat(collection, item), []);
            }
            exports22.flatten = flatten2;
            function splitWhen(items, predicate) {
              const result = [[]];
              let groupIndex = 0;
              for (const item of items) {
                if (predicate(item)) {
                  groupIndex++;
                  result[groupIndex] = [];
                } else {
                  result[groupIndex].push(item);
                }
              }
              return result;
            }
            exports22.splitWhen = splitWhen;
          }
        });
        var require_errno = __commonJS22({
          "node_modules/fast-glob/out/utils/errno.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.isEnoentCodeError = void 0;
            function isEnoentCodeError(error) {
              return error.code === "ENOENT";
            }
            exports22.isEnoentCodeError = isEnoentCodeError;
          }
        });
        var require_fs3 = __commonJS22({
          "node_modules/fast-glob/out/utils/fs.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.createDirentFromStats = void 0;
            var DirentFromStats = class {
              constructor(name, stats) {
                this.name = name;
                this.isBlockDevice = stats.isBlockDevice.bind(stats);
                this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
                this.isDirectory = stats.isDirectory.bind(stats);
                this.isFIFO = stats.isFIFO.bind(stats);
                this.isFile = stats.isFile.bind(stats);
                this.isSocket = stats.isSocket.bind(stats);
                this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
              }
            };
            function createDirentFromStats(name, stats) {
              return new DirentFromStats(name, stats);
            }
            exports22.createDirentFromStats = createDirentFromStats;
          }
        });
        var require_path = __commonJS22({
          "node_modules/fast-glob/out/utils/path.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.removeLeadingDotSegment = exports22.escape = exports22.makeAbsolute = exports22.unixify = void 0;
            var path7 = require("path");
            var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
            var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
            function unixify(filepath) {
              return filepath.replace(/\\/g, "/");
            }
            exports22.unixify = unixify;
            function makeAbsolute(cwd, filepath) {
              return path7.resolve(cwd, filepath);
            }
            exports22.makeAbsolute = makeAbsolute;
            function escape(pattern) {
              return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
            }
            exports22.escape = escape;
            function removeLeadingDotSegment(entry) {
              if (entry.charAt(0) === ".") {
                const secondCharactery = entry.charAt(1);
                if (secondCharactery === "/" || secondCharactery === "\\") {
                  return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
                }
              }
              return entry;
            }
            exports22.removeLeadingDotSegment = removeLeadingDotSegment;
          }
        });
        var require_is_extglob = __commonJS22({
          "node_modules/is-extglob/index.js"(exports22, module22) {
            module22.exports = function isExtglob(str) {
              if (typeof str !== "string" || str === "") {
                return false;
              }
              var match;
              while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
                if (match[2])
                  return true;
                str = str.slice(match.index + match[0].length);
              }
              return false;
            };
          }
        });
        var require_is_glob = __commonJS22({
          "node_modules/is-glob/index.js"(exports22, module22) {
            var isExtglob = require_is_extglob();
            var chars = { "{": "}", "(": ")", "[": "]" };
            var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
            var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
            module22.exports = function isGlob(str, options) {
              if (typeof str !== "string" || str === "") {
                return false;
              }
              if (isExtglob(str)) {
                return true;
              }
              var regex = strictRegex;
              var match;
              if (options && options.strict === false) {
                regex = relaxedRegex;
              }
              while (match = regex.exec(str)) {
                if (match[2])
                  return true;
                var idx = match.index + match[0].length;
                var open = match[1];
                var close = open ? chars[open] : null;
                if (open && close) {
                  var n = str.indexOf(close, idx);
                  if (n !== -1) {
                    idx = n + 1;
                  }
                }
                str = str.slice(idx);
              }
              return false;
            };
          }
        });
        var require_glob_parent = __commonJS22({
          "node_modules/glob-parent/index.js"(exports22, module22) {
            "use strict";
            var isGlob = require_is_glob();
            var pathPosixDirname = require("path").posix.dirname;
            var isWin32 = require("os").platform() === "win32";
            var slash = "/";
            var backslash = /\\/g;
            var enclosure = /[\{\[].*[\}\]]$/;
            var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
            var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
            module22.exports = function globParent(str, opts) {
              var options = Object.assign({ flipBackslashes: true }, opts);
              if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
                str = str.replace(backslash, slash);
              }
              if (enclosure.test(str)) {
                str += slash;
              }
              str += "a";
              do {
                str = pathPosixDirname(str);
              } while (isGlob(str) || globby.test(str));
              return str.replace(escaped, "$1");
            };
          }
        });
        var require_utils3 = __commonJS22({
          "node_modules/braces/lib/utils.js"(exports22) {
            "use strict";
            exports22.isInteger = (num) => {
              if (typeof num === "number") {
                return Number.isInteger(num);
              }
              if (typeof num === "string" && num.trim() !== "") {
                return Number.isInteger(Number(num));
              }
              return false;
            };
            exports22.find = (node, type) => node.nodes.find((node2) => node2.type === type);
            exports22.exceedsLimit = (min, max, step = 1, limit) => {
              if (limit === false)
                return false;
              if (!exports22.isInteger(min) || !exports22.isInteger(max))
                return false;
              return (Number(max) - Number(min)) / Number(step) >= limit;
            };
            exports22.escapeNode = (block, n = 0, type) => {
              let node = block.nodes[n];
              if (!node)
                return;
              if (type && node.type === type || node.type === "open" || node.type === "close") {
                if (node.escaped !== true) {
                  node.value = "\\" + node.value;
                  node.escaped = true;
                }
              }
            };
            exports22.encloseBrace = (node) => {
              if (node.type !== "brace")
                return false;
              if (node.commas >> 0 + node.ranges >> 0 === 0) {
                node.invalid = true;
                return true;
              }
              return false;
            };
            exports22.isInvalidBrace = (block) => {
              if (block.type !== "brace")
                return false;
              if (block.invalid === true || block.dollar)
                return true;
              if (block.commas >> 0 + block.ranges >> 0 === 0) {
                block.invalid = true;
                return true;
              }
              if (block.open !== true || block.close !== true) {
                block.invalid = true;
                return true;
              }
              return false;
            };
            exports22.isOpenOrClose = (node) => {
              if (node.type === "open" || node.type === "close") {
                return true;
              }
              return node.open === true || node.close === true;
            };
            exports22.reduce = (nodes) => nodes.reduce((acc, node) => {
              if (node.type === "text")
                acc.push(node.value);
              if (node.type === "range")
                node.type = "text";
              return acc;
            }, []);
            exports22.flatten = (...args) => {
              const result = [];
              const flat = (arr) => {
                for (let i = 0; i < arr.length; i++) {
                  let ele = arr[i];
                  Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
                }
                return result;
              };
              flat(args);
              return result;
            };
          }
        });
        var require_stringify222 = __commonJS22({
          "node_modules/braces/lib/stringify.js"(exports22, module22) {
            "use strict";
            var utils = require_utils3();
            module22.exports = (ast, options = {}) => {
              let stringify2 = (node, parent = {}) => {
                let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
                let invalidNode = node.invalid === true && options.escapeInvalid === true;
                let output = "";
                if (node.value) {
                  if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
                    return "\\" + node.value;
                  }
                  return node.value;
                }
                if (node.value) {
                  return node.value;
                }
                if (node.nodes) {
                  for (let child of node.nodes) {
                    output += stringify2(child);
                  }
                }
                return output;
              };
              return stringify2(ast);
            };
          }
        });
        var require_is_number = __commonJS22({
          "node_modules/is-number/index.js"(exports22, module22) {
            "use strict";
            module22.exports = function(num) {
              if (typeof num === "number") {
                return num - num === 0;
              }
              if (typeof num === "string" && num.trim() !== "") {
                return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
              }
              return false;
            };
          }
        });
        var require_to_regex_range = __commonJS22({
          "node_modules/to-regex-range/index.js"(exports22, module22) {
            "use strict";
            var isNumber = require_is_number();
            var toRegexRange = (min, max, options) => {
              if (isNumber(min) === false) {
                throw new TypeError("toRegexRange: expected the first argument to be a number");
              }
              if (max === void 0 || min === max) {
                return String(min);
              }
              if (isNumber(max) === false) {
                throw new TypeError("toRegexRange: expected the second argument to be a number.");
              }
              let opts = __spreadValues2({ relaxZeros: true }, options);
              if (typeof opts.strictZeros === "boolean") {
                opts.relaxZeros = opts.strictZeros === false;
              }
              let relax = String(opts.relaxZeros);
              let shorthand = String(opts.shorthand);
              let capture = String(opts.capture);
              let wrap = String(opts.wrap);
              let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
              if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
                return toRegexRange.cache[cacheKey].result;
              }
              let a = Math.min(min, max);
              let b = Math.max(min, max);
              if (Math.abs(a - b) === 1) {
                let result = min + "|" + max;
                if (opts.capture) {
                  return `(${result})`;
                }
                if (opts.wrap === false) {
                  return result;
                }
                return `(?:${result})`;
              }
              let isPadded = hasPadding(min) || hasPadding(max);
              let state = { min, max, a, b };
              let positives = [];
              let negatives = [];
              if (isPadded) {
                state.isPadded = isPadded;
                state.maxLen = String(state.max).length;
              }
              if (a < 0) {
                let newMin = b < 0 ? Math.abs(b) : 1;
                negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
                a = state.a = 0;
              }
              if (b >= 0) {
                positives = splitToPatterns(a, b, state, opts);
              }
              state.negatives = negatives;
              state.positives = positives;
              state.result = collatePatterns(negatives, positives, opts);
              if (opts.capture === true) {
                state.result = `(${state.result})`;
              } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
                state.result = `(?:${state.result})`;
              }
              toRegexRange.cache[cacheKey] = state;
              return state.result;
            };
            function collatePatterns(neg, pos, options) {
              let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
              let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
              let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
              let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
              return subpatterns.join("|");
            }
            function splitToRanges(min, max) {
              let nines = 1;
              let zeros = 1;
              let stop = countNines(min, nines);
              let stops = new Set([max]);
              while (min <= stop && stop <= max) {
                stops.add(stop);
                nines += 1;
                stop = countNines(min, nines);
              }
              stop = countZeros(max + 1, zeros) - 1;
              while (min < stop && stop <= max) {
                stops.add(stop);
                zeros += 1;
                stop = countZeros(max + 1, zeros) - 1;
              }
              stops = [...stops];
              stops.sort(compare);
              return stops;
            }
            function rangeToPattern(start, stop, options) {
              if (start === stop) {
                return { pattern: start, count: [], digits: 0 };
              }
              let zipped = zip(start, stop);
              let digits = zipped.length;
              let pattern = "";
              let count = 0;
              for (let i = 0; i < digits; i++) {
                let [startDigit, stopDigit] = zipped[i];
                if (startDigit === stopDigit) {
                  pattern += startDigit;
                } else if (startDigit !== "0" || stopDigit !== "9") {
                  pattern += toCharacterClass(startDigit, stopDigit, options);
                } else {
                  count++;
                }
              }
              if (count) {
                pattern += options.shorthand === true ? "\\d" : "[0-9]";
              }
              return { pattern, count: [count], digits };
            }
            function splitToPatterns(min, max, tok, options) {
              let ranges = splitToRanges(min, max);
              let tokens = [];
              let start = min;
              let prev;
              for (let i = 0; i < ranges.length; i++) {
                let max2 = ranges[i];
                let obj = rangeToPattern(String(start), String(max2), options);
                let zeros = "";
                if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
                  if (prev.count.length > 1) {
                    prev.count.pop();
                  }
                  prev.count.push(obj.count[0]);
                  prev.string = prev.pattern + toQuantifier(prev.count);
                  start = max2 + 1;
                  continue;
                }
                if (tok.isPadded) {
                  zeros = padZeros(max2, tok, options);
                }
                obj.string = zeros + obj.pattern + toQuantifier(obj.count);
                tokens.push(obj);
                start = max2 + 1;
                prev = obj;
              }
              return tokens;
            }
            function filterPatterns(arr, comparison, prefix, intersection, options) {
              let result = [];
              for (let ele of arr) {
                let { string } = ele;
                if (!intersection && !contains(comparison, "string", string)) {
                  result.push(prefix + string);
                }
                if (intersection && contains(comparison, "string", string)) {
                  result.push(prefix + string);
                }
              }
              return result;
            }
            function zip(a, b) {
              let arr = [];
              for (let i = 0; i < a.length; i++)
                arr.push([a[i], b[i]]);
              return arr;
            }
            function compare(a, b) {
              return a > b ? 1 : b > a ? -1 : 0;
            }
            function contains(arr, key, val) {
              return arr.some((ele) => ele[key] === val);
            }
            function countNines(min, len) {
              return Number(String(min).slice(0, -len) + "9".repeat(len));
            }
            function countZeros(integer, zeros) {
              return integer - integer % Math.pow(10, zeros);
            }
            function toQuantifier(digits) {
              let [start = 0, stop = ""] = digits;
              if (stop || start > 1) {
                return `{${start + (stop ? "," + stop : "")}}`;
              }
              return "";
            }
            function toCharacterClass(a, b, options) {
              return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
            }
            function hasPadding(str) {
              return /^-?(0+)\d/.test(str);
            }
            function padZeros(value, tok, options) {
              if (!tok.isPadded) {
                return value;
              }
              let diff = Math.abs(tok.maxLen - String(value).length);
              let relax = options.relaxZeros !== false;
              switch (diff) {
                case 0:
                  return "";
                case 1:
                  return relax ? "0?" : "0";
                case 2:
                  return relax ? "0{0,2}" : "00";
                default: {
                  return relax ? `0{0,${diff}}` : `0{${diff}}`;
                }
              }
            }
            toRegexRange.cache = {};
            toRegexRange.clearCache = () => toRegexRange.cache = {};
            module22.exports = toRegexRange;
          }
        });
        var require_fill_range = __commonJS22({
          "node_modules/fill-range/index.js"(exports22, module22) {
            "use strict";
            var util = require("util");
            var toRegexRange = require_to_regex_range();
            var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
            var transform = (toNumber) => {
              return (value) => toNumber === true ? Number(value) : String(value);
            };
            var isValidValue = (value) => {
              return typeof value === "number" || typeof value === "string" && value !== "";
            };
            var isNumber = (num) => Number.isInteger(+num);
            var zeros = (input) => {
              let value = `${input}`;
              let index = -1;
              if (value[0] === "-")
                value = value.slice(1);
              if (value === "0")
                return false;
              while (value[++index] === "0")
                ;
              return index > 0;
            };
            var stringify2 = (start, end, options) => {
              if (typeof start === "string" || typeof end === "string") {
                return true;
              }
              return options.stringify === true;
            };
            var pad = (input, maxLength, toNumber) => {
              if (maxLength > 0) {
                let dash = input[0] === "-" ? "-" : "";
                if (dash)
                  input = input.slice(1);
                input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
              }
              if (toNumber === false) {
                return String(input);
              }
              return input;
            };
            var toMaxLen = (input, maxLength) => {
              let negative = input[0] === "-" ? "-" : "";
              if (negative) {
                input = input.slice(1);
                maxLength--;
              }
              while (input.length < maxLength)
                input = "0" + input;
              return negative ? "-" + input : input;
            };
            var toSequence = (parts, options) => {
              parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
              parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
              let prefix = options.capture ? "" : "?:";
              let positives = "";
              let negatives = "";
              let result;
              if (parts.positives.length) {
                positives = parts.positives.join("|");
              }
              if (parts.negatives.length) {
                negatives = `-(${prefix}${parts.negatives.join("|")})`;
              }
              if (positives && negatives) {
                result = `${positives}|${negatives}`;
              } else {
                result = positives || negatives;
              }
              if (options.wrap) {
                return `(${prefix}${result})`;
              }
              return result;
            };
            var toRange = (a, b, isNumbers, options) => {
              if (isNumbers) {
                return toRegexRange(a, b, __spreadValues2({ wrap: false }, options));
              }
              let start = String.fromCharCode(a);
              if (a === b)
                return start;
              let stop = String.fromCharCode(b);
              return `[${start}-${stop}]`;
            };
            var toRegex = (start, end, options) => {
              if (Array.isArray(start)) {
                let wrap = options.wrap === true;
                let prefix = options.capture ? "" : "?:";
                return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
              }
              return toRegexRange(start, end, options);
            };
            var rangeError = (...args) => {
              return new RangeError("Invalid range arguments: " + util.inspect(...args));
            };
            var invalidRange = (start, end, options) => {
              if (options.strictRanges === true)
                throw rangeError([start, end]);
              return [];
            };
            var invalidStep = (step, options) => {
              if (options.strictRanges === true) {
                throw new TypeError(`Expected step "${step}" to be a number`);
              }
              return [];
            };
            var fillNumbers = (start, end, step = 1, options = {}) => {
              let a = Number(start);
              let b = Number(end);
              if (!Number.isInteger(a) || !Number.isInteger(b)) {
                if (options.strictRanges === true)
                  throw rangeError([start, end]);
                return [];
              }
              if (a === 0)
                a = 0;
              if (b === 0)
                b = 0;
              let descending = a > b;
              let startString = String(start);
              let endString = String(end);
              let stepString = String(step);
              step = Math.max(Math.abs(step), 1);
              let padded = zeros(startString) || zeros(endString) || zeros(stepString);
              let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
              let toNumber = padded === false && stringify2(start, end, options) === false;
              let format = options.transform || transform(toNumber);
              if (options.toRegex && step === 1) {
                return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
              }
              let parts = { negatives: [], positives: [] };
              let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
              let range = [];
              let index = 0;
              while (descending ? a >= b : a <= b) {
                if (options.toRegex === true && step > 1) {
                  push(a);
                } else {
                  range.push(pad(format(a, index), maxLen, toNumber));
                }
                a = descending ? a - step : a + step;
                index++;
              }
              if (options.toRegex === true) {
                return step > 1 ? toSequence(parts, options) : toRegex(range, null, __spreadValues2({ wrap: false }, options));
              }
              return range;
            };
            var fillLetters = (start, end, step = 1, options = {}) => {
              if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
                return invalidRange(start, end, options);
              }
              let format = options.transform || ((val) => String.fromCharCode(val));
              let a = `${start}`.charCodeAt(0);
              let b = `${end}`.charCodeAt(0);
              let descending = a > b;
              let min = Math.min(a, b);
              let max = Math.max(a, b);
              if (options.toRegex && step === 1) {
                return toRange(min, max, false, options);
              }
              let range = [];
              let index = 0;
              while (descending ? a >= b : a <= b) {
                range.push(format(a, index));
                a = descending ? a - step : a + step;
                index++;
              }
              if (options.toRegex === true) {
                return toRegex(range, null, { wrap: false, options });
              }
              return range;
            };
            var fill = (start, end, step, options = {}) => {
              if (end == null && isValidValue(start)) {
                return [start];
              }
              if (!isValidValue(start) || !isValidValue(end)) {
                return invalidRange(start, end, options);
              }
              if (typeof step === "function") {
                return fill(start, end, 1, { transform: step });
              }
              if (isObject(step)) {
                return fill(start, end, 0, step);
              }
              let opts = __spreadValues2({}, options);
              if (opts.capture === true)
                opts.wrap = true;
              step = step || opts.step || 1;
              if (!isNumber(step)) {
                if (step != null && !isObject(step))
                  return invalidStep(step, opts);
                return fill(start, end, 1, step);
              }
              if (isNumber(start) && isNumber(end)) {
                return fillNumbers(start, end, step, opts);
              }
              return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
            };
            module22.exports = fill;
          }
        });
        var require_compile = __commonJS22({
          "node_modules/braces/lib/compile.js"(exports22, module22) {
            "use strict";
            var fill = require_fill_range();
            var utils = require_utils3();
            var compile = (ast, options = {}) => {
              let walk = (node, parent = {}) => {
                let invalidBlock = utils.isInvalidBrace(parent);
                let invalidNode = node.invalid === true && options.escapeInvalid === true;
                let invalid = invalidBlock === true || invalidNode === true;
                let prefix = options.escapeInvalid === true ? "\\" : "";
                let output = "";
                if (node.isOpen === true) {
                  return prefix + node.value;
                }
                if (node.isClose === true) {
                  return prefix + node.value;
                }
                if (node.type === "open") {
                  return invalid ? prefix + node.value : "(";
                }
                if (node.type === "close") {
                  return invalid ? prefix + node.value : ")";
                }
                if (node.type === "comma") {
                  return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
                }
                if (node.value) {
                  return node.value;
                }
                if (node.nodes && node.ranges > 0) {
                  let args = utils.reduce(node.nodes);
                  let range = fill(...args, __spreadProps2(__spreadValues2({}, options), { wrap: false, toRegex: true }));
                  if (range.length !== 0) {
                    return args.length > 1 && range.length > 1 ? `(${range})` : range;
                  }
                }
                if (node.nodes) {
                  for (let child of node.nodes) {
                    output += walk(child, node);
                  }
                }
                return output;
              };
              return walk(ast);
            };
            module22.exports = compile;
          }
        });
        var require_expand = __commonJS22({
          "node_modules/braces/lib/expand.js"(exports22, module22) {
            "use strict";
            var fill = require_fill_range();
            var stringify2 = require_stringify222();
            var utils = require_utils3();
            var append = (queue = "", stash = "", enclose = false) => {
              let result = [];
              queue = [].concat(queue);
              stash = [].concat(stash);
              if (!stash.length)
                return queue;
              if (!queue.length) {
                return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
              }
              for (let item of queue) {
                if (Array.isArray(item)) {
                  for (let value of item) {
                    result.push(append(value, stash, enclose));
                  }
                } else {
                  for (let ele of stash) {
                    if (enclose === true && typeof ele === "string")
                      ele = `{${ele}}`;
                    result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
                  }
                }
              }
              return utils.flatten(result);
            };
            var expand = (ast, options = {}) => {
              let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
              let walk = (node, parent = {}) => {
                node.queue = [];
                let p = parent;
                let q = parent.queue;
                while (p.type !== "brace" && p.type !== "root" && p.parent) {
                  p = p.parent;
                  q = p.queue;
                }
                if (node.invalid || node.dollar) {
                  q.push(append(q.pop(), stringify2(node, options)));
                  return;
                }
                if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
                  q.push(append(q.pop(), ["{}"]));
                  return;
                }
                if (node.nodes && node.ranges > 0) {
                  let args = utils.reduce(node.nodes);
                  if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
                    throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
                  }
                  let range = fill(...args, options);
                  if (range.length === 0) {
                    range = stringify2(node, options);
                  }
                  q.push(append(q.pop(), range));
                  node.nodes = [];
                  return;
                }
                let enclose = utils.encloseBrace(node);
                let queue = node.queue;
                let block = node;
                while (block.type !== "brace" && block.type !== "root" && block.parent) {
                  block = block.parent;
                  queue = block.queue;
                }
                for (let i = 0; i < node.nodes.length; i++) {
                  let child = node.nodes[i];
                  if (child.type === "comma" && node.type === "brace") {
                    if (i === 1)
                      queue.push("");
                    queue.push("");
                    continue;
                  }
                  if (child.type === "close") {
                    q.push(append(q.pop(), queue, enclose));
                    continue;
                  }
                  if (child.value && child.type !== "open") {
                    queue.push(append(queue.pop(), child.value));
                    continue;
                  }
                  if (child.nodes) {
                    walk(child, node);
                  }
                }
                return queue;
              };
              return utils.flatten(walk(ast));
            };
            module22.exports = expand;
          }
        });
        var require_constants = __commonJS22({
          "node_modules/braces/lib/constants.js"(exports22, module22) {
            "use strict";
            module22.exports = {
              MAX_LENGTH: 1024 * 64,
              CHAR_0: "0",
              CHAR_9: "9",
              CHAR_UPPERCASE_A: "A",
              CHAR_LOWERCASE_A: "a",
              CHAR_UPPERCASE_Z: "Z",
              CHAR_LOWERCASE_Z: "z",
              CHAR_LEFT_PARENTHESES: "(",
              CHAR_RIGHT_PARENTHESES: ")",
              CHAR_ASTERISK: "*",
              CHAR_AMPERSAND: "&",
              CHAR_AT: "@",
              CHAR_BACKSLASH: "\\",
              CHAR_BACKTICK: "`",
              CHAR_CARRIAGE_RETURN: "\r",
              CHAR_CIRCUMFLEX_ACCENT: "^",
              CHAR_COLON: ":",
              CHAR_COMMA: ",",
              CHAR_DOLLAR: "$",
              CHAR_DOT: ".",
              CHAR_DOUBLE_QUOTE: '"',
              CHAR_EQUAL: "=",
              CHAR_EXCLAMATION_MARK: "!",
              CHAR_FORM_FEED: "\f",
              CHAR_FORWARD_SLASH: "/",
              CHAR_HASH: "#",
              CHAR_HYPHEN_MINUS: "-",
              CHAR_LEFT_ANGLE_BRACKET: "<",
              CHAR_LEFT_CURLY_BRACE: "{",
              CHAR_LEFT_SQUARE_BRACKET: "[",
              CHAR_LINE_FEED: "\n",
              CHAR_NO_BREAK_SPACE: "\xA0",
              CHAR_PERCENT: "%",
              CHAR_PLUS: "+",
              CHAR_QUESTION_MARK: "?",
              CHAR_RIGHT_ANGLE_BRACKET: ">",
              CHAR_RIGHT_CURLY_BRACE: "}",
              CHAR_RIGHT_SQUARE_BRACKET: "]",
              CHAR_SEMICOLON: ";",
              CHAR_SINGLE_QUOTE: "'",
              CHAR_SPACE: " ",
              CHAR_TAB: "	",
              CHAR_UNDERSCORE: "_",
              CHAR_VERTICAL_LINE: "|",
              CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
            };
          }
        });
        var require_parse = __commonJS22({
          "node_modules/braces/lib/parse.js"(exports22, module22) {
            "use strict";
            var stringify2 = require_stringify222();
            var {
              MAX_LENGTH,
              CHAR_BACKSLASH,
              CHAR_BACKTICK,
              CHAR_COMMA,
              CHAR_DOT,
              CHAR_LEFT_PARENTHESES,
              CHAR_RIGHT_PARENTHESES,
              CHAR_LEFT_CURLY_BRACE,
              CHAR_RIGHT_CURLY_BRACE,
              CHAR_LEFT_SQUARE_BRACKET,
              CHAR_RIGHT_SQUARE_BRACKET,
              CHAR_DOUBLE_QUOTE,
              CHAR_SINGLE_QUOTE,
              CHAR_NO_BREAK_SPACE,
              CHAR_ZERO_WIDTH_NOBREAK_SPACE
            } = require_constants();
            var parse = (input, options = {}) => {
              if (typeof input !== "string") {
                throw new TypeError("Expected a string");
              }
              let opts = options || {};
              let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
              if (input.length > max) {
                throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
              }
              let ast = { type: "root", input, nodes: [] };
              let stack = [ast];
              let block = ast;
              let prev = ast;
              let brackets = 0;
              let length = input.length;
              let index = 0;
              let depth = 0;
              let value;
              let memo = {};
              const advance = () => input[index++];
              const push = (node) => {
                if (node.type === "text" && prev.type === "dot") {
                  prev.type = "text";
                }
                if (prev && prev.type === "text" && node.type === "text") {
                  prev.value += node.value;
                  return;
                }
                block.nodes.push(node);
                node.parent = block;
                node.prev = prev;
                prev = node;
                return node;
              };
              push({ type: "bos" });
              while (index < length) {
                block = stack[stack.length - 1];
                value = advance();
                if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
                  continue;
                }
                if (value === CHAR_BACKSLASH) {
                  push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
                  continue;
                }
                if (value === CHAR_RIGHT_SQUARE_BRACKET) {
                  push({ type: "text", value: "\\" + value });
                  continue;
                }
                if (value === CHAR_LEFT_SQUARE_BRACKET) {
                  brackets++;
                  let closed = true;
                  let next;
                  while (index < length && (next = advance())) {
                    value += next;
                    if (next === CHAR_LEFT_SQUARE_BRACKET) {
                      brackets++;
                      continue;
                    }
                    if (next === CHAR_BACKSLASH) {
                      value += advance();
                      continue;
                    }
                    if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                      brackets--;
                      if (brackets === 0) {
                        break;
                      }
                    }
                  }
                  push({ type: "text", value });
                  continue;
                }
                if (value === CHAR_LEFT_PARENTHESES) {
                  block = push({ type: "paren", nodes: [] });
                  stack.push(block);
                  push({ type: "text", value });
                  continue;
                }
                if (value === CHAR_RIGHT_PARENTHESES) {
                  if (block.type !== "paren") {
                    push({ type: "text", value });
                    continue;
                  }
                  block = stack.pop();
                  push({ type: "text", value });
                  block = stack[stack.length - 1];
                  continue;
                }
                if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
                  let open = value;
                  let next;
                  if (options.keepQuotes !== true) {
                    value = "";
                  }
                  while (index < length && (next = advance())) {
                    if (next === CHAR_BACKSLASH) {
                      value += next + advance();
                      continue;
                    }
                    if (next === open) {
                      if (options.keepQuotes === true)
                        value += next;
                      break;
                    }
                    value += next;
                  }
                  push({ type: "text", value });
                  continue;
                }
                if (value === CHAR_LEFT_CURLY_BRACE) {
                  depth++;
                  let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
                  let brace = {
                    type: "brace",
                    open: true,
                    close: false,
                    dollar,
                    depth,
                    commas: 0,
                    ranges: 0,
                    nodes: []
                  };
                  block = push(brace);
                  stack.push(block);
                  push({ type: "open", value });
                  continue;
                }
                if (value === CHAR_RIGHT_CURLY_BRACE) {
                  if (block.type !== "brace") {
                    push({ type: "text", value });
                    continue;
                  }
                  let type = "close";
                  block = stack.pop();
                  block.close = true;
                  push({ type, value });
                  depth--;
                  block = stack[stack.length - 1];
                  continue;
                }
                if (value === CHAR_COMMA && depth > 0) {
                  if (block.ranges > 0) {
                    block.ranges = 0;
                    let open = block.nodes.shift();
                    block.nodes = [open, { type: "text", value: stringify2(block) }];
                  }
                  push({ type: "comma", value });
                  block.commas++;
                  continue;
                }
                if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
                  let siblings = block.nodes;
                  if (depth === 0 || siblings.length === 0) {
                    push({ type: "text", value });
                    continue;
                  }
                  if (prev.type === "dot") {
                    block.range = [];
                    prev.value += value;
                    prev.type = "range";
                    if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                      block.invalid = true;
                      block.ranges = 0;
                      prev.type = "text";
                      continue;
                    }
                    block.ranges++;
                    block.args = [];
                    continue;
                  }
                  if (prev.type === "range") {
                    siblings.pop();
                    let before = siblings[siblings.length - 1];
                    before.value += prev.value + value;
                    prev = before;
                    block.ranges--;
                    continue;
                  }
                  push({ type: "dot", value });
                  continue;
                }
                push({ type: "text", value });
              }
              do {
                block = stack.pop();
                if (block.type !== "root") {
                  block.nodes.forEach((node) => {
                    if (!node.nodes) {
                      if (node.type === "open")
                        node.isOpen = true;
                      if (node.type === "close")
                        node.isClose = true;
                      if (!node.nodes)
                        node.type = "text";
                      node.invalid = true;
                    }
                  });
                  let parent = stack[stack.length - 1];
                  let index2 = parent.nodes.indexOf(block);
                  parent.nodes.splice(index2, 1, ...block.nodes);
                }
              } while (stack.length > 0);
              push({ type: "eos" });
              return ast;
            };
            module22.exports = parse;
          }
        });
        var require_braces = __commonJS22({
          "node_modules/braces/index.js"(exports22, module22) {
            "use strict";
            var stringify2 = require_stringify222();
            var compile = require_compile();
            var expand = require_expand();
            var parse = require_parse();
            var braces = (input, options = {}) => {
              let output = [];
              if (Array.isArray(input)) {
                for (let pattern of input) {
                  let result = braces.create(pattern, options);
                  if (Array.isArray(result)) {
                    output.push(...result);
                  } else {
                    output.push(result);
                  }
                }
              } else {
                output = [].concat(braces.create(input, options));
              }
              if (options && options.expand === true && options.nodupes === true) {
                output = [...new Set(output)];
              }
              return output;
            };
            braces.parse = (input, options = {}) => parse(input, options);
            braces.stringify = (input, options = {}) => {
              if (typeof input === "string") {
                return stringify2(braces.parse(input, options), options);
              }
              return stringify2(input, options);
            };
            braces.compile = (input, options = {}) => {
              if (typeof input === "string") {
                input = braces.parse(input, options);
              }
              return compile(input, options);
            };
            braces.expand = (input, options = {}) => {
              if (typeof input === "string") {
                input = braces.parse(input, options);
              }
              let result = expand(input, options);
              if (options.noempty === true) {
                result = result.filter(Boolean);
              }
              if (options.nodupes === true) {
                result = [...new Set(result)];
              }
              return result;
            };
            braces.create = (input, options = {}) => {
              if (input === "" || input.length < 3) {
                return [input];
              }
              return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
            };
            module22.exports = braces;
          }
        });
        var require_constants2 = __commonJS22({
          "node_modules/picomatch/lib/constants.js"(exports22, module22) {
            "use strict";
            var path7 = require("path");
            var WIN_SLASH = "\\\\/";
            var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
            var DOT_LITERAL = "\\.";
            var PLUS_LITERAL = "\\+";
            var QMARK_LITERAL = "\\?";
            var SLASH_LITERAL = "\\/";
            var ONE_CHAR = "(?=.)";
            var QMARK = "[^/]";
            var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
            var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
            var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
            var NO_DOT = `(?!${DOT_LITERAL})`;
            var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
            var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
            var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
            var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
            var STAR = `${QMARK}*?`;
            var POSIX_CHARS = {
              DOT_LITERAL,
              PLUS_LITERAL,
              QMARK_LITERAL,
              SLASH_LITERAL,
              ONE_CHAR,
              QMARK,
              END_ANCHOR,
              DOTS_SLASH,
              NO_DOT,
              NO_DOTS,
              NO_DOT_SLASH,
              NO_DOTS_SLASH,
              QMARK_NO_DOT,
              STAR,
              START_ANCHOR
            };
            var WINDOWS_CHARS = __spreadProps2(__spreadValues2({}, POSIX_CHARS), {
              SLASH_LITERAL: `[${WIN_SLASH}]`,
              QMARK: WIN_NO_SLASH,
              STAR: `${WIN_NO_SLASH}*?`,
              DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
              NO_DOT: `(?!${DOT_LITERAL})`,
              NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
              NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
              NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
              QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
              START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
              END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
            });
            var POSIX_REGEX_SOURCE = {
              alnum: "a-zA-Z0-9",
              alpha: "a-zA-Z",
              ascii: "\\x00-\\x7F",
              blank: " \\t",
              cntrl: "\\x00-\\x1F\\x7F",
              digit: "0-9",
              graph: "\\x21-\\x7E",
              lower: "a-z",
              print: "\\x20-\\x7E ",
              punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
              space: " \\t\\r\\n\\v\\f",
              upper: "A-Z",
              word: "A-Za-z0-9_",
              xdigit: "A-Fa-f0-9"
            };
            module22.exports = {
              MAX_LENGTH: 1024 * 64,
              POSIX_REGEX_SOURCE,
              REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
              REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
              REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
              REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
              REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
              REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
              REPLACEMENTS: {
                "***": "*",
                "**/**": "**",
                "**/**/**": "**"
              },
              CHAR_0: 48,
              CHAR_9: 57,
              CHAR_UPPERCASE_A: 65,
              CHAR_LOWERCASE_A: 97,
              CHAR_UPPERCASE_Z: 90,
              CHAR_LOWERCASE_Z: 122,
              CHAR_LEFT_PARENTHESES: 40,
              CHAR_RIGHT_PARENTHESES: 41,
              CHAR_ASTERISK: 42,
              CHAR_AMPERSAND: 38,
              CHAR_AT: 64,
              CHAR_BACKWARD_SLASH: 92,
              CHAR_CARRIAGE_RETURN: 13,
              CHAR_CIRCUMFLEX_ACCENT: 94,
              CHAR_COLON: 58,
              CHAR_COMMA: 44,
              CHAR_DOT: 46,
              CHAR_DOUBLE_QUOTE: 34,
              CHAR_EQUAL: 61,
              CHAR_EXCLAMATION_MARK: 33,
              CHAR_FORM_FEED: 12,
              CHAR_FORWARD_SLASH: 47,
              CHAR_GRAVE_ACCENT: 96,
              CHAR_HASH: 35,
              CHAR_HYPHEN_MINUS: 45,
              CHAR_LEFT_ANGLE_BRACKET: 60,
              CHAR_LEFT_CURLY_BRACE: 123,
              CHAR_LEFT_SQUARE_BRACKET: 91,
              CHAR_LINE_FEED: 10,
              CHAR_NO_BREAK_SPACE: 160,
              CHAR_PERCENT: 37,
              CHAR_PLUS: 43,
              CHAR_QUESTION_MARK: 63,
              CHAR_RIGHT_ANGLE_BRACKET: 62,
              CHAR_RIGHT_CURLY_BRACE: 125,
              CHAR_RIGHT_SQUARE_BRACKET: 93,
              CHAR_SEMICOLON: 59,
              CHAR_SINGLE_QUOTE: 39,
              CHAR_SPACE: 32,
              CHAR_TAB: 9,
              CHAR_UNDERSCORE: 95,
              CHAR_VERTICAL_LINE: 124,
              CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
              SEP: path7.sep,
              extglobChars(chars) {
                return {
                  "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
                  "?": { type: "qmark", open: "(?:", close: ")?" },
                  "+": { type: "plus", open: "(?:", close: ")+" },
                  "*": { type: "star", open: "(?:", close: ")*" },
                  "@": { type: "at", open: "(?:", close: ")" }
                };
              },
              globChars(win32) {
                return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
              }
            };
          }
        });
        var require_utils4 = __commonJS22({
          "node_modules/picomatch/lib/utils.js"(exports22) {
            "use strict";
            var path7 = require("path");
            var win32 = process.platform === "win32";
            var {
              REGEX_BACKSLASH,
              REGEX_REMOVE_BACKSLASH,
              REGEX_SPECIAL_CHARS,
              REGEX_SPECIAL_CHARS_GLOBAL
            } = require_constants2();
            exports22.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
            exports22.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
            exports22.isRegexChar = (str) => str.length === 1 && exports22.hasRegexChars(str);
            exports22.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
            exports22.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
            exports22.removeBackslashes = (str) => {
              return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
                return match === "\\" ? "" : match;
              });
            };
            exports22.supportsLookbehinds = () => {
              const segs = process.version.slice(1).split(".").map(Number);
              if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
                return true;
              }
              return false;
            };
            exports22.isWindows = (options) => {
              if (options && typeof options.windows === "boolean") {
                return options.windows;
              }
              return win32 === true || path7.sep === "\\";
            };
            exports22.escapeLast = (input, char, lastIdx) => {
              const idx = input.lastIndexOf(char, lastIdx);
              if (idx === -1)
                return input;
              if (input[idx - 1] === "\\")
                return exports22.escapeLast(input, char, idx - 1);
              return `${input.slice(0, idx)}\\${input.slice(idx)}`;
            };
            exports22.removePrefix = (input, state = {}) => {
              let output = input;
              if (output.startsWith("./")) {
                output = output.slice(2);
                state.prefix = "./";
              }
              return output;
            };
            exports22.wrapOutput = (input, state = {}, options = {}) => {
              const prepend = options.contains ? "" : "^";
              const append = options.contains ? "" : "$";
              let output = `${prepend}(?:${input})${append}`;
              if (state.negated === true) {
                output = `(?:^(?!${output}).*$)`;
              }
              return output;
            };
          }
        });
        var require_scan = __commonJS22({
          "node_modules/picomatch/lib/scan.js"(exports22, module22) {
            "use strict";
            var utils = require_utils4();
            var {
              CHAR_ASTERISK,
              CHAR_AT,
              CHAR_BACKWARD_SLASH,
              CHAR_COMMA,
              CHAR_DOT,
              CHAR_EXCLAMATION_MARK,
              CHAR_FORWARD_SLASH,
              CHAR_LEFT_CURLY_BRACE,
              CHAR_LEFT_PARENTHESES,
              CHAR_LEFT_SQUARE_BRACKET,
              CHAR_PLUS,
              CHAR_QUESTION_MARK,
              CHAR_RIGHT_CURLY_BRACE,
              CHAR_RIGHT_PARENTHESES,
              CHAR_RIGHT_SQUARE_BRACKET
            } = require_constants2();
            var isPathSeparator = (code) => {
              return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
            };
            var depth = (token) => {
              if (token.isPrefix !== true) {
                token.depth = token.isGlobstar ? Infinity : 1;
              }
            };
            var scan = (input, options) => {
              const opts = options || {};
              const length = input.length - 1;
              const scanToEnd = opts.parts === true || opts.scanToEnd === true;
              const slashes = [];
              const tokens = [];
              const parts = [];
              let str = input;
              let index = -1;
              let start = 0;
              let lastIndex = 0;
              let isBrace = false;
              let isBracket = false;
              let isGlob = false;
              let isExtglob = false;
              let isGlobstar = false;
              let braceEscaped = false;
              let backslashes = false;
              let negated = false;
              let negatedExtglob = false;
              let finished = false;
              let braces = 0;
              let prev;
              let code;
              let token = { value: "", depth: 0, isGlob: false };
              const eos = () => index >= length;
              const peek = () => str.charCodeAt(index + 1);
              const advance = () => {
                prev = code;
                return str.charCodeAt(++index);
              };
              while (index < length) {
                code = advance();
                let next;
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  if (code === CHAR_LEFT_CURLY_BRACE) {
                    braceEscaped = true;
                  }
                  continue;
                }
                if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
                  braces++;
                  while (eos() !== true && (code = advance())) {
                    if (code === CHAR_BACKWARD_SLASH) {
                      backslashes = token.backslashes = true;
                      advance();
                      continue;
                    }
                    if (code === CHAR_LEFT_CURLY_BRACE) {
                      braces++;
                      continue;
                    }
                    if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                      isBrace = token.isBrace = true;
                      isGlob = token.isGlob = true;
                      finished = true;
                      if (scanToEnd === true) {
                        continue;
                      }
                      break;
                    }
                    if (braceEscaped !== true && code === CHAR_COMMA) {
                      isBrace = token.isBrace = true;
                      isGlob = token.isGlob = true;
                      finished = true;
                      if (scanToEnd === true) {
                        continue;
                      }
                      break;
                    }
                    if (code === CHAR_RIGHT_CURLY_BRACE) {
                      braces--;
                      if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                      }
                    }
                  }
                  if (scanToEnd === true) {
                    continue;
                  }
                  break;
                }
                if (code === CHAR_FORWARD_SLASH) {
                  slashes.push(index);
                  tokens.push(token);
                  token = { value: "", depth: 0, isGlob: false };
                  if (finished === true)
                    continue;
                  if (prev === CHAR_DOT && index === start + 1) {
                    start += 2;
                    continue;
                  }
                  lastIndex = index + 1;
                  continue;
                }
                if (opts.noext !== true) {
                  const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
                  if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    isExtglob = token.isExtglob = true;
                    finished = true;
                    if (code === CHAR_EXCLAMATION_MARK && index === start) {
                      negatedExtglob = true;
                    }
                    if (scanToEnd === true) {
                      while (eos() !== true && (code = advance())) {
                        if (code === CHAR_BACKWARD_SLASH) {
                          backslashes = token.backslashes = true;
                          code = advance();
                          continue;
                        }
                        if (code === CHAR_RIGHT_PARENTHESES) {
                          isGlob = token.isGlob = true;
                          finished = true;
                          break;
                        }
                      }
                      continue;
                    }
                    break;
                  }
                }
                if (code === CHAR_ASTERISK) {
                  if (prev === CHAR_ASTERISK)
                    isGlobstar = token.isGlobstar = true;
                  isGlob = token.isGlob = true;
                  finished = true;
                  if (scanToEnd === true) {
                    continue;
                  }
                  break;
                }
                if (code === CHAR_QUESTION_MARK) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  if (scanToEnd === true) {
                    continue;
                  }
                  break;
                }
                if (code === CHAR_LEFT_SQUARE_BRACKET) {
                  while (eos() !== true && (next = advance())) {
                    if (next === CHAR_BACKWARD_SLASH) {
                      backslashes = token.backslashes = true;
                      advance();
                      continue;
                    }
                    if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                      isBracket = token.isBracket = true;
                      isGlob = token.isGlob = true;
                      finished = true;
                      break;
                    }
                  }
                  if (scanToEnd === true) {
                    continue;
                  }
                  break;
                }
                if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
                  negated = token.negated = true;
                  start++;
                  continue;
                }
                if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  if (scanToEnd === true) {
                    while (eos() !== true && (code = advance())) {
                      if (code === CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                      }
                      if (code === CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                      }
                    }
                    continue;
                  }
                  break;
                }
                if (isGlob === true) {
                  finished = true;
                  if (scanToEnd === true) {
                    continue;
                  }
                  break;
                }
              }
              if (opts.noext === true) {
                isExtglob = false;
                isGlob = false;
              }
              let base = str;
              let prefix = "";
              let glob = "";
              if (start > 0) {
                prefix = str.slice(0, start);
                str = str.slice(start);
                lastIndex -= start;
              }
              if (base && isGlob === true && lastIndex > 0) {
                base = str.slice(0, lastIndex);
                glob = str.slice(lastIndex);
              } else if (isGlob === true) {
                base = "";
                glob = str;
              } else {
                base = str;
              }
              if (base && base !== "" && base !== "/" && base !== str) {
                if (isPathSeparator(base.charCodeAt(base.length - 1))) {
                  base = base.slice(0, -1);
                }
              }
              if (opts.unescape === true) {
                if (glob)
                  glob = utils.removeBackslashes(glob);
                if (base && backslashes === true) {
                  base = utils.removeBackslashes(base);
                }
              }
              const state = {
                prefix,
                input,
                start,
                base,
                glob,
                isBrace,
                isBracket,
                isGlob,
                isExtglob,
                isGlobstar,
                negated,
                negatedExtglob
              };
              if (opts.tokens === true) {
                state.maxDepth = 0;
                if (!isPathSeparator(code)) {
                  tokens.push(token);
                }
                state.tokens = tokens;
              }
              if (opts.parts === true || opts.tokens === true) {
                let prevIndex;
                for (let idx = 0; idx < slashes.length; idx++) {
                  const n = prevIndex ? prevIndex + 1 : start;
                  const i = slashes[idx];
                  const value = input.slice(n, i);
                  if (opts.tokens) {
                    if (idx === 0 && start !== 0) {
                      tokens[idx].isPrefix = true;
                      tokens[idx].value = prefix;
                    } else {
                      tokens[idx].value = value;
                    }
                    depth(tokens[idx]);
                    state.maxDepth += tokens[idx].depth;
                  }
                  if (idx !== 0 || value !== "") {
                    parts.push(value);
                  }
                  prevIndex = i;
                }
                if (prevIndex && prevIndex + 1 < input.length) {
                  const value = input.slice(prevIndex + 1);
                  parts.push(value);
                  if (opts.tokens) {
                    tokens[tokens.length - 1].value = value;
                    depth(tokens[tokens.length - 1]);
                    state.maxDepth += tokens[tokens.length - 1].depth;
                  }
                }
                state.slashes = slashes;
                state.parts = parts;
              }
              return state;
            };
            module22.exports = scan;
          }
        });
        var require_parse2 = __commonJS22({
          "node_modules/picomatch/lib/parse.js"(exports22, module22) {
            "use strict";
            var constants2 = require_constants2();
            var utils = require_utils4();
            var {
              MAX_LENGTH,
              POSIX_REGEX_SOURCE,
              REGEX_NON_SPECIAL_CHARS,
              REGEX_SPECIAL_CHARS_BACKREF,
              REPLACEMENTS
            } = constants2;
            var expandRange = (args, options) => {
              if (typeof options.expandRange === "function") {
                return options.expandRange(...args, options);
              }
              args.sort();
              const value = `[${args.join("-")}]`;
              try {
                new RegExp(value);
              } catch (ex) {
                return args.map((v) => utils.escapeRegex(v)).join("..");
              }
              return value;
            };
            var syntaxError = (type, char) => {
              return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
            };
            var parse = (input, options) => {
              if (typeof input !== "string") {
                throw new TypeError("Expected a string");
              }
              input = REPLACEMENTS[input] || input;
              const opts = __spreadValues2({}, options);
              const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
              let len = input.length;
              if (len > max) {
                throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
              }
              const bos = { type: "bos", value: "", output: opts.prepend || "" };
              const tokens = [bos];
              const capture = opts.capture ? "" : "?:";
              const win32 = utils.isWindows(options);
              const PLATFORM_CHARS = constants2.globChars(win32);
              const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
              const {
                DOT_LITERAL,
                PLUS_LITERAL,
                SLASH_LITERAL,
                ONE_CHAR,
                DOTS_SLASH,
                NO_DOT,
                NO_DOT_SLASH,
                NO_DOTS_SLASH,
                QMARK,
                QMARK_NO_DOT,
                STAR,
                START_ANCHOR
              } = PLATFORM_CHARS;
              const globstar = (opts2) => {
                return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
              };
              const nodot = opts.dot ? "" : NO_DOT;
              const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
              let star = opts.bash === true ? globstar(opts) : STAR;
              if (opts.capture) {
                star = `(${star})`;
              }
              if (typeof opts.noext === "boolean") {
                opts.noextglob = opts.noext;
              }
              const state = {
                input,
                index: -1,
                start: 0,
                dot: opts.dot === true,
                consumed: "",
                output: "",
                prefix: "",
                backtrack: false,
                negated: false,
                brackets: 0,
                braces: 0,
                parens: 0,
                quotes: 0,
                globstar: false,
                tokens
              };
              input = utils.removePrefix(input, state);
              len = input.length;
              const extglobs = [];
              const braces = [];
              const stack = [];
              let prev = bos;
              let value;
              const eos = () => state.index === len - 1;
              const peek = state.peek = (n = 1) => input[state.index + n];
              const advance = state.advance = () => input[++state.index] || "";
              const remaining = () => input.slice(state.index + 1);
              const consume = (value2 = "", num = 0) => {
                state.consumed += value2;
                state.index += num;
              };
              const append = (token) => {
                state.output += token.output != null ? token.output : token.value;
                consume(token.value);
              };
              const negate = () => {
                let count = 1;
                while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
                  advance();
                  state.start++;
                  count++;
                }
                if (count % 2 === 0) {
                  return false;
                }
                state.negated = true;
                state.start++;
                return true;
              };
              const increment = (type) => {
                state[type]++;
                stack.push(type);
              };
              const decrement = (type) => {
                state[type]--;
                stack.pop();
              };
              const push = (tok) => {
                if (prev.type === "globstar") {
                  const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
                  const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
                  if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
                    state.output = state.output.slice(0, -prev.output.length);
                    prev.type = "star";
                    prev.value = "*";
                    prev.output = star;
                    state.output += prev.output;
                  }
                }
                if (extglobs.length && tok.type !== "paren") {
                  extglobs[extglobs.length - 1].inner += tok.value;
                }
                if (tok.value || tok.output)
                  append(tok);
                if (prev && prev.type === "text" && tok.type === "text") {
                  prev.value += tok.value;
                  prev.output = (prev.output || "") + tok.value;
                  return;
                }
                tok.prev = prev;
                tokens.push(tok);
                prev = tok;
              };
              const extglobOpen = (type, value2) => {
                const token = __spreadProps2(__spreadValues2({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
                token.prev = prev;
                token.parens = state.parens;
                token.output = state.output;
                const output = (opts.capture ? "(" : "") + token.open;
                increment("parens");
                push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
                push({ type: "paren", extglob: true, value: advance(), output });
                extglobs.push(token);
              };
              const extglobClose = (token) => {
                let output = token.close + (opts.capture ? ")" : "");
                let rest;
                if (token.type === "negate") {
                  let extglobStar = star;
                  if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
                    extglobStar = globstar(opts);
                  }
                  if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
                    output = token.close = `)$))${extglobStar}`;
                  }
                  if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                    output = token.close = `)${rest})${extglobStar})`;
                  }
                  if (token.prev.type === "bos") {
                    state.negatedExtglob = true;
                  }
                }
                push({ type: "paren", extglob: true, value, output });
                decrement("parens");
              };
              if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
                let backslashes = false;
                let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
                  if (first === "\\") {
                    backslashes = true;
                    return m;
                  }
                  if (first === "?") {
                    if (esc) {
                      return esc + first + (rest ? QMARK.repeat(rest.length) : "");
                    }
                    if (index === 0) {
                      return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
                    }
                    return QMARK.repeat(chars.length);
                  }
                  if (first === ".") {
                    return DOT_LITERAL.repeat(chars.length);
                  }
                  if (first === "*") {
                    if (esc) {
                      return esc + first + (rest ? star : "");
                    }
                    return star;
                  }
                  return esc ? m : `\\${m}`;
                });
                if (backslashes === true) {
                  if (opts.unescape === true) {
                    output = output.replace(/\\/g, "");
                  } else {
                    output = output.replace(/\\+/g, (m) => {
                      return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
                    });
                  }
                }
                if (output === input && opts.contains === true) {
                  state.output = input;
                  return state;
                }
                state.output = utils.wrapOutput(output, state, options);
                return state;
              }
              while (!eos()) {
                value = advance();
                if (value === "\0") {
                  continue;
                }
                if (value === "\\") {
                  const next = peek();
                  if (next === "/" && opts.bash !== true) {
                    continue;
                  }
                  if (next === "." || next === ";") {
                    continue;
                  }
                  if (!next) {
                    value += "\\";
                    push({ type: "text", value });
                    continue;
                  }
                  const match = /^\\+/.exec(remaining());
                  let slashes = 0;
                  if (match && match[0].length > 2) {
                    slashes = match[0].length;
                    state.index += slashes;
                    if (slashes % 2 !== 0) {
                      value += "\\";
                    }
                  }
                  if (opts.unescape === true) {
                    value = advance();
                  } else {
                    value += advance();
                  }
                  if (state.brackets === 0) {
                    push({ type: "text", value });
                    continue;
                  }
                }
                if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
                  if (opts.posix !== false && value === ":") {
                    const inner = prev.value.slice(1);
                    if (inner.includes("[")) {
                      prev.posix = true;
                      if (inner.includes(":")) {
                        const idx = prev.value.lastIndexOf("[");
                        const pre = prev.value.slice(0, idx);
                        const rest2 = prev.value.slice(idx + 2);
                        const posix = POSIX_REGEX_SOURCE[rest2];
                        if (posix) {
                          prev.value = pre + posix;
                          state.backtrack = true;
                          advance();
                          if (!bos.output && tokens.indexOf(prev) === 1) {
                            bos.output = ONE_CHAR;
                          }
                          continue;
                        }
                      }
                    }
                  }
                  if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
                    value = `\\${value}`;
                  }
                  if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
                    value = `\\${value}`;
                  }
                  if (opts.posix === true && value === "!" && prev.value === "[") {
                    value = "^";
                  }
                  prev.value += value;
                  append({ value });
                  continue;
                }
                if (state.quotes === 1 && value !== '"') {
                  value = utils.escapeRegex(value);
                  prev.value += value;
                  append({ value });
                  continue;
                }
                if (value === '"') {
                  state.quotes = state.quotes === 1 ? 0 : 1;
                  if (opts.keepQuotes === true) {
                    push({ type: "text", value });
                  }
                  continue;
                }
                if (value === "(") {
                  increment("parens");
                  push({ type: "paren", value });
                  continue;
                }
                if (value === ")") {
                  if (state.parens === 0 && opts.strictBrackets === true) {
                    throw new SyntaxError(syntaxError("opening", "("));
                  }
                  const extglob = extglobs[extglobs.length - 1];
                  if (extglob && state.parens === extglob.parens + 1) {
                    extglobClose(extglobs.pop());
                    continue;
                  }
                  push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
                  decrement("parens");
                  continue;
                }
                if (value === "[") {
                  if (opts.nobracket === true || !remaining().includes("]")) {
                    if (opts.nobracket !== true && opts.strictBrackets === true) {
                      throw new SyntaxError(syntaxError("closing", "]"));
                    }
                    value = `\\${value}`;
                  } else {
                    increment("brackets");
                  }
                  push({ type: "bracket", value });
                  continue;
                }
                if (value === "]") {
                  if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
                    push({ type: "text", value, output: `\\${value}` });
                    continue;
                  }
                  if (state.brackets === 0) {
                    if (opts.strictBrackets === true) {
                      throw new SyntaxError(syntaxError("opening", "["));
                    }
                    push({ type: "text", value, output: `\\${value}` });
                    continue;
                  }
                  decrement("brackets");
                  const prevValue = prev.value.slice(1);
                  if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
                    value = `/${value}`;
                  }
                  prev.value += value;
                  append({ value });
                  if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
                    continue;
                  }
                  const escaped = utils.escapeRegex(prev.value);
                  state.output = state.output.slice(0, -prev.value.length);
                  if (opts.literalBrackets === true) {
                    state.output += escaped;
                    prev.value = escaped;
                    continue;
                  }
                  prev.value = `(${capture}${escaped}|${prev.value})`;
                  state.output += prev.value;
                  continue;
                }
                if (value === "{" && opts.nobrace !== true) {
                  increment("braces");
                  const open = {
                    type: "brace",
                    value,
                    output: "(",
                    outputIndex: state.output.length,
                    tokensIndex: state.tokens.length
                  };
                  braces.push(open);
                  push(open);
                  continue;
                }
                if (value === "}") {
                  const brace = braces[braces.length - 1];
                  if (opts.nobrace === true || !brace) {
                    push({ type: "text", value, output: value });
                    continue;
                  }
                  let output = ")";
                  if (brace.dots === true) {
                    const arr = tokens.slice();
                    const range = [];
                    for (let i = arr.length - 1; i >= 0; i--) {
                      tokens.pop();
                      if (arr[i].type === "brace") {
                        break;
                      }
                      if (arr[i].type !== "dots") {
                        range.unshift(arr[i].value);
                      }
                    }
                    output = expandRange(range, opts);
                    state.backtrack = true;
                  }
                  if (brace.comma !== true && brace.dots !== true) {
                    const out = state.output.slice(0, brace.outputIndex);
                    const toks = state.tokens.slice(brace.tokensIndex);
                    brace.value = brace.output = "\\{";
                    value = output = "\\}";
                    state.output = out;
                    for (const t of toks) {
                      state.output += t.output || t.value;
                    }
                  }
                  push({ type: "brace", value, output });
                  decrement("braces");
                  braces.pop();
                  continue;
                }
                if (value === "|") {
                  if (extglobs.length > 0) {
                    extglobs[extglobs.length - 1].conditions++;
                  }
                  push({ type: "text", value });
                  continue;
                }
                if (value === ",") {
                  let output = value;
                  const brace = braces[braces.length - 1];
                  if (brace && stack[stack.length - 1] === "braces") {
                    brace.comma = true;
                    output = "|";
                  }
                  push({ type: "comma", value, output });
                  continue;
                }
                if (value === "/") {
                  if (prev.type === "dot" && state.index === state.start + 1) {
                    state.start = state.index + 1;
                    state.consumed = "";
                    state.output = "";
                    tokens.pop();
                    prev = bos;
                    continue;
                  }
                  push({ type: "slash", value, output: SLASH_LITERAL });
                  continue;
                }
                if (value === ".") {
                  if (state.braces > 0 && prev.type === "dot") {
                    if (prev.value === ".")
                      prev.output = DOT_LITERAL;
                    const brace = braces[braces.length - 1];
                    prev.type = "dots";
                    prev.output += value;
                    prev.value += value;
                    brace.dots = true;
                    continue;
                  }
                  if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
                    push({ type: "text", value, output: DOT_LITERAL });
                    continue;
                  }
                  push({ type: "dot", value, output: DOT_LITERAL });
                  continue;
                }
                if (value === "?") {
                  const isGroup = prev && prev.value === "(";
                  if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                    extglobOpen("qmark", value);
                    continue;
                  }
                  if (prev && prev.type === "paren") {
                    const next = peek();
                    let output = value;
                    if (next === "<" && !utils.supportsLookbehinds()) {
                      throw new Error("Node.js v10 or higher is required for regex lookbehinds");
                    }
                    if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                      output = `\\${value}`;
                    }
                    push({ type: "text", value, output });
                    continue;
                  }
                  if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
                    push({ type: "qmark", value, output: QMARK_NO_DOT });
                    continue;
                  }
                  push({ type: "qmark", value, output: QMARK });
                  continue;
                }
                if (value === "!") {
                  if (opts.noextglob !== true && peek() === "(") {
                    if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                      extglobOpen("negate", value);
                      continue;
                    }
                  }
                  if (opts.nonegate !== true && state.index === 0) {
                    negate();
                    continue;
                  }
                }
                if (value === "+") {
                  if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                    extglobOpen("plus", value);
                    continue;
                  }
                  if (prev && prev.value === "(" || opts.regex === false) {
                    push({ type: "plus", value, output: PLUS_LITERAL });
                    continue;
                  }
                  if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
                    push({ type: "plus", value });
                    continue;
                  }
                  push({ type: "plus", value: PLUS_LITERAL });
                  continue;
                }
                if (value === "@") {
                  if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                    push({ type: "at", extglob: true, value, output: "" });
                    continue;
                  }
                  push({ type: "text", value });
                  continue;
                }
                if (value !== "*") {
                  if (value === "$" || value === "^") {
                    value = `\\${value}`;
                  }
                  const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
                  if (match) {
                    value += match[0];
                    state.index += match[0].length;
                  }
                  push({ type: "text", value });
                  continue;
                }
                if (prev && (prev.type === "globstar" || prev.star === true)) {
                  prev.type = "star";
                  prev.star = true;
                  prev.value += value;
                  prev.output = star;
                  state.backtrack = true;
                  state.globstar = true;
                  consume(value);
                  continue;
                }
                let rest = remaining();
                if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
                  extglobOpen("star", value);
                  continue;
                }
                if (prev.type === "star") {
                  if (opts.noglobstar === true) {
                    consume(value);
                    continue;
                  }
                  const prior = prev.prev;
                  const before = prior.prev;
                  const isStart = prior.type === "slash" || prior.type === "bos";
                  const afterStar = before && (before.type === "star" || before.type === "globstar");
                  if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
                    push({ type: "star", value, output: "" });
                    continue;
                  }
                  const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
                  const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
                  if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
                    push({ type: "star", value, output: "" });
                    continue;
                  }
                  while (rest.slice(0, 3) === "/**") {
                    const after = input[state.index + 4];
                    if (after && after !== "/") {
                      break;
                    }
                    rest = rest.slice(3);
                    consume("/**", 3);
                  }
                  if (prior.type === "bos" && eos()) {
                    prev.type = "globstar";
                    prev.value += value;
                    prev.output = globstar(opts);
                    state.output = prev.output;
                    state.globstar = true;
                    consume(value);
                    continue;
                  }
                  if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
                    state.output = state.output.slice(0, -(prior.output + prev.output).length);
                    prior.output = `(?:${prior.output}`;
                    prev.type = "globstar";
                    prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
                    prev.value += value;
                    state.globstar = true;
                    state.output += prior.output + prev.output;
                    consume(value);
                    continue;
                  }
                  if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
                    const end = rest[1] !== void 0 ? "|$" : "";
                    state.output = state.output.slice(0, -(prior.output + prev.output).length);
                    prior.output = `(?:${prior.output}`;
                    prev.type = "globstar";
                    prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                    prev.value += value;
                    state.output += prior.output + prev.output;
                    state.globstar = true;
                    consume(value + advance());
                    push({ type: "slash", value: "/", output: "" });
                    continue;
                  }
                  if (prior.type === "bos" && rest[0] === "/") {
                    prev.type = "globstar";
                    prev.value += value;
                    prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                    state.output = prev.output;
                    state.globstar = true;
                    consume(value + advance());
                    push({ type: "slash", value: "/", output: "" });
                    continue;
                  }
                  state.output = state.output.slice(0, -prev.output.length);
                  prev.type = "globstar";
                  prev.output = globstar(opts);
                  prev.value += value;
                  state.output += prev.output;
                  state.globstar = true;
                  consume(value);
                  continue;
                }
                const token = { type: "star", value, output: star };
                if (opts.bash === true) {
                  token.output = ".*?";
                  if (prev.type === "bos" || prev.type === "slash") {
                    token.output = nodot + token.output;
                  }
                  push(token);
                  continue;
                }
                if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
                  token.output = value;
                  push(token);
                  continue;
                }
                if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
                  if (prev.type === "dot") {
                    state.output += NO_DOT_SLASH;
                    prev.output += NO_DOT_SLASH;
                  } else if (opts.dot === true) {
                    state.output += NO_DOTS_SLASH;
                    prev.output += NO_DOTS_SLASH;
                  } else {
                    state.output += nodot;
                    prev.output += nodot;
                  }
                  if (peek() !== "*") {
                    state.output += ONE_CHAR;
                    prev.output += ONE_CHAR;
                  }
                }
                push(token);
              }
              while (state.brackets > 0) {
                if (opts.strictBrackets === true)
                  throw new SyntaxError(syntaxError("closing", "]"));
                state.output = utils.escapeLast(state.output, "[");
                decrement("brackets");
              }
              while (state.parens > 0) {
                if (opts.strictBrackets === true)
                  throw new SyntaxError(syntaxError("closing", ")"));
                state.output = utils.escapeLast(state.output, "(");
                decrement("parens");
              }
              while (state.braces > 0) {
                if (opts.strictBrackets === true)
                  throw new SyntaxError(syntaxError("closing", "}"));
                state.output = utils.escapeLast(state.output, "{");
                decrement("braces");
              }
              if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
                push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
              }
              if (state.backtrack === true) {
                state.output = "";
                for (const token of state.tokens) {
                  state.output += token.output != null ? token.output : token.value;
                  if (token.suffix) {
                    state.output += token.suffix;
                  }
                }
              }
              return state;
            };
            parse.fastpaths = (input, options) => {
              const opts = __spreadValues2({}, options);
              const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
              const len = input.length;
              if (len > max) {
                throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
              }
              input = REPLACEMENTS[input] || input;
              const win32 = utils.isWindows(options);
              const {
                DOT_LITERAL,
                SLASH_LITERAL,
                ONE_CHAR,
                DOTS_SLASH,
                NO_DOT,
                NO_DOTS,
                NO_DOTS_SLASH,
                STAR,
                START_ANCHOR
              } = constants2.globChars(win32);
              const nodot = opts.dot ? NO_DOTS : NO_DOT;
              const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
              const capture = opts.capture ? "" : "?:";
              const state = { negated: false, prefix: "" };
              let star = opts.bash === true ? ".*?" : STAR;
              if (opts.capture) {
                star = `(${star})`;
              }
              const globstar = (opts2) => {
                if (opts2.noglobstar === true)
                  return star;
                return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
              };
              const create = (str) => {
                switch (str) {
                  case "*":
                    return `${nodot}${ONE_CHAR}${star}`;
                  case ".*":
                    return `${DOT_LITERAL}${ONE_CHAR}${star}`;
                  case "*.*":
                    return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                  case "*/*":
                    return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
                  case "**":
                    return nodot + globstar(opts);
                  case "**/*":
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
                  case "**/*.*":
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
                  case "**/.*":
                    return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
                  default: {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match)
                      return;
                    const source2 = create(match[1]);
                    if (!source2)
                      return;
                    return source2 + DOT_LITERAL + match[2];
                  }
                }
              };
              const output = utils.removePrefix(input, state);
              let source = create(output);
              if (source && opts.strictSlashes !== true) {
                source += `${SLASH_LITERAL}?`;
              }
              return source;
            };
            module22.exports = parse;
          }
        });
        var require_picomatch = __commonJS22({
          "node_modules/picomatch/lib/picomatch.js"(exports22, module22) {
            "use strict";
            var path7 = require("path");
            var scan = require_scan();
            var parse = require_parse2();
            var utils = require_utils4();
            var constants2 = require_constants2();
            var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
            var picomatch = (glob, options, returnState = false) => {
              if (Array.isArray(glob)) {
                const fns = glob.map((input) => picomatch(input, options, returnState));
                const arrayMatcher = (str) => {
                  for (const isMatch of fns) {
                    const state2 = isMatch(str);
                    if (state2)
                      return state2;
                  }
                  return false;
                };
                return arrayMatcher;
              }
              const isState = isObject(glob) && glob.tokens && glob.input;
              if (glob === "" || typeof glob !== "string" && !isState) {
                throw new TypeError("Expected pattern to be a non-empty string");
              }
              const opts = options || {};
              const posix = utils.isWindows(options);
              const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
              const state = regex.state;
              delete regex.state;
              let isIgnored = () => false;
              if (opts.ignore) {
                const ignoreOpts = __spreadProps2(__spreadValues2({}, options), { ignore: null, onMatch: null, onResult: null });
                isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
              }
              const matcher = (input, returnObject = false) => {
                const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
                const result = { glob, state, regex, posix, input, output, match, isMatch };
                if (typeof opts.onResult === "function") {
                  opts.onResult(result);
                }
                if (isMatch === false) {
                  result.isMatch = false;
                  return returnObject ? result : false;
                }
                if (isIgnored(input)) {
                  if (typeof opts.onIgnore === "function") {
                    opts.onIgnore(result);
                  }
                  result.isMatch = false;
                  return returnObject ? result : false;
                }
                if (typeof opts.onMatch === "function") {
                  opts.onMatch(result);
                }
                return returnObject ? result : true;
              };
              if (returnState) {
                matcher.state = state;
              }
              return matcher;
            };
            picomatch.test = (input, regex, options, { glob, posix } = {}) => {
              if (typeof input !== "string") {
                throw new TypeError("Expected input to be a string");
              }
              if (input === "") {
                return { isMatch: false, output: "" };
              }
              const opts = options || {};
              const format = opts.format || (posix ? utils.toPosixSlashes : null);
              let match = input === glob;
              let output = match && format ? format(input) : input;
              if (match === false) {
                output = format ? format(input) : input;
                match = output === glob;
              }
              if (match === false || opts.capture === true) {
                if (opts.matchBase === true || opts.basename === true) {
                  match = picomatch.matchBase(input, regex, options, posix);
                } else {
                  match = regex.exec(output);
                }
              }
              return { isMatch: Boolean(match), match, output };
            };
            picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
              const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
              return regex.test(path7.basename(input));
            };
            picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
            picomatch.parse = (pattern, options) => {
              if (Array.isArray(pattern))
                return pattern.map((p) => picomatch.parse(p, options));
              return parse(pattern, __spreadProps2(__spreadValues2({}, options), { fastpaths: false }));
            };
            picomatch.scan = (input, options) => scan(input, options);
            picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
              if (returnOutput === true) {
                return state.output;
              }
              const opts = options || {};
              const prepend = opts.contains ? "" : "^";
              const append = opts.contains ? "" : "$";
              let source = `${prepend}(?:${state.output})${append}`;
              if (state && state.negated === true) {
                source = `^(?!${source}).*$`;
              }
              const regex = picomatch.toRegex(source, options);
              if (returnState === true) {
                regex.state = state;
              }
              return regex;
            };
            picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
              if (!input || typeof input !== "string") {
                throw new TypeError("Expected a non-empty string");
              }
              let parsed = { negated: false, fastpaths: true };
              if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
                parsed.output = parse.fastpaths(input, options);
              }
              if (!parsed.output) {
                parsed = parse(input, options);
              }
              return picomatch.compileRe(parsed, options, returnOutput, returnState);
            };
            picomatch.toRegex = (source, options) => {
              try {
                const opts = options || {};
                return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
              } catch (err) {
                if (options && options.debug === true)
                  throw err;
                return /$^/;
              }
            };
            picomatch.constants = constants2;
            module22.exports = picomatch;
          }
        });
        var require_picomatch2 = __commonJS22({
          "node_modules/picomatch/index.js"(exports22, module22) {
            "use strict";
            module22.exports = require_picomatch();
          }
        });
        var require_micromatch = __commonJS22({
          "node_modules/micromatch/index.js"(exports22, module22) {
            "use strict";
            var util = require("util");
            var braces = require_braces();
            var picomatch = require_picomatch2();
            var utils = require_utils4();
            var isEmptyString = (val) => val === "" || val === "./";
            var micromatch = (list, patterns, options) => {
              patterns = [].concat(patterns);
              list = [].concat(list);
              let omit = new Set();
              let keep = new Set();
              let items = new Set();
              let negatives = 0;
              let onResult = (state) => {
                items.add(state.output);
                if (options && options.onResult) {
                  options.onResult(state);
                }
              };
              for (let i = 0; i < patterns.length; i++) {
                let isMatch = picomatch(String(patterns[i]), __spreadProps2(__spreadValues2({}, options), { onResult }), true);
                let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
                if (negated)
                  negatives++;
                for (let item of list) {
                  let matched = isMatch(item, true);
                  let match = negated ? !matched.isMatch : matched.isMatch;
                  if (!match)
                    continue;
                  if (negated) {
                    omit.add(matched.output);
                  } else {
                    omit.delete(matched.output);
                    keep.add(matched.output);
                  }
                }
              }
              let result = negatives === patterns.length ? [...items] : [...keep];
              let matches = result.filter((item) => !omit.has(item));
              if (options && matches.length === 0) {
                if (options.failglob === true) {
                  throw new Error(`No matches found for "${patterns.join(", ")}"`);
                }
                if (options.nonull === true || options.nullglob === true) {
                  return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
                }
              }
              return matches;
            };
            micromatch.match = micromatch;
            micromatch.matcher = (pattern, options) => picomatch(pattern, options);
            micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
            micromatch.any = micromatch.isMatch;
            micromatch.not = (list, patterns, options = {}) => {
              patterns = [].concat(patterns).map(String);
              let result = new Set();
              let items = [];
              let onResult = (state) => {
                if (options.onResult)
                  options.onResult(state);
                items.push(state.output);
              };
              let matches = micromatch(list, patterns, __spreadProps2(__spreadValues2({}, options), { onResult }));
              for (let item of items) {
                if (!matches.includes(item)) {
                  result.add(item);
                }
              }
              return [...result];
            };
            micromatch.contains = (str, pattern, options) => {
              if (typeof str !== "string") {
                throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
              }
              if (Array.isArray(pattern)) {
                return pattern.some((p) => micromatch.contains(str, p, options));
              }
              if (typeof pattern === "string") {
                if (isEmptyString(str) || isEmptyString(pattern)) {
                  return false;
                }
                if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
                  return true;
                }
              }
              return micromatch.isMatch(str, pattern, __spreadProps2(__spreadValues2({}, options), { contains: true }));
            };
            micromatch.matchKeys = (obj, patterns, options) => {
              if (!utils.isObject(obj)) {
                throw new TypeError("Expected the first argument to be an object");
              }
              let keys = micromatch(Object.keys(obj), patterns, options);
              let res = {};
              for (let key of keys)
                res[key] = obj[key];
              return res;
            };
            micromatch.some = (list, patterns, options) => {
              let items = [].concat(list);
              for (let pattern of [].concat(patterns)) {
                let isMatch = picomatch(String(pattern), options);
                if (items.some((item) => isMatch(item))) {
                  return true;
                }
              }
              return false;
            };
            micromatch.every = (list, patterns, options) => {
              let items = [].concat(list);
              for (let pattern of [].concat(patterns)) {
                let isMatch = picomatch(String(pattern), options);
                if (!items.every((item) => isMatch(item))) {
                  return false;
                }
              }
              return true;
            };
            micromatch.all = (str, patterns, options) => {
              if (typeof str !== "string") {
                throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
              }
              return [].concat(patterns).every((p) => picomatch(p, options)(str));
            };
            micromatch.capture = (glob, input, options) => {
              let posix = utils.isWindows(options);
              let regex = picomatch.makeRe(String(glob), __spreadProps2(__spreadValues2({}, options), { capture: true }));
              let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
              if (match) {
                return match.slice(1).map((v) => v === void 0 ? "" : v);
              }
            };
            micromatch.makeRe = (...args) => picomatch.makeRe(...args);
            micromatch.scan = (...args) => picomatch.scan(...args);
            micromatch.parse = (patterns, options) => {
              let res = [];
              for (let pattern of [].concat(patterns || [])) {
                for (let str of braces(String(pattern), options)) {
                  res.push(picomatch.parse(str, options));
                }
              }
              return res;
            };
            micromatch.braces = (pattern, options) => {
              if (typeof pattern !== "string")
                throw new TypeError("Expected a string");
              if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
                return [pattern];
              }
              return braces(pattern, options);
            };
            micromatch.braceExpand = (pattern, options) => {
              if (typeof pattern !== "string")
                throw new TypeError("Expected a string");
              return micromatch.braces(pattern, __spreadProps2(__spreadValues2({}, options), { expand: true }));
            };
            module22.exports = micromatch;
          }
        });
        var require_pattern = __commonJS22({
          "node_modules/fast-glob/out/utils/pattern.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.matchAny = exports22.convertPatternsToRe = exports22.makeRe = exports22.getPatternParts = exports22.expandBraceExpansion = exports22.expandPatternsWithBraceExpansion = exports22.isAffectDepthOfReadingPattern = exports22.endsWithSlashGlobStar = exports22.hasGlobStar = exports22.getBaseDirectory = exports22.isPatternRelatedToParentDirectory = exports22.getPatternsOutsideCurrentDirectory = exports22.getPatternsInsideCurrentDirectory = exports22.getPositivePatterns = exports22.getNegativePatterns = exports22.isPositivePattern = exports22.isNegativePattern = exports22.convertToNegativePattern = exports22.convertToPositivePattern = exports22.isDynamicPattern = exports22.isStaticPattern = void 0;
            var path7 = require("path");
            var globParent = require_glob_parent();
            var micromatch = require_micromatch();
            var GLOBSTAR = "**";
            var ESCAPE_SYMBOL = "\\";
            var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
            var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
            var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
            var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
            var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
            function isStaticPattern(pattern, options = {}) {
              return !isDynamicPattern(pattern, options);
            }
            exports22.isStaticPattern = isStaticPattern;
            function isDynamicPattern(pattern, options = {}) {
              if (pattern === "") {
                return false;
              }
              if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
                return true;
              }
              if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
                return true;
              }
              if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
                return true;
              }
              if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
                return true;
              }
              return false;
            }
            exports22.isDynamicPattern = isDynamicPattern;
            function convertToPositivePattern(pattern) {
              return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
            }
            exports22.convertToPositivePattern = convertToPositivePattern;
            function convertToNegativePattern(pattern) {
              return "!" + pattern;
            }
            exports22.convertToNegativePattern = convertToNegativePattern;
            function isNegativePattern(pattern) {
              return pattern.startsWith("!") && pattern[1] !== "(";
            }
            exports22.isNegativePattern = isNegativePattern;
            function isPositivePattern(pattern) {
              return !isNegativePattern(pattern);
            }
            exports22.isPositivePattern = isPositivePattern;
            function getNegativePatterns(patterns) {
              return patterns.filter(isNegativePattern);
            }
            exports22.getNegativePatterns = getNegativePatterns;
            function getPositivePatterns(patterns) {
              return patterns.filter(isPositivePattern);
            }
            exports22.getPositivePatterns = getPositivePatterns;
            function getPatternsInsideCurrentDirectory(patterns) {
              return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
            }
            exports22.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
            function getPatternsOutsideCurrentDirectory(patterns) {
              return patterns.filter(isPatternRelatedToParentDirectory);
            }
            exports22.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
            function isPatternRelatedToParentDirectory(pattern) {
              return pattern.startsWith("..") || pattern.startsWith("./..");
            }
            exports22.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
            function getBaseDirectory(pattern) {
              return globParent(pattern, { flipBackslashes: false });
            }
            exports22.getBaseDirectory = getBaseDirectory;
            function hasGlobStar(pattern) {
              return pattern.includes(GLOBSTAR);
            }
            exports22.hasGlobStar = hasGlobStar;
            function endsWithSlashGlobStar(pattern) {
              return pattern.endsWith("/" + GLOBSTAR);
            }
            exports22.endsWithSlashGlobStar = endsWithSlashGlobStar;
            function isAffectDepthOfReadingPattern(pattern) {
              const basename = path7.basename(pattern);
              return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
            }
            exports22.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
            function expandPatternsWithBraceExpansion(patterns) {
              return patterns.reduce((collection, pattern) => {
                return collection.concat(expandBraceExpansion(pattern));
              }, []);
            }
            exports22.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
            function expandBraceExpansion(pattern) {
              return micromatch.braces(pattern, {
                expand: true,
                nodupes: true
              });
            }
            exports22.expandBraceExpansion = expandBraceExpansion;
            function getPatternParts(pattern, options) {
              let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
              if (parts.length === 0) {
                parts = [pattern];
              }
              if (parts[0].startsWith("/")) {
                parts[0] = parts[0].slice(1);
                parts.unshift("");
              }
              return parts;
            }
            exports22.getPatternParts = getPatternParts;
            function makeRe(pattern, options) {
              return micromatch.makeRe(pattern, options);
            }
            exports22.makeRe = makeRe;
            function convertPatternsToRe(patterns, options) {
              return patterns.map((pattern) => makeRe(pattern, options));
            }
            exports22.convertPatternsToRe = convertPatternsToRe;
            function matchAny(entry, patternsRe) {
              return patternsRe.some((patternRe) => patternRe.test(entry));
            }
            exports22.matchAny = matchAny;
          }
        });
        var require_stream = __commonJS22({
          "node_modules/fast-glob/out/utils/stream.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.merge = void 0;
            var merge2 = require_merge2();
            function merge(streams) {
              const mergedStream = merge2(streams);
              streams.forEach((stream) => {
                stream.once("error", (error) => mergedStream.emit("error", error));
              });
              mergedStream.once("close", () => propagateCloseEventToSources(streams));
              mergedStream.once("end", () => propagateCloseEventToSources(streams));
              return mergedStream;
            }
            exports22.merge = merge;
            function propagateCloseEventToSources(streams) {
              streams.forEach((stream) => stream.emit("close"));
            }
          }
        });
        var require_string222 = __commonJS22({
          "node_modules/fast-glob/out/utils/string.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.isEmpty = exports22.isString = void 0;
            function isString(input) {
              return typeof input === "string";
            }
            exports22.isString = isString;
            function isEmpty(input) {
              return input === "";
            }
            exports22.isEmpty = isEmpty;
          }
        });
        var require_utils5 = __commonJS22({
          "node_modules/fast-glob/out/utils/index.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.string = exports22.stream = exports22.pattern = exports22.path = exports22.fs = exports22.errno = exports22.array = void 0;
            var array2 = require_array();
            exports22.array = array2;
            var errno = require_errno();
            exports22.errno = errno;
            var fs3 = require_fs3();
            exports22.fs = fs3;
            var path7 = require_path();
            exports22.path = path7;
            var pattern = require_pattern();
            exports22.pattern = pattern;
            var stream = require_stream();
            exports22.stream = stream;
            var string = require_string222();
            exports22.string = string;
          }
        });
        var require_tasks = __commonJS22({
          "node_modules/fast-glob/out/managers/tasks.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.convertPatternGroupToTask = exports22.convertPatternGroupsToTasks = exports22.groupPatternsByBaseDirectory = exports22.getNegativePatternsAsPositive = exports22.getPositivePatterns = exports22.convertPatternsToTasks = exports22.generate = void 0;
            var utils = require_utils5();
            function generate(patterns, settings) {
              const positivePatterns = getPositivePatterns(patterns);
              const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
              const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
              const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
              const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
              const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
              return staticTasks.concat(dynamicTasks);
            }
            exports22.generate = generate;
            function convertPatternsToTasks(positive, negative, dynamic) {
              const tasks = [];
              const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
              const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
              const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
              const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
              tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
              if ("." in insideCurrentDirectoryGroup) {
                tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
              } else {
                tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
              }
              return tasks;
            }
            exports22.convertPatternsToTasks = convertPatternsToTasks;
            function getPositivePatterns(patterns) {
              return utils.pattern.getPositivePatterns(patterns);
            }
            exports22.getPositivePatterns = getPositivePatterns;
            function getNegativePatternsAsPositive(patterns, ignore) {
              const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
              const positive = negative.map(utils.pattern.convertToPositivePattern);
              return positive;
            }
            exports22.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
            function groupPatternsByBaseDirectory(patterns) {
              const group = {};
              return patterns.reduce((collection, pattern) => {
                const base = utils.pattern.getBaseDirectory(pattern);
                if (base in collection) {
                  collection[base].push(pattern);
                } else {
                  collection[base] = [pattern];
                }
                return collection;
              }, group);
            }
            exports22.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
            function convertPatternGroupsToTasks(positive, negative, dynamic) {
              return Object.keys(positive).map((base) => {
                return convertPatternGroupToTask(base, positive[base], negative, dynamic);
              });
            }
            exports22.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
            function convertPatternGroupToTask(base, positive, negative, dynamic) {
              return {
                dynamic,
                positive,
                negative,
                base,
                patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
              };
            }
            exports22.convertPatternGroupToTask = convertPatternGroupToTask;
          }
        });
        var require_async = __commonJS22({
          "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.read = void 0;
            function read(path7, settings, callback) {
              settings.fs.lstat(path7, (lstatError, lstat) => {
                if (lstatError !== null) {
                  callFailureCallback(callback, lstatError);
                  return;
                }
                if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
                  callSuccessCallback(callback, lstat);
                  return;
                }
                settings.fs.stat(path7, (statError, stat) => {
                  if (statError !== null) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                      callFailureCallback(callback, statError);
                      return;
                    }
                    callSuccessCallback(callback, lstat);
                    return;
                  }
                  if (settings.markSymbolicLink) {
                    stat.isSymbolicLink = () => true;
                  }
                  callSuccessCallback(callback, stat);
                });
              });
            }
            exports22.read = read;
            function callFailureCallback(callback, error) {
              callback(error);
            }
            function callSuccessCallback(callback, result) {
              callback(null, result);
            }
          }
        });
        var require_sync2 = __commonJS22({
          "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.read = void 0;
            function read(path7, settings) {
              const lstat = settings.fs.lstatSync(path7);
              if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
                return lstat;
              }
              try {
                const stat = settings.fs.statSync(path7);
                if (settings.markSymbolicLink) {
                  stat.isSymbolicLink = () => true;
                }
                return stat;
              } catch (error) {
                if (!settings.throwErrorOnBrokenSymbolicLink) {
                  return lstat;
                }
                throw error;
              }
            }
            exports22.read = read;
          }
        });
        var require_fs4 = __commonJS22({
          "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.createFileSystemAdapter = exports22.FILE_SYSTEM_ADAPTER = void 0;
            var fs3 = require("fs");
            exports22.FILE_SYSTEM_ADAPTER = {
              lstat: fs3.lstat,
              stat: fs3.stat,
              lstatSync: fs3.lstatSync,
              statSync: fs3.statSync
            };
            function createFileSystemAdapter(fsMethods) {
              if (fsMethods === void 0) {
                return exports22.FILE_SYSTEM_ADAPTER;
              }
              return Object.assign(Object.assign({}, exports22.FILE_SYSTEM_ADAPTER), fsMethods);
            }
            exports22.createFileSystemAdapter = createFileSystemAdapter;
          }
        });
        var require_settings = __commonJS22({
          "node_modules/@nodelib/fs.stat/out/settings.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var fs3 = require_fs4();
            var Settings = class {
              constructor(_options = {}) {
                this._options = _options;
                this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
                this.fs = fs3.createFileSystemAdapter(this._options.fs);
                this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
                this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
              }
              _getValue(option, value) {
                return option !== null && option !== void 0 ? option : value;
              }
            };
            exports22.default = Settings;
          }
        });
        var require_out = __commonJS22({
          "node_modules/@nodelib/fs.stat/out/index.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.statSync = exports22.stat = exports22.Settings = void 0;
            var async = require_async();
            var sync = require_sync2();
            var settings_1 = require_settings();
            exports22.Settings = settings_1.default;
            function stat(path7, optionsOrSettingsOrCallback, callback) {
              if (typeof optionsOrSettingsOrCallback === "function") {
                async.read(path7, getSettings(), optionsOrSettingsOrCallback);
                return;
              }
              async.read(path7, getSettings(optionsOrSettingsOrCallback), callback);
            }
            exports22.stat = stat;
            function statSync2(path7, optionsOrSettings) {
              const settings = getSettings(optionsOrSettings);
              return sync.read(path7, settings);
            }
            exports22.statSync = statSync2;
            function getSettings(settingsOrOptions = {}) {
              if (settingsOrOptions instanceof settings_1.default) {
                return settingsOrOptions;
              }
              return new settings_1.default(settingsOrOptions);
            }
          }
        });
        var require_queue_microtask = __commonJS22({
          "node_modules/queue-microtask/index.js"(exports22, module22) {
            var promise;
            module22.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
              throw err;
            }, 0));
          }
        });
        var require_run_parallel = __commonJS22({
          "node_modules/run-parallel/index.js"(exports22, module22) {
            module22.exports = runParallel;
            var queueMicrotask2 = require_queue_microtask();
            function runParallel(tasks, cb) {
              let results, pending, keys;
              let isSync = true;
              if (Array.isArray(tasks)) {
                results = [];
                pending = tasks.length;
              } else {
                keys = Object.keys(tasks);
                results = {};
                pending = keys.length;
              }
              function done(err) {
                function end() {
                  if (cb)
                    cb(err, results);
                  cb = null;
                }
                if (isSync)
                  queueMicrotask2(end);
                else
                  end();
              }
              function each(i, err, result) {
                results[i] = result;
                if (--pending === 0 || err) {
                  done(err);
                }
              }
              if (!pending) {
                done(null);
              } else if (keys) {
                keys.forEach(function(key) {
                  tasks[key](function(err, result) {
                    each(key, err, result);
                  });
                });
              } else {
                tasks.forEach(function(task, i) {
                  task(function(err, result) {
                    each(i, err, result);
                  });
                });
              }
              isSync = false;
            }
          }
        });
        var require_constants3 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/constants.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
            var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
            if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
              throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
            }
            var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
            var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
            var SUPPORTED_MAJOR_VERSION = 10;
            var SUPPORTED_MINOR_VERSION = 10;
            var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
            var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
            exports22.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
          }
        });
        var require_fs5 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.createDirentFromStats = void 0;
            var DirentFromStats = class {
              constructor(name, stats) {
                this.name = name;
                this.isBlockDevice = stats.isBlockDevice.bind(stats);
                this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
                this.isDirectory = stats.isDirectory.bind(stats);
                this.isFIFO = stats.isFIFO.bind(stats);
                this.isFile = stats.isFile.bind(stats);
                this.isSocket = stats.isSocket.bind(stats);
                this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
              }
            };
            function createDirentFromStats(name, stats) {
              return new DirentFromStats(name, stats);
            }
            exports22.createDirentFromStats = createDirentFromStats;
          }
        });
        var require_utils6 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.fs = void 0;
            var fs3 = require_fs5();
            exports22.fs = fs3;
          }
        });
        var require_common22 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.joinPathSegments = void 0;
            function joinPathSegments(a, b, separator) {
              if (a.endsWith(separator)) {
                return a + b;
              }
              return a + separator + b;
            }
            exports22.joinPathSegments = joinPathSegments;
          }
        });
        var require_async2 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.readdir = exports22.readdirWithFileTypes = exports22.read = void 0;
            var fsStat = require_out();
            var rpl = require_run_parallel();
            var constants_1 = require_constants3();
            var utils = require_utils6();
            var common = require_common22();
            function read(directory, settings, callback) {
              if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
                readdirWithFileTypes(directory, settings, callback);
                return;
              }
              readdir(directory, settings, callback);
            }
            exports22.read = read;
            function readdirWithFileTypes(directory, settings, callback) {
              settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
                if (readdirError !== null) {
                  callFailureCallback(callback, readdirError);
                  return;
                }
                const entries3 = dirents.map((dirent) => ({
                  dirent,
                  name: dirent.name,
                  path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
                }));
                if (!settings.followSymbolicLinks) {
                  callSuccessCallback(callback, entries3);
                  return;
                }
                const tasks = entries3.map((entry) => makeRplTaskEntry(entry, settings));
                rpl(tasks, (rplError, rplEntries) => {
                  if (rplError !== null) {
                    callFailureCallback(callback, rplError);
                    return;
                  }
                  callSuccessCallback(callback, rplEntries);
                });
              });
            }
            exports22.readdirWithFileTypes = readdirWithFileTypes;
            function makeRplTaskEntry(entry, settings) {
              return (done) => {
                if (!entry.dirent.isSymbolicLink()) {
                  done(null, entry);
                  return;
                }
                settings.fs.stat(entry.path, (statError, stats) => {
                  if (statError !== null) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                      done(statError);
                      return;
                    }
                    done(null, entry);
                    return;
                  }
                  entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
                  done(null, entry);
                });
              };
            }
            function readdir(directory, settings, callback) {
              settings.fs.readdir(directory, (readdirError, names) => {
                if (readdirError !== null) {
                  callFailureCallback(callback, readdirError);
                  return;
                }
                const tasks = names.map((name) => {
                  const path7 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
                  return (done) => {
                    fsStat.stat(path7, settings.fsStatSettings, (error, stats) => {
                      if (error !== null) {
                        done(error);
                        return;
                      }
                      const entry = {
                        name,
                        path: path7,
                        dirent: utils.fs.createDirentFromStats(name, stats)
                      };
                      if (settings.stats) {
                        entry.stats = stats;
                      }
                      done(null, entry);
                    });
                  };
                });
                rpl(tasks, (rplError, entries3) => {
                  if (rplError !== null) {
                    callFailureCallback(callback, rplError);
                    return;
                  }
                  callSuccessCallback(callback, entries3);
                });
              });
            }
            exports22.readdir = readdir;
            function callFailureCallback(callback, error) {
              callback(error);
            }
            function callSuccessCallback(callback, result) {
              callback(null, result);
            }
          }
        });
        var require_sync3 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.readdir = exports22.readdirWithFileTypes = exports22.read = void 0;
            var fsStat = require_out();
            var constants_1 = require_constants3();
            var utils = require_utils6();
            var common = require_common22();
            function read(directory, settings) {
              if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
                return readdirWithFileTypes(directory, settings);
              }
              return readdir(directory, settings);
            }
            exports22.read = read;
            function readdirWithFileTypes(directory, settings) {
              const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
              return dirents.map((dirent) => {
                const entry = {
                  dirent,
                  name: dirent.name,
                  path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
                };
                if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
                  try {
                    const stats = settings.fs.statSync(entry.path);
                    entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
                  } catch (error) {
                    if (settings.throwErrorOnBrokenSymbolicLink) {
                      throw error;
                    }
                  }
                }
                return entry;
              });
            }
            exports22.readdirWithFileTypes = readdirWithFileTypes;
            function readdir(directory, settings) {
              const names = settings.fs.readdirSync(directory);
              return names.map((name) => {
                const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
                const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
                const entry = {
                  name,
                  path: entryPath,
                  dirent: utils.fs.createDirentFromStats(name, stats)
                };
                if (settings.stats) {
                  entry.stats = stats;
                }
                return entry;
              });
            }
            exports22.readdir = readdir;
          }
        });
        var require_fs6 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.createFileSystemAdapter = exports22.FILE_SYSTEM_ADAPTER = void 0;
            var fs3 = require("fs");
            exports22.FILE_SYSTEM_ADAPTER = {
              lstat: fs3.lstat,
              stat: fs3.stat,
              lstatSync: fs3.lstatSync,
              statSync: fs3.statSync,
              readdir: fs3.readdir,
              readdirSync: fs3.readdirSync
            };
            function createFileSystemAdapter(fsMethods) {
              if (fsMethods === void 0) {
                return exports22.FILE_SYSTEM_ADAPTER;
              }
              return Object.assign(Object.assign({}, exports22.FILE_SYSTEM_ADAPTER), fsMethods);
            }
            exports22.createFileSystemAdapter = createFileSystemAdapter;
          }
        });
        var require_settings2 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/settings.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var path7 = require("path");
            var fsStat = require_out();
            var fs3 = require_fs6();
            var Settings = class {
              constructor(_options = {}) {
                this._options = _options;
                this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
                this.fs = fs3.createFileSystemAdapter(this._options.fs);
                this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path7.sep);
                this.stats = this._getValue(this._options.stats, false);
                this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
                this.fsStatSettings = new fsStat.Settings({
                  followSymbolicLink: this.followSymbolicLinks,
                  fs: this.fs,
                  throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
                });
              }
              _getValue(option, value) {
                return option !== null && option !== void 0 ? option : value;
              }
            };
            exports22.default = Settings;
          }
        });
        var require_out2 = __commonJS22({
          "node_modules/@nodelib/fs.scandir/out/index.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.Settings = exports22.scandirSync = exports22.scandir = void 0;
            var async = require_async2();
            var sync = require_sync3();
            var settings_1 = require_settings2();
            exports22.Settings = settings_1.default;
            function scandir(path7, optionsOrSettingsOrCallback, callback) {
              if (typeof optionsOrSettingsOrCallback === "function") {
                async.read(path7, getSettings(), optionsOrSettingsOrCallback);
                return;
              }
              async.read(path7, getSettings(optionsOrSettingsOrCallback), callback);
            }
            exports22.scandir = scandir;
            function scandirSync(path7, optionsOrSettings) {
              const settings = getSettings(optionsOrSettings);
              return sync.read(path7, settings);
            }
            exports22.scandirSync = scandirSync;
            function getSettings(settingsOrOptions = {}) {
              if (settingsOrOptions instanceof settings_1.default) {
                return settingsOrOptions;
              }
              return new settings_1.default(settingsOrOptions);
            }
          }
        });
        var require_reusify = __commonJS22({
          "node_modules/reusify/reusify.js"(exports22, module22) {
            "use strict";
            function reusify(Constructor) {
              var head = new Constructor();
              var tail = head;
              function get() {
                var current = head;
                if (current.next) {
                  head = current.next;
                } else {
                  head = new Constructor();
                  tail = head;
                }
                current.next = null;
                return current;
              }
              function release(obj) {
                tail.next = obj;
                tail = obj;
              }
              return {
                get,
                release
              };
            }
            module22.exports = reusify;
          }
        });
        var require_queue = __commonJS22({
          "node_modules/fastq/queue.js"(exports22, module22) {
            "use strict";
            var reusify = require_reusify();
            function fastqueue(context, worker, concurrency) {
              if (typeof context === "function") {
                concurrency = worker;
                worker = context;
                context = null;
              }
              if (concurrency < 1) {
                throw new Error("fastqueue concurrency must be greater than 1");
              }
              var cache = reusify(Task);
              var queueHead = null;
              var queueTail = null;
              var _running = 0;
              var errorHandler = null;
              var self2 = {
                push,
                drain: noop,
                saturated: noop,
                pause,
                paused: false,
                concurrency,
                running,
                resume,
                idle,
                length,
                getQueue,
                unshift,
                empty: noop,
                kill,
                killAndDrain,
                error
              };
              return self2;
              function running() {
                return _running;
              }
              function pause() {
                self2.paused = true;
              }
              function length() {
                var current = queueHead;
                var counter = 0;
                while (current) {
                  current = current.next;
                  counter++;
                }
                return counter;
              }
              function getQueue() {
                var current = queueHead;
                var tasks = [];
                while (current) {
                  tasks.push(current.value);
                  current = current.next;
                }
                return tasks;
              }
              function resume() {
                if (!self2.paused)
                  return;
                self2.paused = false;
                for (var i = 0; i < self2.concurrency; i++) {
                  _running++;
                  release();
                }
              }
              function idle() {
                return _running === 0 && self2.length() === 0;
              }
              function push(value, done) {
                var current = cache.get();
                current.context = context;
                current.release = release;
                current.value = value;
                current.callback = done || noop;
                current.errorHandler = errorHandler;
                if (_running === self2.concurrency || self2.paused) {
                  if (queueTail) {
                    queueTail.next = current;
                    queueTail = current;
                  } else {
                    queueHead = current;
                    queueTail = current;
                    self2.saturated();
                  }
                } else {
                  _running++;
                  worker.call(context, current.value, current.worked);
                }
              }
              function unshift(value, done) {
                var current = cache.get();
                current.context = context;
                current.release = release;
                current.value = value;
                current.callback = done || noop;
                if (_running === self2.concurrency || self2.paused) {
                  if (queueHead) {
                    current.next = queueHead;
                    queueHead = current;
                  } else {
                    queueHead = current;
                    queueTail = current;
                    self2.saturated();
                  }
                } else {
                  _running++;
                  worker.call(context, current.value, current.worked);
                }
              }
              function release(holder) {
                if (holder) {
                  cache.release(holder);
                }
                var next = queueHead;
                if (next) {
                  if (!self2.paused) {
                    if (queueTail === queueHead) {
                      queueTail = null;
                    }
                    queueHead = next.next;
                    next.next = null;
                    worker.call(context, next.value, next.worked);
                    if (queueTail === null) {
                      self2.empty();
                    }
                  } else {
                    _running--;
                  }
                } else if (--_running === 0) {
                  self2.drain();
                }
              }
              function kill() {
                queueHead = null;
                queueTail = null;
                self2.drain = noop;
              }
              function killAndDrain() {
                queueHead = null;
                queueTail = null;
                self2.drain();
                self2.drain = noop;
              }
              function error(handler2) {
                errorHandler = handler2;
              }
            }
            function noop() {
            }
            function Task() {
              this.value = null;
              this.callback = noop;
              this.next = null;
              this.release = noop;
              this.context = null;
              this.errorHandler = null;
              var self2 = this;
              this.worked = function worked(err, result) {
                var callback = self2.callback;
                var errorHandler = self2.errorHandler;
                var val = self2.value;
                self2.value = null;
                self2.callback = noop;
                if (self2.errorHandler) {
                  errorHandler(err, val);
                }
                callback.call(self2.context, err, result);
                self2.release(self2);
              };
            }
            function queueAsPromised(context, worker, concurrency) {
              if (typeof context === "function") {
                concurrency = worker;
                worker = context;
                context = null;
              }
              function asyncWrapper(arg, cb) {
                worker.call(this, arg).then(function(res) {
                  cb(null, res);
                }, cb);
              }
              var queue = fastqueue(context, asyncWrapper, concurrency);
              var pushCb = queue.push;
              var unshiftCb = queue.unshift;
              queue.push = push;
              queue.unshift = unshift;
              return queue;
              function push(value) {
                var p = new Promise(function(resolve, reject) {
                  pushCb(value, function(err, result) {
                    if (err) {
                      reject(err);
                      return;
                    }
                    resolve(result);
                  });
                });
                p.catch(noop);
                return p;
              }
              function unshift(value) {
                var p = new Promise(function(resolve, reject) {
                  unshiftCb(value, function(err, result) {
                    if (err) {
                      reject(err);
                      return;
                    }
                    resolve(result);
                  });
                });
                p.catch(noop);
                return p;
              }
            }
            module22.exports = fastqueue;
            module22.exports.promise = queueAsPromised;
          }
        });
        var require_common3 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.joinPathSegments = exports22.replacePathSegmentSeparator = exports22.isAppliedFilter = exports22.isFatalError = void 0;
            function isFatalError(settings, error) {
              if (settings.errorFilter === null) {
                return true;
              }
              return !settings.errorFilter(error);
            }
            exports22.isFatalError = isFatalError;
            function isAppliedFilter(filter, value) {
              return filter === null || filter(value);
            }
            exports22.isAppliedFilter = isAppliedFilter;
            function replacePathSegmentSeparator(filepath, separator) {
              return filepath.split(/[/\\]/).join(separator);
            }
            exports22.replacePathSegmentSeparator = replacePathSegmentSeparator;
            function joinPathSegments(a, b, separator) {
              if (a === "") {
                return b;
              }
              if (a.endsWith(separator)) {
                return a + b;
              }
              return a + separator + b;
            }
            exports22.joinPathSegments = joinPathSegments;
          }
        });
        var require_reader = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var common = require_common3();
            var Reader = class {
              constructor(_root, _settings) {
                this._root = _root;
                this._settings = _settings;
                this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
              }
            };
            exports22.default = Reader;
          }
        });
        var require_async3 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var events_1 = require("events");
            var fsScandir = require_out2();
            var fastq = require_queue();
            var common = require_common3();
            var reader_1 = require_reader();
            var AsyncReader = class extends reader_1.default {
              constructor(_root, _settings) {
                super(_root, _settings);
                this._settings = _settings;
                this._scandir = fsScandir.scandir;
                this._emitter = new events_1.EventEmitter();
                this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
                this._isFatalError = false;
                this._isDestroyed = false;
                this._queue.drain = () => {
                  if (!this._isFatalError) {
                    this._emitter.emit("end");
                  }
                };
              }
              read() {
                this._isFatalError = false;
                this._isDestroyed = false;
                setImmediate(() => {
                  this._pushToQueue(this._root, this._settings.basePath);
                });
                return this._emitter;
              }
              get isDestroyed() {
                return this._isDestroyed;
              }
              destroy() {
                if (this._isDestroyed) {
                  throw new Error("The reader is already destroyed");
                }
                this._isDestroyed = true;
                this._queue.killAndDrain();
              }
              onEntry(callback) {
                this._emitter.on("entry", callback);
              }
              onError(callback) {
                this._emitter.once("error", callback);
              }
              onEnd(callback) {
                this._emitter.once("end", callback);
              }
              _pushToQueue(directory, base) {
                const queueItem = { directory, base };
                this._queue.push(queueItem, (error) => {
                  if (error !== null) {
                    this._handleError(error);
                  }
                });
              }
              _worker(item, done) {
                this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries3) => {
                  if (error !== null) {
                    done(error, void 0);
                    return;
                  }
                  for (const entry of entries3) {
                    this._handleEntry(entry, item.base);
                  }
                  done(null, void 0);
                });
              }
              _handleError(error) {
                if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
                  return;
                }
                this._isFatalError = true;
                this._isDestroyed = true;
                this._emitter.emit("error", error);
              }
              _handleEntry(entry, base) {
                if (this._isDestroyed || this._isFatalError) {
                  return;
                }
                const fullpath = entry.path;
                if (base !== void 0) {
                  entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
                }
                if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
                  this._emitEntry(entry);
                }
                if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
                  this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
                }
              }
              _emitEntry(entry) {
                this._emitter.emit("entry", entry);
              }
            };
            exports22.default = AsyncReader;
          }
        });
        var require_async4 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var async_1 = require_async3();
            var AsyncProvider = class {
              constructor(_root, _settings) {
                this._root = _root;
                this._settings = _settings;
                this._reader = new async_1.default(this._root, this._settings);
                this._storage = [];
              }
              read(callback) {
                this._reader.onError((error) => {
                  callFailureCallback(callback, error);
                });
                this._reader.onEntry((entry) => {
                  this._storage.push(entry);
                });
                this._reader.onEnd(() => {
                  callSuccessCallback(callback, this._storage);
                });
                this._reader.read();
              }
            };
            exports22.default = AsyncProvider;
            function callFailureCallback(callback, error) {
              callback(error);
            }
            function callSuccessCallback(callback, entries3) {
              callback(null, entries3);
            }
          }
        });
        var require_stream2 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var stream_1 = require("stream");
            var async_1 = require_async3();
            var StreamProvider = class {
              constructor(_root, _settings) {
                this._root = _root;
                this._settings = _settings;
                this._reader = new async_1.default(this._root, this._settings);
                this._stream = new stream_1.Readable({
                  objectMode: true,
                  read: () => {
                  },
                  destroy: () => {
                    if (!this._reader.isDestroyed) {
                      this._reader.destroy();
                    }
                  }
                });
              }
              read() {
                this._reader.onError((error) => {
                  this._stream.emit("error", error);
                });
                this._reader.onEntry((entry) => {
                  this._stream.push(entry);
                });
                this._reader.onEnd(() => {
                  this._stream.push(null);
                });
                this._reader.read();
                return this._stream;
              }
            };
            exports22.default = StreamProvider;
          }
        });
        var require_sync4 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var fsScandir = require_out2();
            var common = require_common3();
            var reader_1 = require_reader();
            var SyncReader = class extends reader_1.default {
              constructor() {
                super(...arguments);
                this._scandir = fsScandir.scandirSync;
                this._storage = [];
                this._queue = new Set();
              }
              read() {
                this._pushToQueue(this._root, this._settings.basePath);
                this._handleQueue();
                return this._storage;
              }
              _pushToQueue(directory, base) {
                this._queue.add({ directory, base });
              }
              _handleQueue() {
                for (const item of this._queue.values()) {
                  this._handleDirectory(item.directory, item.base);
                }
              }
              _handleDirectory(directory, base) {
                try {
                  const entries3 = this._scandir(directory, this._settings.fsScandirSettings);
                  for (const entry of entries3) {
                    this._handleEntry(entry, base);
                  }
                } catch (error) {
                  this._handleError(error);
                }
              }
              _handleError(error) {
                if (!common.isFatalError(this._settings, error)) {
                  return;
                }
                throw error;
              }
              _handleEntry(entry, base) {
                const fullpath = entry.path;
                if (base !== void 0) {
                  entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
                }
                if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
                  this._pushToStorage(entry);
                }
                if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
                  this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
                }
              }
              _pushToStorage(entry) {
                this._storage.push(entry);
              }
            };
            exports22.default = SyncReader;
          }
        });
        var require_sync5 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var sync_1 = require_sync4();
            var SyncProvider = class {
              constructor(_root, _settings) {
                this._root = _root;
                this._settings = _settings;
                this._reader = new sync_1.default(this._root, this._settings);
              }
              read() {
                return this._reader.read();
              }
            };
            exports22.default = SyncProvider;
          }
        });
        var require_settings3 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/settings.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var path7 = require("path");
            var fsScandir = require_out2();
            var Settings = class {
              constructor(_options = {}) {
                this._options = _options;
                this.basePath = this._getValue(this._options.basePath, void 0);
                this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
                this.deepFilter = this._getValue(this._options.deepFilter, null);
                this.entryFilter = this._getValue(this._options.entryFilter, null);
                this.errorFilter = this._getValue(this._options.errorFilter, null);
                this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path7.sep);
                this.fsScandirSettings = new fsScandir.Settings({
                  followSymbolicLinks: this._options.followSymbolicLinks,
                  fs: this._options.fs,
                  pathSegmentSeparator: this._options.pathSegmentSeparator,
                  stats: this._options.stats,
                  throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
                });
              }
              _getValue(option, value) {
                return option !== null && option !== void 0 ? option : value;
              }
            };
            exports22.default = Settings;
          }
        });
        var require_out3 = __commonJS22({
          "node_modules/@nodelib/fs.walk/out/index.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.Settings = exports22.walkStream = exports22.walkSync = exports22.walk = void 0;
            var async_1 = require_async4();
            var stream_1 = require_stream2();
            var sync_1 = require_sync5();
            var settings_1 = require_settings3();
            exports22.Settings = settings_1.default;
            function walk(directory, optionsOrSettingsOrCallback, callback) {
              if (typeof optionsOrSettingsOrCallback === "function") {
                new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
                return;
              }
              new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
            }
            exports22.walk = walk;
            function walkSync(directory, optionsOrSettings) {
              const settings = getSettings(optionsOrSettings);
              const provider = new sync_1.default(directory, settings);
              return provider.read();
            }
            exports22.walkSync = walkSync;
            function walkStream(directory, optionsOrSettings) {
              const settings = getSettings(optionsOrSettings);
              const provider = new stream_1.default(directory, settings);
              return provider.read();
            }
            exports22.walkStream = walkStream;
            function getSettings(settingsOrOptions = {}) {
              if (settingsOrOptions instanceof settings_1.default) {
                return settingsOrOptions;
              }
              return new settings_1.default(settingsOrOptions);
            }
          }
        });
        var require_reader2 = __commonJS22({
          "node_modules/fast-glob/out/readers/reader.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var path7 = require("path");
            var fsStat = require_out();
            var utils = require_utils5();
            var Reader = class {
              constructor(_settings) {
                this._settings = _settings;
                this._fsStatSettings = new fsStat.Settings({
                  followSymbolicLink: this._settings.followSymbolicLinks,
                  fs: this._settings.fs,
                  throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
                });
              }
              _getFullEntryPath(filepath) {
                return path7.resolve(this._settings.cwd, filepath);
              }
              _makeEntry(stats, pattern) {
                const entry = {
                  name: pattern,
                  path: pattern,
                  dirent: utils.fs.createDirentFromStats(pattern, stats)
                };
                if (this._settings.stats) {
                  entry.stats = stats;
                }
                return entry;
              }
              _isFatalError(error) {
                return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
              }
            };
            exports22.default = Reader;
          }
        });
        var require_stream3 = __commonJS22({
          "node_modules/fast-glob/out/readers/stream.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var stream_1 = require("stream");
            var fsStat = require_out();
            var fsWalk = require_out3();
            var reader_1 = require_reader2();
            var ReaderStream = class extends reader_1.default {
              constructor() {
                super(...arguments);
                this._walkStream = fsWalk.walkStream;
                this._stat = fsStat.stat;
              }
              dynamic(root, options) {
                return this._walkStream(root, options);
              }
              static(patterns, options) {
                const filepaths = patterns.map(this._getFullEntryPath, this);
                const stream = new stream_1.PassThrough({ objectMode: true });
                stream._write = (index, _enc, done) => {
                  return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
                    if (entry !== null && options.entryFilter(entry)) {
                      stream.push(entry);
                    }
                    if (index === filepaths.length - 1) {
                      stream.end();
                    }
                    done();
                  }).catch(done);
                };
                for (let i = 0; i < filepaths.length; i++) {
                  stream.write(i);
                }
                return stream;
              }
              _getEntry(filepath, pattern, options) {
                return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
                  if (options.errorFilter(error)) {
                    return null;
                  }
                  throw error;
                });
              }
              _getStat(filepath) {
                return new Promise((resolve, reject) => {
                  this._stat(filepath, this._fsStatSettings, (error, stats) => {
                    return error === null ? resolve(stats) : reject(error);
                  });
                });
              }
            };
            exports22.default = ReaderStream;
          }
        });
        var require_matcher = __commonJS22({
          "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var utils = require_utils5();
            var Matcher = class {
              constructor(_patterns, _settings, _micromatchOptions) {
                this._patterns = _patterns;
                this._settings = _settings;
                this._micromatchOptions = _micromatchOptions;
                this._storage = [];
                this._fillStorage();
              }
              _fillStorage() {
                const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
                for (const pattern of patterns) {
                  const segments = this._getPatternSegments(pattern);
                  const sections = this._splitSegmentsIntoSections(segments);
                  this._storage.push({
                    complete: sections.length <= 1,
                    pattern,
                    segments,
                    sections
                  });
                }
              }
              _getPatternSegments(pattern) {
                const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
                return parts.map((part) => {
                  const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
                  if (!dynamic) {
                    return {
                      dynamic: false,
                      pattern: part
                    };
                  }
                  return {
                    dynamic: true,
                    pattern: part,
                    patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
                  };
                });
              }
              _splitSegmentsIntoSections(segments) {
                return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
              }
            };
            exports22.default = Matcher;
          }
        });
        var require_partial = __commonJS22({
          "node_modules/fast-glob/out/providers/matchers/partial.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var matcher_1 = require_matcher();
            var PartialMatcher = class extends matcher_1.default {
              match(filepath) {
                const parts = filepath.split("/");
                const levels = parts.length;
                const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
                for (const pattern of patterns) {
                  const section = pattern.sections[0];
                  if (!pattern.complete && levels > section.length) {
                    return true;
                  }
                  const match = parts.every((part, index) => {
                    const segment = pattern.segments[index];
                    if (segment.dynamic && segment.patternRe.test(part)) {
                      return true;
                    }
                    if (!segment.dynamic && segment.pattern === part) {
                      return true;
                    }
                    return false;
                  });
                  if (match) {
                    return true;
                  }
                }
                return false;
              }
            };
            exports22.default = PartialMatcher;
          }
        });
        var require_deep = __commonJS22({
          "node_modules/fast-glob/out/providers/filters/deep.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var utils = require_utils5();
            var partial_1 = require_partial();
            var DeepFilter = class {
              constructor(_settings, _micromatchOptions) {
                this._settings = _settings;
                this._micromatchOptions = _micromatchOptions;
              }
              getFilter(basePath, positive, negative) {
                const matcher = this._getMatcher(positive);
                const negativeRe = this._getNegativePatternsRe(negative);
                return (entry) => this._filter(basePath, entry, matcher, negativeRe);
              }
              _getMatcher(patterns) {
                return new partial_1.default(patterns, this._settings, this._micromatchOptions);
              }
              _getNegativePatternsRe(patterns) {
                const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
                return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
              }
              _filter(basePath, entry, matcher, negativeRe) {
                if (this._isSkippedByDeep(basePath, entry.path)) {
                  return false;
                }
                if (this._isSkippedSymbolicLink(entry)) {
                  return false;
                }
                const filepath = utils.path.removeLeadingDotSegment(entry.path);
                if (this._isSkippedByPositivePatterns(filepath, matcher)) {
                  return false;
                }
                return this._isSkippedByNegativePatterns(filepath, negativeRe);
              }
              _isSkippedByDeep(basePath, entryPath) {
                if (this._settings.deep === Infinity) {
                  return false;
                }
                return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
              }
              _getEntryLevel(basePath, entryPath) {
                const entryPathDepth = entryPath.split("/").length;
                if (basePath === "") {
                  return entryPathDepth;
                }
                const basePathDepth = basePath.split("/").length;
                return entryPathDepth - basePathDepth;
              }
              _isSkippedSymbolicLink(entry) {
                return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
              }
              _isSkippedByPositivePatterns(entryPath, matcher) {
                return !this._settings.baseNameMatch && !matcher.match(entryPath);
              }
              _isSkippedByNegativePatterns(entryPath, patternsRe) {
                return !utils.pattern.matchAny(entryPath, patternsRe);
              }
            };
            exports22.default = DeepFilter;
          }
        });
        var require_entry = __commonJS22({
          "node_modules/fast-glob/out/providers/filters/entry.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var utils = require_utils5();
            var EntryFilter = class {
              constructor(_settings, _micromatchOptions) {
                this._settings = _settings;
                this._micromatchOptions = _micromatchOptions;
                this.index = new Map();
              }
              getFilter(positive, negative) {
                const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
                const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
                return (entry) => this._filter(entry, positiveRe, negativeRe);
              }
              _filter(entry, positiveRe, negativeRe) {
                if (this._settings.unique && this._isDuplicateEntry(entry)) {
                  return false;
                }
                if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
                  return false;
                }
                if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
                  return false;
                }
                const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
                const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
                if (this._settings.unique && isMatched) {
                  this._createIndexRecord(entry);
                }
                return isMatched;
              }
              _isDuplicateEntry(entry) {
                return this.index.has(entry.path);
              }
              _createIndexRecord(entry) {
                this.index.set(entry.path, void 0);
              }
              _onlyFileFilter(entry) {
                return this._settings.onlyFiles && !entry.dirent.isFile();
              }
              _onlyDirectoryFilter(entry) {
                return this._settings.onlyDirectories && !entry.dirent.isDirectory();
              }
              _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
                if (!this._settings.absolute) {
                  return false;
                }
                const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
                return utils.pattern.matchAny(fullpath, patternsRe);
              }
              _isMatchToPatterns(entryPath, patternsRe) {
                const filepath = utils.path.removeLeadingDotSegment(entryPath);
                return utils.pattern.matchAny(filepath, patternsRe);
              }
            };
            exports22.default = EntryFilter;
          }
        });
        var require_error = __commonJS22({
          "node_modules/fast-glob/out/providers/filters/error.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var utils = require_utils5();
            var ErrorFilter = class {
              constructor(_settings) {
                this._settings = _settings;
              }
              getFilter() {
                return (error) => this._isNonFatalError(error);
              }
              _isNonFatalError(error) {
                return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
              }
            };
            exports22.default = ErrorFilter;
          }
        });
        var require_entry2 = __commonJS22({
          "node_modules/fast-glob/out/providers/transformers/entry.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var utils = require_utils5();
            var EntryTransformer = class {
              constructor(_settings) {
                this._settings = _settings;
              }
              getTransformer() {
                return (entry) => this._transform(entry);
              }
              _transform(entry) {
                let filepath = entry.path;
                if (this._settings.absolute) {
                  filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
                  filepath = utils.path.unixify(filepath);
                }
                if (this._settings.markDirectories && entry.dirent.isDirectory()) {
                  filepath += "/";
                }
                if (!this._settings.objectMode) {
                  return filepath;
                }
                return Object.assign(Object.assign({}, entry), { path: filepath });
              }
            };
            exports22.default = EntryTransformer;
          }
        });
        var require_provider = __commonJS22({
          "node_modules/fast-glob/out/providers/provider.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var path7 = require("path");
            var deep_1 = require_deep();
            var entry_1 = require_entry();
            var error_1 = require_error();
            var entry_2 = require_entry2();
            var Provider = class {
              constructor(_settings) {
                this._settings = _settings;
                this.errorFilter = new error_1.default(this._settings);
                this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
                this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
                this.entryTransformer = new entry_2.default(this._settings);
              }
              _getRootDirectory(task) {
                return path7.resolve(this._settings.cwd, task.base);
              }
              _getReaderOptions(task) {
                const basePath = task.base === "." ? "" : task.base;
                return {
                  basePath,
                  pathSegmentSeparator: "/",
                  concurrency: this._settings.concurrency,
                  deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
                  entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
                  errorFilter: this.errorFilter.getFilter(),
                  followSymbolicLinks: this._settings.followSymbolicLinks,
                  fs: this._settings.fs,
                  stats: this._settings.stats,
                  throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
                  transform: this.entryTransformer.getTransformer()
                };
              }
              _getMicromatchOptions() {
                return {
                  dot: this._settings.dot,
                  matchBase: this._settings.baseNameMatch,
                  nobrace: !this._settings.braceExpansion,
                  nocase: !this._settings.caseSensitiveMatch,
                  noext: !this._settings.extglob,
                  noglobstar: !this._settings.globstar,
                  posix: true,
                  strictSlashes: false
                };
              }
            };
            exports22.default = Provider;
          }
        });
        var require_async5 = __commonJS22({
          "node_modules/fast-glob/out/providers/async.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var stream_1 = require_stream3();
            var provider_1 = require_provider();
            var ProviderAsync = class extends provider_1.default {
              constructor() {
                super(...arguments);
                this._reader = new stream_1.default(this._settings);
              }
              read(task) {
                const root = this._getRootDirectory(task);
                const options = this._getReaderOptions(task);
                const entries3 = [];
                return new Promise((resolve, reject) => {
                  const stream = this.api(root, task, options);
                  stream.once("error", reject);
                  stream.on("data", (entry) => entries3.push(options.transform(entry)));
                  stream.once("end", () => resolve(entries3));
                });
              }
              api(root, task, options) {
                if (task.dynamic) {
                  return this._reader.dynamic(root, options);
                }
                return this._reader.static(task.patterns, options);
              }
            };
            exports22.default = ProviderAsync;
          }
        });
        var require_stream4 = __commonJS22({
          "node_modules/fast-glob/out/providers/stream.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var stream_1 = require("stream");
            var stream_2 = require_stream3();
            var provider_1 = require_provider();
            var ProviderStream = class extends provider_1.default {
              constructor() {
                super(...arguments);
                this._reader = new stream_2.default(this._settings);
              }
              read(task) {
                const root = this._getRootDirectory(task);
                const options = this._getReaderOptions(task);
                const source = this.api(root, task, options);
                const destination = new stream_1.Readable({ objectMode: true, read: () => {
                } });
                source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
                destination.once("close", () => source.destroy());
                return destination;
              }
              api(root, task, options) {
                if (task.dynamic) {
                  return this._reader.dynamic(root, options);
                }
                return this._reader.static(task.patterns, options);
              }
            };
            exports22.default = ProviderStream;
          }
        });
        var require_sync6 = __commonJS22({
          "node_modules/fast-glob/out/readers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var fsStat = require_out();
            var fsWalk = require_out3();
            var reader_1 = require_reader2();
            var ReaderSync = class extends reader_1.default {
              constructor() {
                super(...arguments);
                this._walkSync = fsWalk.walkSync;
                this._statSync = fsStat.statSync;
              }
              dynamic(root, options) {
                return this._walkSync(root, options);
              }
              static(patterns, options) {
                const entries3 = [];
                for (const pattern of patterns) {
                  const filepath = this._getFullEntryPath(pattern);
                  const entry = this._getEntry(filepath, pattern, options);
                  if (entry === null || !options.entryFilter(entry)) {
                    continue;
                  }
                  entries3.push(entry);
                }
                return entries3;
              }
              _getEntry(filepath, pattern, options) {
                try {
                  const stats = this._getStat(filepath);
                  return this._makeEntry(stats, pattern);
                } catch (error) {
                  if (options.errorFilter(error)) {
                    return null;
                  }
                  throw error;
                }
              }
              _getStat(filepath) {
                return this._statSync(filepath, this._fsStatSettings);
              }
            };
            exports22.default = ReaderSync;
          }
        });
        var require_sync7 = __commonJS22({
          "node_modules/fast-glob/out/providers/sync.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            var sync_1 = require_sync6();
            var provider_1 = require_provider();
            var ProviderSync = class extends provider_1.default {
              constructor() {
                super(...arguments);
                this._reader = new sync_1.default(this._settings);
              }
              read(task) {
                const root = this._getRootDirectory(task);
                const options = this._getReaderOptions(task);
                const entries3 = this.api(root, task, options);
                return entries3.map(options.transform);
              }
              api(root, task, options) {
                if (task.dynamic) {
                  return this._reader.dynamic(root, options);
                }
                return this._reader.static(task.patterns, options);
              }
            };
            exports22.default = ProviderSync;
          }
        });
        var require_settings4 = __commonJS22({
          "node_modules/fast-glob/out/settings.js"(exports22) {
            "use strict";
            Object.defineProperty(exports22, "__esModule", { value: true });
            exports22.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
            var fs3 = require("fs");
            var os = require("os");
            var CPU_COUNT = Math.max(os.cpus().length, 1);
            exports22.DEFAULT_FILE_SYSTEM_ADAPTER = {
              lstat: fs3.lstat,
              lstatSync: fs3.lstatSync,
              stat: fs3.stat,
              statSync: fs3.statSync,
              readdir: fs3.readdir,
              readdirSync: fs3.readdirSync
            };
            var Settings = class {
              constructor(_options = {}) {
                this._options = _options;
                this.absolute = this._getValue(this._options.absolute, false);
                this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
                this.braceExpansion = this._getValue(this._options.braceExpansion, true);
                this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
                this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
                this.cwd = this._getValue(this._options.cwd, process.cwd());
                this.deep = this._getValue(this._options.deep, Infinity);
                this.dot = this._getValue(this._options.dot, false);
                this.extglob = this._getValue(this._options.extglob, true);
                this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
                this.fs = this._getFileSystemMethods(this._options.fs);
                this.globstar = this._getValue(this._options.globstar, true);
                this.ignore = this._getValue(this._options.ignore, []);
                this.markDirectories = this._getValue(this._options.markDirectories, false);
                this.objectMode = this._getValue(this._options.objectMode, false);
                this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
                this.onlyFiles = this._getValue(this._options.onlyFiles, true);
                this.stats = this._getValue(this._options.stats, false);
                this.suppressErrors = this._getValue(this._options.suppressErrors, false);
                this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
                this.unique = this._getValue(this._options.unique, true);
                if (this.onlyDirectories) {
                  this.onlyFiles = false;
                }
                if (this.stats) {
                  this.objectMode = true;
                }
              }
              _getValue(option, value) {
                return option === void 0 ? value : option;
              }
              _getFileSystemMethods(methods = {}) {
                return Object.assign(Object.assign({}, exports22.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
              }
            };
            exports22.default = Settings;
          }
        });
        var require_out4 = __commonJS22({
          "node_modules/fast-glob/out/index.js"(exports22, module22) {
            "use strict";
            var taskManager = require_tasks();
            var async_1 = require_async5();
            var stream_1 = require_stream4();
            var sync_1 = require_sync7();
            var settings_1 = require_settings4();
            var utils = require_utils5();
            function FastGlob(source, options) {
              return __async2(this, null, function* () {
                assertPatternsInput(source);
                const works = getWorks(source, async_1.default, options);
                const result = yield Promise.all(works);
                return utils.array.flatten(result);
              });
            }
            (function(FastGlob2) {
              function sync(source, options) {
                assertPatternsInput(source);
                const works = getWorks(source, sync_1.default, options);
                return utils.array.flatten(works);
              }
              FastGlob2.sync = sync;
              function stream(source, options) {
                assertPatternsInput(source);
                const works = getWorks(source, stream_1.default, options);
                return utils.stream.merge(works);
              }
              FastGlob2.stream = stream;
              function generateTasks(source, options) {
                assertPatternsInput(source);
                const patterns = [].concat(source);
                const settings = new settings_1.default(options);
                return taskManager.generate(patterns, settings);
              }
              FastGlob2.generateTasks = generateTasks;
              function isDynamicPattern(source, options) {
                assertPatternsInput(source);
                const settings = new settings_1.default(options);
                return utils.pattern.isDynamicPattern(source, settings);
              }
              FastGlob2.isDynamicPattern = isDynamicPattern;
              function escapePath(source) {
                assertPatternsInput(source);
                return utils.path.escape(source);
              }
              FastGlob2.escapePath = escapePath;
            })(FastGlob || (FastGlob = {}));
            function getWorks(source, _Provider, options) {
              const patterns = [].concat(source);
              const settings = new settings_1.default(options);
              const tasks = taskManager.generate(patterns, settings);
              const provider = new _Provider(settings);
              return tasks.map(provider.read, provider);
            }
            function assertPatternsInput(input) {
              const source = [].concat(input);
              const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
              if (!isValidSource) {
                throw new TypeError("Patterns must be a string (non empty) or an array of strings");
              }
            }
            module22.exports = FastGlob;
          }
        });
        var require_path_type = __commonJS22({
          "node_modules/path-type/index.js"(exports22) {
            "use strict";
            var { promisify } = require("util");
            var fs3 = require("fs");
            function isType(fsStatType, statsMethodName, filePath) {
              return __async2(this, null, function* () {
                if (typeof filePath !== "string") {
                  throw new TypeError(`Expected a string, got ${typeof filePath}`);
                }
                try {
                  const stats = yield promisify(fs3[fsStatType])(filePath);
                  return stats[statsMethodName]();
                } catch (error) {
                  if (error.code === "ENOENT") {
                    return false;
                  }
                  throw error;
                }
              });
            }
            function isTypeSync(fsStatType, statsMethodName, filePath) {
              if (typeof filePath !== "string") {
                throw new TypeError(`Expected a string, got ${typeof filePath}`);
              }
              try {
                return fs3[fsStatType](filePath)[statsMethodName]();
              } catch (error) {
                if (error.code === "ENOENT") {
                  return false;
                }
                throw error;
              }
            }
            exports22.isFile = isType.bind(null, "stat", "isFile");
            exports22.isDirectory = isType.bind(null, "stat", "isDirectory");
            exports22.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
            exports22.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
            exports22.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
            exports22.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
          }
        });
        var require_dir_glob = __commonJS22({
          "node_modules/dir-glob/index.js"(exports22, module22) {
            "use strict";
            var path7 = require("path");
            var pathType = require_path_type();
            var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
            var getPath = (filepath, cwd) => {
              const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
              return path7.isAbsolute(pth) ? pth : path7.join(cwd, pth);
            };
            var addExtensions = (file, extensions) => {
              if (path7.extname(file)) {
                return `**/${file}`;
              }
              return `**/${file}.${getExtensions(extensions)}`;
            };
            var getGlob = (directory, options) => {
              if (options.files && !Array.isArray(options.files)) {
                throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
              }
              if (options.extensions && !Array.isArray(options.extensions)) {
                throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
              }
              if (options.files && options.extensions) {
                return options.files.map((x) => path7.posix.join(directory, addExtensions(x, options.extensions)));
              }
              if (options.files) {
                return options.files.map((x) => path7.posix.join(directory, `**/${x}`));
              }
              if (options.extensions) {
                return [path7.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
              }
              return [path7.posix.join(directory, "**")];
            };
            module22.exports = (input, options) => __async2(exports22, null, function* () {
              options = __spreadValues2({
                cwd: process.cwd()
              }, options);
              if (typeof options.cwd !== "string") {
                throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
              }
              const globs = yield Promise.all([].concat(input).map((x) => __async2(exports22, null, function* () {
                const isDirectory = yield pathType.isDirectory(getPath(x, options.cwd));
                return isDirectory ? getGlob(x, options) : x;
              })));
              return [].concat.apply([], globs);
            });
            module22.exports.sync = (input, options) => {
              options = __spreadValues2({
                cwd: process.cwd()
              }, options);
              if (typeof options.cwd !== "string") {
                throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
              }
              const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
              return [].concat.apply([], globs);
            };
          }
        });
        var require_ignore = __commonJS22({
          "node_modules/ignore/index.js"(exports22, module22) {
            function makeArray(subject) {
              return Array.isArray(subject) ? subject : [subject];
            }
            var EMPTY = "";
            var SPACE = " ";
            var ESCAPE = "\\";
            var REGEX_TEST_BLANK_LINE = /^\s+$/;
            var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
            var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
            var REGEX_SPLITALL_CRLF = /\r?\n/g;
            var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
            var SLASH = "/";
            var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
            var define = (object, key, value) => Object.defineProperty(object, key, { value });
            var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
            var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
            var cleanRangeBackSlash = (slashes) => {
              const { length } = slashes;
              return slashes.slice(0, length - length % 2);
            };
            var REPLACERS = [
              [
                /\\?\s+$/,
                (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
              ],
              [
                /\\\s/g,
                () => SPACE
              ],
              [
                /[\\$.|*+(){^]/g,
                (match) => `\\${match}`
              ],
              [
                /(?!\\)\?/g,
                () => "[^/]"
              ],
              [
                /^\//,
                () => "^"
              ],
              [
                /\//g,
                () => "\\/"
              ],
              [
                /^\^*\\\*\\\*\\\//,
                () => "^(?:.*\\/)?"
              ],
              [
                /^(?=[^^])/,
                function startingReplacer() {
                  return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
                }
              ],
              [
                /\\\/\\\*\\\*(?=\\\/|$)/g,
                (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
              ],
              [
                /(^|[^\\]+)\\\*(?=.+)/g,
                (_, p1) => `${p1}[^\\/]*`
              ],
              [
                /\\\\\\(?=[$.|*+(){^])/g,
                () => ESCAPE
              ],
              [
                /\\\\/g,
                () => ESCAPE
              ],
              [
                /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
                (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
              ],
              [
                /(?:[^*])$/,
                (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
              ],
              [
                /(\^|\\\/)?\\\*$/,
                (_, p1) => {
                  const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
                  return `${prefix}(?=$|\\/$)`;
                }
              ]
            ];
            var regexCache = Object.create(null);
            var makeRegex = (pattern, negative, ignorecase) => {
              const r = regexCache[pattern];
              if (r) {
                return r;
              }
              const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
              return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
            };
            var isString = (subject) => typeof subject === "string";
            var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
            var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
            var IgnoreRule = class {
              constructor(origin, pattern, negative, regex) {
                this.origin = origin;
                this.pattern = pattern;
                this.negative = negative;
                this.regex = regex;
              }
            };
            var createRule = (pattern, ignorecase) => {
              const origin = pattern;
              let negative = false;
              if (pattern.indexOf("!") === 0) {
                negative = true;
                pattern = pattern.substr(1);
              }
              pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
              const regex = makeRegex(pattern, negative, ignorecase);
              return new IgnoreRule(origin, pattern, negative, regex);
            };
            var throwError = (message, Ctor) => {
              throw new Ctor(message);
            };
            var checkPath = (path7, originalPath, doThrow) => {
              if (!isString(path7)) {
                return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
              }
              if (!path7) {
                return doThrow(`path must not be empty`, TypeError);
              }
              if (checkPath.isNotRelative(path7)) {
                const r = "`path.relative()`d";
                return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
              }
              return true;
            };
            var isNotRelative = (path7) => REGEX_TEST_INVALID_PATH.test(path7);
            checkPath.isNotRelative = isNotRelative;
            checkPath.convert = (p) => p;
            var Ignore = class {
              constructor({
                ignorecase = true
              } = {}) {
                this._rules = [];
                this._ignorecase = ignorecase;
                define(this, KEY_IGNORE, true);
                this._initCache();
              }
              _initCache() {
                this._ignoreCache = Object.create(null);
                this._testCache = Object.create(null);
              }
              _addPattern(pattern) {
                if (pattern && pattern[KEY_IGNORE]) {
                  this._rules = this._rules.concat(pattern._rules);
                  this._added = true;
                  return;
                }
                if (checkPattern(pattern)) {
                  const rule = createRule(pattern, this._ignorecase);
                  this._added = true;
                  this._rules.push(rule);
                }
              }
              add(pattern) {
                this._added = false;
                makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
                if (this._added) {
                  this._initCache();
                }
                return this;
              }
              addPattern(pattern) {
                return this.add(pattern);
              }
              _testOne(path7, checkUnignored) {
                let ignored = false;
                let unignored = false;
                this._rules.forEach((rule) => {
                  const { negative } = rule;
                  if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
                    return;
                  }
                  const matched = rule.regex.test(path7);
                  if (matched) {
                    ignored = !negative;
                    unignored = negative;
                  }
                });
                return {
                  ignored,
                  unignored
                };
              }
              _test(originalPath, cache, checkUnignored, slices) {
                const path7 = originalPath && checkPath.convert(originalPath);
                checkPath(path7, originalPath, throwError);
                return this._t(path7, cache, checkUnignored, slices);
              }
              _t(path7, cache, checkUnignored, slices) {
                if (path7 in cache) {
                  return cache[path7];
                }
                if (!slices) {
                  slices = path7.split(SLASH);
                }
                slices.pop();
                if (!slices.length) {
                  return cache[path7] = this._testOne(path7, checkUnignored);
                }
                const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
                return cache[path7] = parent.ignored ? parent : this._testOne(path7, checkUnignored);
              }
              ignores(path7) {
                return this._test(path7, this._ignoreCache, false).ignored;
              }
              createFilter() {
                return (path7) => !this.ignores(path7);
              }
              filter(paths) {
                return makeArray(paths).filter(this.createFilter());
              }
              test(path7) {
                return this._test(path7, this._testCache, true);
              }
            };
            var factory = (options) => new Ignore(options);
            var returnFalse = () => false;
            var isPathValid = (path7) => checkPath(path7 && checkPath.convert(path7), path7, returnFalse);
            factory.isPathValid = isPathValid;
            factory.default = factory;
            module22.exports = factory;
            if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
              const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
              checkPath.convert = makePosix;
              const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
              checkPath.isNotRelative = (path7) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path7) || isNotRelative(path7);
            }
          }
        });
        var require_slash = __commonJS22({
          "node_modules/slash/index.js"(exports22, module22) {
            "use strict";
            module22.exports = (path7) => {
              const isExtendedLengthPath = /^\\\\\?\\/.test(path7);
              const hasNonAscii = /[^\u0000-\u0080]+/.test(path7);
              if (isExtendedLengthPath || hasNonAscii) {
                return path7;
              }
              return path7.replace(/\\/g, "/");
            };
          }
        });
        var require_gitignore = __commonJS22({
          "node_modules/globby/gitignore.js"(exports22, module22) {
            "use strict";
            var { promisify } = require("util");
            var fs3 = require("fs");
            var path7 = require("path");
            var fastGlob = require_out4();
            var gitIgnore = require_ignore();
            var slash = require_slash();
            var DEFAULT_IGNORE = [
              "**/node_modules/**",
              "**/flow-typed/**",
              "**/coverage/**",
              "**/.git"
            ];
            var readFileP = promisify(fs3.readFile);
            var mapGitIgnorePatternTo = (base) => (ignore) => {
              if (ignore.startsWith("!")) {
                return "!" + path7.posix.join(base, ignore.slice(1));
              }
              return path7.posix.join(base, ignore);
            };
            var parseGitIgnore = (content, options) => {
              const base = slash(path7.relative(options.cwd, path7.dirname(options.fileName)));
              return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
            };
            var reduceIgnore = (files) => {
              return files.reduce((ignores, file) => {
                ignores.add(parseGitIgnore(file.content, {
                  cwd: file.cwd,
                  fileName: file.filePath
                }));
                return ignores;
              }, gitIgnore());
            };
            var ensureAbsolutePathForCwd = (cwd, p) => {
              if (path7.isAbsolute(p)) {
                if (p.startsWith(cwd)) {
                  return p;
                }
                throw new Error(`Path ${p} is not in cwd ${cwd}`);
              }
              return path7.join(cwd, p);
            };
            var getIsIgnoredPredecate = (ignores, cwd) => {
              return (p) => ignores.ignores(slash(path7.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));
            };
            var getFile = (file, cwd) => __async2(exports22, null, function* () {
              const filePath = path7.join(cwd, file);
              const content = yield readFileP(filePath, "utf8");
              return {
                cwd,
                filePath,
                content
              };
            });
            var getFileSync = (file, cwd) => {
              const filePath = path7.join(cwd, file);
              const content = fs3.readFileSync(filePath, "utf8");
              return {
                cwd,
                filePath,
                content
              };
            };
            var normalizeOptions = ({
              ignore = [],
              cwd = slash(process.cwd())
            } = {}) => {
              return { ignore, cwd };
            };
            module22.exports = (options) => __async2(exports22, null, function* () {
              options = normalizeOptions(options);
              const paths = yield fastGlob("**/.gitignore", {
                ignore: DEFAULT_IGNORE.concat(options.ignore),
                cwd: options.cwd
              });
              const files = yield Promise.all(paths.map((file) => getFile(file, options.cwd)));
              const ignores = reduceIgnore(files);
              return getIsIgnoredPredecate(ignores, options.cwd);
            });
            module22.exports.sync = (options) => {
              options = normalizeOptions(options);
              const paths = fastGlob.sync("**/.gitignore", {
                ignore: DEFAULT_IGNORE.concat(options.ignore),
                cwd: options.cwd
              });
              const files = paths.map((file) => getFileSync(file, options.cwd));
              const ignores = reduceIgnore(files);
              return getIsIgnoredPredecate(ignores, options.cwd);
            };
          }
        });
        var require_stream_utils = __commonJS22({
          "node_modules/globby/stream-utils.js"(exports22, module22) {
            "use strict";
            var { Transform } = require("stream");
            var ObjectTransform = class extends Transform {
              constructor() {
                super({
                  objectMode: true
                });
              }
            };
            var FilterStream = class extends ObjectTransform {
              constructor(filter) {
                super();
                this._filter = filter;
              }
              _transform(data, encoding, callback) {
                if (this._filter(data)) {
                  this.push(data);
                }
                callback();
              }
            };
            var UniqueStream = class extends ObjectTransform {
              constructor() {
                super();
                this._pushed = new Set();
              }
              _transform(data, encoding, callback) {
                if (!this._pushed.has(data)) {
                  this.push(data);
                  this._pushed.add(data);
                }
                callback();
              }
            };
            module22.exports = {
              FilterStream,
              UniqueStream
            };
          }
        });
        var require_globby = __commonJS22({
          "node_modules/globby/index.js"(exports22, module22) {
            "use strict";
            var fs3 = require("fs");
            var arrayUnion = require_array_union();
            var merge2 = require_merge2();
            var glob = require_glob();
            var fastGlob = require_out4();
            var dirGlob = require_dir_glob();
            var gitignore = require_gitignore();
            var { FilterStream, UniqueStream } = require_stream_utils();
            var DEFAULT_FILTER = () => false;
            var isNegative = (pattern) => pattern[0] === "!";
            var assertPatternsInput = (patterns) => {
              if (!patterns.every((pattern) => typeof pattern === "string")) {
                throw new TypeError("Patterns must be a string or an array of strings");
              }
            };
            var checkCwdOption = (options = {}) => {
              if (!options.cwd) {
                return;
              }
              let stat;
              try {
                stat = fs3.statSync(options.cwd);
              } catch (_) {
                return;
              }
              if (!stat.isDirectory()) {
                throw new Error("The `cwd` option must be a path to a directory");
              }
            };
            var getPathString = (p) => p.stats instanceof fs3.Stats ? p.path : p;
            var generateGlobTasks = (patterns, taskOptions) => {
              patterns = arrayUnion([].concat(patterns));
              assertPatternsInput(patterns);
              checkCwdOption(taskOptions);
              const globTasks = [];
              taskOptions = __spreadValues2({
                ignore: [],
                expandDirectories: true
              }, taskOptions);
              for (const [index, pattern] of patterns.entries()) {
                if (isNegative(pattern)) {
                  continue;
                }
                const ignore = patterns.slice(index).filter(isNegative).map((pattern2) => pattern2.slice(1));
                const options = __spreadProps2(__spreadValues2({}, taskOptions), {
                  ignore: taskOptions.ignore.concat(ignore)
                });
                globTasks.push({ pattern, options });
              }
              return globTasks;
            };
            var globDirs = (task, fn) => {
              let options = {};
              if (task.options.cwd) {
                options.cwd = task.options.cwd;
              }
              if (Array.isArray(task.options.expandDirectories)) {
                options = __spreadProps2(__spreadValues2({}, options), {
                  files: task.options.expandDirectories
                });
              } else if (typeof task.options.expandDirectories === "object") {
                options = __spreadValues2(__spreadValues2({}, options), task.options.expandDirectories);
              }
              return fn(task.pattern, options);
            };
            var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
            var getFilterSync = (options) => {
              return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
            };
            var globToTask = (task) => (glob2) => {
              const { options } = task;
              if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
                options.ignore = dirGlob.sync(options.ignore);
              }
              return {
                pattern: glob2,
                options
              };
            };
            module22.exports = (patterns, options) => __async2(exports22, null, function* () {
              const globTasks = generateGlobTasks(patterns, options);
              const getFilter = () => __async2(exports22, null, function* () {
                return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
              });
              const getTasks = () => __async2(exports22, null, function* () {
                const tasks2 = yield Promise.all(globTasks.map((task) => __async2(exports22, null, function* () {
                  const globs = yield getPattern(task, dirGlob);
                  return Promise.all(globs.map(globToTask(task)));
                })));
                return arrayUnion(...tasks2);
              });
              const [filter, tasks] = yield Promise.all([getFilter(), getTasks()]);
              const paths = yield Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
              return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
            });
            module22.exports.sync = (patterns, options) => {
              const globTasks = generateGlobTasks(patterns, options);
              const tasks = globTasks.reduce((tasks2, task) => {
                const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
                return tasks2.concat(newTask);
              }, []);
              const filter = getFilterSync(options);
              return tasks.reduce((matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)), []).filter((path_) => !filter(path_));
            };
            module22.exports.stream = (patterns, options) => {
              const globTasks = generateGlobTasks(patterns, options);
              const tasks = globTasks.reduce((tasks2, task) => {
                const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
                return tasks2.concat(newTask);
              }, []);
              const filter = getFilterSync(options);
              const filterStream = new FilterStream((p) => !filter(p));
              const uniqueStream = new UniqueStream();
              return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
            };
            module22.exports.generateGlobTasks = generateGlobTasks;
            module22.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => glob.hasMagic(pattern, options));
            module22.exports.gitignore = gitignore;
          }
        });
        var require_escape_string_regexp = __commonJS22({
          "node_modules/escape-string-regexp/index.js"(exports22, module22) {
            "use strict";
            var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
            module22.exports = function(str) {
              if (typeof str !== "string") {
                throw new TypeError("Expected a string");
              }
              return str.replace(matchOperatorsRe, "\\$&");
            };
          }
        });
        var require_color_name2 = __commonJS22({
          "node_modules/color-name/index.js"(exports22, module22) {
            "use strict";
            module22.exports = {
              "aliceblue": [240, 248, 255],
              "antiquewhite": [250, 235, 215],
              "aqua": [0, 255, 255],
              "aquamarine": [127, 255, 212],
              "azure": [240, 255, 255],
              "beige": [245, 245, 220],
              "bisque": [255, 228, 196],
              "black": [0, 0, 0],
              "blanchedalmond": [255, 235, 205],
              "blue": [0, 0, 255],
              "blueviolet": [138, 43, 226],
              "brown": [165, 42, 42],
              "burlywood": [222, 184, 135],
              "cadetblue": [95, 158, 160],
              "chartreuse": [127, 255, 0],
              "chocolate": [210, 105, 30],
              "coral": [255, 127, 80],
              "cornflowerblue": [100, 149, 237],
              "cornsilk": [255, 248, 220],
              "crimson": [220, 20, 60],
              "cyan": [0, 255, 255],
              "darkblue": [0, 0, 139],
              "darkcyan": [0, 139, 139],
              "darkgoldenrod": [184, 134, 11],
              "darkgray": [169, 169, 169],
              "darkgreen": [0, 100, 0],
              "darkgrey": [169, 169, 169],
              "darkkhaki": [189, 183, 107],
              "darkmagenta": [139, 0, 139],
              "darkolivegreen": [85, 107, 47],
              "darkorange": [255, 140, 0],
              "darkorchid": [153, 50, 204],
              "darkred": [139, 0, 0],
              "darksalmon": [233, 150, 122],
              "darkseagreen": [143, 188, 143],
              "darkslateblue": [72, 61, 139],
              "darkslategray": [47, 79, 79],
              "darkslategrey": [47, 79, 79],
              "darkturquoise": [0, 206, 209],
              "darkviolet": [148, 0, 211],
              "deeppink": [255, 20, 147],
              "deepskyblue": [0, 191, 255],
              "dimgray": [105, 105, 105],
              "dimgrey": [105, 105, 105],
              "dodgerblue": [30, 144, 255],
              "firebrick": [178, 34, 34],
              "floralwhite": [255, 250, 240],
              "forestgreen": [34, 139, 34],
              "fuchsia": [255, 0, 255],
              "gainsboro": [220, 220, 220],
              "ghostwhite": [248, 248, 255],
              "gold": [255, 215, 0],
              "goldenrod": [218, 165, 32],
              "gray": [128, 128, 128],
              "green": [0, 128, 0],
              "greenyellow": [173, 255, 47],
              "grey": [128, 128, 128],
              "honeydew": [240, 255, 240],
              "hotpink": [255, 105, 180],
              "indianred": [205, 92, 92],
              "indigo": [75, 0, 130],
              "ivory": [255, 255, 240],
              "khaki": [240, 230, 140],
              "lavender": [230, 230, 250],
              "lavenderblush": [255, 240, 245],
              "lawngreen": [124, 252, 0],
              "lemonchiffon": [255, 250, 205],
              "lightblue": [173, 216, 230],
              "lightcoral": [240, 128, 128],
              "lightcyan": [224, 255, 255],
              "lightgoldenrodyellow": [250, 250, 210],
              "lightgray": [211, 211, 211],
              "lightgreen": [144, 238, 144],
              "lightgrey": [211, 211, 211],
              "lightpink": [255, 182, 193],
              "lightsalmon": [255, 160, 122],
              "lightseagreen": [32, 178, 170],
              "lightskyblue": [135, 206, 250],
              "lightslategray": [119, 136, 153],
              "lightslategrey": [119, 136, 153],
              "lightsteelblue": [176, 196, 222],
              "lightyellow": [255, 255, 224],
              "lime": [0, 255, 0],
              "limegreen": [50, 205, 50],
              "linen": [250, 240, 230],
              "magenta": [255, 0, 255],
              "maroon": [128, 0, 0],
              "mediumaquamarine": [102, 205, 170],
              "mediumblue": [0, 0, 205],
              "mediumorchid": [186, 85, 211],
              "mediumpurple": [147, 112, 219],
              "mediumseagreen": [60, 179, 113],
              "mediumslateblue": [123, 104, 238],
              "mediumspringgreen": [0, 250, 154],
              "mediumturquoise": [72, 209, 204],
              "mediumvioletred": [199, 21, 133],
              "midnightblue": [25, 25, 112],
              "mintcream": [245, 255, 250],
              "mistyrose": [255, 228, 225],
              "moccasin": [255, 228, 181],
              "navajowhite": [255, 222, 173],
              "navy": [0, 0, 128],
              "oldlace": [253, 245, 230],
              "olive": [128, 128, 0],
              "olivedrab": [107, 142, 35],
              "orange": [255, 165, 0],
              "orangered": [255, 69, 0],
              "orchid": [218, 112, 214],
              "palegoldenrod": [238, 232, 170],
              "palegreen": [152, 251, 152],
              "paleturquoise": [175, 238, 238],
              "palevioletred": [219, 112, 147],
              "papayawhip": [255, 239, 213],
              "peachpuff": [255, 218, 185],
              "peru": [205, 133, 63],
              "pink": [255, 192, 203],
              "plum": [221, 160, 221],
              "powderblue": [176, 224, 230],
              "purple": [128, 0, 128],
              "rebeccapurple": [102, 51, 153],
              "red": [255, 0, 0],
              "rosybrown": [188, 143, 143],
              "royalblue": [65, 105, 225],
              "saddlebrown": [139, 69, 19],
              "salmon": [250, 128, 114],
              "sandybrown": [244, 164, 96],
              "seagreen": [46, 139, 87],
              "seashell": [255, 245, 238],
              "sienna": [160, 82, 45],
              "silver": [192, 192, 192],
              "skyblue": [135, 206, 235],
              "slateblue": [106, 90, 205],
              "slategray": [112, 128, 144],
              "slategrey": [112, 128, 144],
              "snow": [255, 250, 250],
              "springgreen": [0, 255, 127],
              "steelblue": [70, 130, 180],
              "tan": [210, 180, 140],
              "teal": [0, 128, 128],
              "thistle": [216, 191, 216],
              "tomato": [255, 99, 71],
              "turquoise": [64, 224, 208],
              "violet": [238, 130, 238],
              "wheat": [245, 222, 179],
              "white": [255, 255, 255],
              "whitesmoke": [245, 245, 245],
              "yellow": [255, 255, 0],
              "yellowgreen": [154, 205, 50]
            };
          }
        });
        var require_conversions2 = __commonJS22({
          "node_modules/color-convert/conversions.js"(exports22, module22) {
            var cssKeywords = require_color_name2();
            var reverseKeywords = {};
            for (key in cssKeywords) {
              if (cssKeywords.hasOwnProperty(key)) {
                reverseKeywords[cssKeywords[key]] = key;
              }
            }
            var key;
            var convert = module22.exports = {
              rgb: { channels: 3, labels: "rgb" },
              hsl: { channels: 3, labels: "hsl" },
              hsv: { channels: 3, labels: "hsv" },
              hwb: { channels: 3, labels: "hwb" },
              cmyk: { channels: 4, labels: "cmyk" },
              xyz: { channels: 3, labels: "xyz" },
              lab: { channels: 3, labels: "lab" },
              lch: { channels: 3, labels: "lch" },
              hex: { channels: 1, labels: ["hex"] },
              keyword: { channels: 1, labels: ["keyword"] },
              ansi16: { channels: 1, labels: ["ansi16"] },
              ansi256: { channels: 1, labels: ["ansi256"] },
              hcg: { channels: 3, labels: ["h", "c", "g"] },
              apple: { channels: 3, labels: ["r16", "g16", "b16"] },
              gray: { channels: 1, labels: ["gray"] }
            };
            for (model in convert) {
              if (convert.hasOwnProperty(model)) {
                if (!("channels" in convert[model])) {
                  throw new Error("missing channels property: " + model);
                }
                if (!("labels" in convert[model])) {
                  throw new Error("missing channel labels property: " + model);
                }
                if (convert[model].labels.length !== convert[model].channels) {
                  throw new Error("channel and label counts mismatch: " + model);
                }
                channels = convert[model].channels;
                labels = convert[model].labels;
                delete convert[model].channels;
                delete convert[model].labels;
                Object.defineProperty(convert[model], "channels", { value: channels });
                Object.defineProperty(convert[model], "labels", { value: labels });
              }
            }
            var channels;
            var labels;
            var model;
            convert.rgb.hsl = function(rgb) {
              var r = rgb[0] / 255;
              var g = rgb[1] / 255;
              var b = rgb[2] / 255;
              var min = Math.min(r, g, b);
              var max = Math.max(r, g, b);
              var delta = max - min;
              var h;
              var s;
              var l;
              if (max === min) {
                h = 0;
              } else if (r === max) {
                h = (g - b) / delta;
              } else if (g === max) {
                h = 2 + (b - r) / delta;
              } else if (b === max) {
                h = 4 + (r - g) / delta;
              }
              h = Math.min(h * 60, 360);
              if (h < 0) {
                h += 360;
              }
              l = (min + max) / 2;
              if (max === min) {
                s = 0;
              } else if (l <= 0.5) {
                s = delta / (max + min);
              } else {
                s = delta / (2 - max - min);
              }
              return [h, s * 100, l * 100];
            };
            convert.rgb.hsv = function(rgb) {
              var rdif;
              var gdif;
              var bdif;
              var h;
              var s;
              var r = rgb[0] / 255;
              var g = rgb[1] / 255;
              var b = rgb[2] / 255;
              var v = Math.max(r, g, b);
              var diff = v - Math.min(r, g, b);
              var diffc = function(c2) {
                return (v - c2) / 6 / diff + 1 / 2;
              };
              if (diff === 0) {
                h = s = 0;
              } else {
                s = diff / v;
                rdif = diffc(r);
                gdif = diffc(g);
                bdif = diffc(b);
                if (r === v) {
                  h = bdif - gdif;
                } else if (g === v) {
                  h = 1 / 3 + rdif - bdif;
                } else if (b === v) {
                  h = 2 / 3 + gdif - rdif;
                }
                if (h < 0) {
                  h += 1;
                } else if (h > 1) {
                  h -= 1;
                }
              }
              return [
                h * 360,
                s * 100,
                v * 100
              ];
            };
            convert.rgb.hwb = function(rgb) {
              var r = rgb[0];
              var g = rgb[1];
              var b = rgb[2];
              var h = convert.rgb.hsl(rgb)[0];
              var w = 1 / 255 * Math.min(r, Math.min(g, b));
              b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
              return [h, w * 100, b * 100];
            };
            convert.rgb.cmyk = function(rgb) {
              var r = rgb[0] / 255;
              var g = rgb[1] / 255;
              var b = rgb[2] / 255;
              var c2;
              var m;
              var y;
              var k;
              k = Math.min(1 - r, 1 - g, 1 - b);
              c2 = (1 - r - k) / (1 - k) || 0;
              m = (1 - g - k) / (1 - k) || 0;
              y = (1 - b - k) / (1 - k) || 0;
              return [c2 * 100, m * 100, y * 100, k * 100];
            };
            function comparativeDistance(x, y) {
              return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
            }
            convert.rgb.keyword = function(rgb) {
              var reversed = reverseKeywords[rgb];
              if (reversed) {
                return reversed;
              }
              var currentClosestDistance = Infinity;
              var currentClosestKeyword;
              for (var keyword in cssKeywords) {
                if (cssKeywords.hasOwnProperty(keyword)) {
                  var value = cssKeywords[keyword];
                  var distance = comparativeDistance(rgb, value);
                  if (distance < currentClosestDistance) {
                    currentClosestDistance = distance;
                    currentClosestKeyword = keyword;
                  }
                }
              }
              return currentClosestKeyword;
            };
            convert.keyword.rgb = function(keyword) {
              return cssKeywords[keyword];
            };
            convert.rgb.xyz = function(rgb) {
              var r = rgb[0] / 255;
              var g = rgb[1] / 255;
              var b = rgb[2] / 255;
              r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
              g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
              b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
              var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
              var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
              var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
              return [x * 100, y * 100, z * 100];
            };
            convert.rgb.lab = function(rgb) {
              var xyz = convert.rgb.xyz(rgb);
              var x = xyz[0];
              var y = xyz[1];
              var z = xyz[2];
              var l;
              var a;
              var b;
              x /= 95.047;
              y /= 100;
              z /= 108.883;
              x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
              y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
              z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
              l = 116 * y - 16;
              a = 500 * (x - y);
              b = 200 * (y - z);
              return [l, a, b];
            };
            convert.hsl.rgb = function(hsl) {
              var h = hsl[0] / 360;
              var s = hsl[1] / 100;
              var l = hsl[2] / 100;
              var t1;
              var t2;
              var t3;
              var rgb;
              var val;
              if (s === 0) {
                val = l * 255;
                return [val, val, val];
              }
              if (l < 0.5) {
                t2 = l * (1 + s);
              } else {
                t2 = l + s - l * s;
              }
              t1 = 2 * l - t2;
              rgb = [0, 0, 0];
              for (var i = 0; i < 3; i++) {
                t3 = h + 1 / 3 * -(i - 1);
                if (t3 < 0) {
                  t3++;
                }
                if (t3 > 1) {
                  t3--;
                }
                if (6 * t3 < 1) {
                  val = t1 + (t2 - t1) * 6 * t3;
                } else if (2 * t3 < 1) {
                  val = t2;
                } else if (3 * t3 < 2) {
                  val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                } else {
                  val = t1;
                }
                rgb[i] = val * 255;
              }
              return rgb;
            };
            convert.hsl.hsv = function(hsl) {
              var h = hsl[0];
              var s = hsl[1] / 100;
              var l = hsl[2] / 100;
              var smin = s;
              var lmin = Math.max(l, 0.01);
              var sv;
              var v;
              l *= 2;
              s *= l <= 1 ? l : 2 - l;
              smin *= lmin <= 1 ? lmin : 2 - lmin;
              v = (l + s) / 2;
              sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
              return [h, sv * 100, v * 100];
            };
            convert.hsv.rgb = function(hsv) {
              var h = hsv[0] / 60;
              var s = hsv[1] / 100;
              var v = hsv[2] / 100;
              var hi = Math.floor(h) % 6;
              var f = h - Math.floor(h);
              var p = 255 * v * (1 - s);
              var q = 255 * v * (1 - s * f);
              var t = 255 * v * (1 - s * (1 - f));
              v *= 255;
              switch (hi) {
                case 0:
                  return [v, t, p];
                case 1:
                  return [q, v, p];
                case 2:
                  return [p, v, t];
                case 3:
                  return [p, q, v];
                case 4:
                  return [t, p, v];
                case 5:
                  return [v, p, q];
              }
            };
            convert.hsv.hsl = function(hsv) {
              var h = hsv[0];
              var s = hsv[1] / 100;
              var v = hsv[2] / 100;
              var vmin = Math.max(v, 0.01);
              var lmin;
              var sl;
              var l;
              l = (2 - s) * v;
              lmin = (2 - s) * vmin;
              sl = s * vmin;
              sl /= lmin <= 1 ? lmin : 2 - lmin;
              sl = sl || 0;
              l /= 2;
              return [h, sl * 100, l * 100];
            };
            convert.hwb.rgb = function(hwb) {
              var h = hwb[0] / 360;
              var wh = hwb[1] / 100;
              var bl = hwb[2] / 100;
              var ratio = wh + bl;
              var i;
              var v;
              var f;
              var n;
              if (ratio > 1) {
                wh /= ratio;
                bl /= ratio;
              }
              i = Math.floor(6 * h);
              v = 1 - bl;
              f = 6 * h - i;
              if ((i & 1) !== 0) {
                f = 1 - f;
              }
              n = wh + f * (v - wh);
              var r;
              var g;
              var b;
              switch (i) {
                default:
                case 6:
                case 0:
                  r = v;
                  g = n;
                  b = wh;
                  break;
                case 1:
                  r = n;
                  g = v;
                  b = wh;
                  break;
                case 2:
                  r = wh;
                  g = v;
                  b = n;
                  break;
                case 3:
                  r = wh;
                  g = n;
                  b = v;
                  break;
                case 4:
                  r = n;
                  g = wh;
                  b = v;
                  break;
                case 5:
                  r = v;
                  g = wh;
                  b = n;
                  break;
              }
              return [r * 255, g * 255, b * 255];
            };
            convert.cmyk.rgb = function(cmyk) {
              var c2 = cmyk[0] / 100;
              var m = cmyk[1] / 100;
              var y = cmyk[2] / 100;
              var k = cmyk[3] / 100;
              var r;
              var g;
              var b;
              r = 1 - Math.min(1, c2 * (1 - k) + k);
              g = 1 - Math.min(1, m * (1 - k) + k);
              b = 1 - Math.min(1, y * (1 - k) + k);
              return [r * 255, g * 255, b * 255];
            };
            convert.xyz.rgb = function(xyz) {
              var x = xyz[0] / 100;
              var y = xyz[1] / 100;
              var z = xyz[2] / 100;
              var r;
              var g;
              var b;
              r = x * 3.2406 + y * -1.5372 + z * -0.4986;
              g = x * -0.9689 + y * 1.8758 + z * 0.0415;
              b = x * 0.0557 + y * -0.204 + z * 1.057;
              r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
              g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
              b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
              r = Math.min(Math.max(0, r), 1);
              g = Math.min(Math.max(0, g), 1);
              b = Math.min(Math.max(0, b), 1);
              return [r * 255, g * 255, b * 255];
            };
            convert.xyz.lab = function(xyz) {
              var x = xyz[0];
              var y = xyz[1];
              var z = xyz[2];
              var l;
              var a;
              var b;
              x /= 95.047;
              y /= 100;
              z /= 108.883;
              x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
              y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
              z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
              l = 116 * y - 16;
              a = 500 * (x - y);
              b = 200 * (y - z);
              return [l, a, b];
            };
            convert.lab.xyz = function(lab) {
              var l = lab[0];
              var a = lab[1];
              var b = lab[2];
              var x;
              var y;
              var z;
              y = (l + 16) / 116;
              x = a / 500 + y;
              z = y - b / 200;
              var y2 = Math.pow(y, 3);
              var x2 = Math.pow(x, 3);
              var z2 = Math.pow(z, 3);
              y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
              x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
              z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
              x *= 95.047;
              y *= 100;
              z *= 108.883;
              return [x, y, z];
            };
            convert.lab.lch = function(lab) {
              var l = lab[0];
              var a = lab[1];
              var b = lab[2];
              var hr;
              var h;
              var c2;
              hr = Math.atan2(b, a);
              h = hr * 360 / 2 / Math.PI;
              if (h < 0) {
                h += 360;
              }
              c2 = Math.sqrt(a * a + b * b);
              return [l, c2, h];
            };
            convert.lch.lab = function(lch) {
              var l = lch[0];
              var c2 = lch[1];
              var h = lch[2];
              var a;
              var b;
              var hr;
              hr = h / 360 * 2 * Math.PI;
              a = c2 * Math.cos(hr);
              b = c2 * Math.sin(hr);
              return [l, a, b];
            };
            convert.rgb.ansi16 = function(args) {
              var r = args[0];
              var g = args[1];
              var b = args[2];
              var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
              value = Math.round(value / 50);
              if (value === 0) {
                return 30;
              }
              var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
              if (value === 2) {
                ansi += 60;
              }
              return ansi;
            };
            convert.hsv.ansi16 = function(args) {
              return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
            };
            convert.rgb.ansi256 = function(args) {
              var r = args[0];
              var g = args[1];
              var b = args[2];
              if (r === g && g === b) {
                if (r < 8) {
                  return 16;
                }
                if (r > 248) {
                  return 231;
                }
                return Math.round((r - 8) / 247 * 24) + 232;
              }
              var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
              return ansi;
            };
            convert.ansi16.rgb = function(args) {
              var color = args % 10;
              if (color === 0 || color === 7) {
                if (args > 50) {
                  color += 3.5;
                }
                color = color / 10.5 * 255;
                return [color, color, color];
              }
              var mult = (~~(args > 50) + 1) * 0.5;
              var r = (color & 1) * mult * 255;
              var g = (color >> 1 & 1) * mult * 255;
              var b = (color >> 2 & 1) * mult * 255;
              return [r, g, b];
            };
            convert.ansi256.rgb = function(args) {
              if (args >= 232) {
                var c2 = (args - 232) * 10 + 8;
                return [c2, c2, c2];
              }
              args -= 16;
              var rem;
              var r = Math.floor(args / 36) / 5 * 255;
              var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
              var b = rem % 6 / 5 * 255;
              return [r, g, b];
            };
            convert.rgb.hex = function(args) {
              var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
              var string = integer.toString(16).toUpperCase();
              return "000000".substring(string.length) + string;
            };
            convert.hex.rgb = function(args) {
              var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
              if (!match) {
                return [0, 0, 0];
              }
              var colorString = match[0];
              if (match[0].length === 3) {
                colorString = colorString.split("").map(function(char) {
                  return char + char;
                }).join("");
              }
              var integer = parseInt(colorString, 16);
              var r = integer >> 16 & 255;
              var g = integer >> 8 & 255;
              var b = integer & 255;
              return [r, g, b];
            };
            convert.rgb.hcg = function(rgb) {
              var r = rgb[0] / 255;
              var g = rgb[1] / 255;
              var b = rgb[2] / 255;
              var max = Math.max(Math.max(r, g), b);
              var min = Math.min(Math.min(r, g), b);
              var chroma = max - min;
              var grayscale;
              var hue;
              if (chroma < 1) {
                grayscale = min / (1 - chroma);
              } else {
                grayscale = 0;
              }
              if (chroma <= 0) {
                hue = 0;
              } else if (max === r) {
                hue = (g - b) / chroma % 6;
              } else if (max === g) {
                hue = 2 + (b - r) / chroma;
              } else {
                hue = 4 + (r - g) / chroma + 4;
              }
              hue /= 6;
              hue %= 1;
              return [hue * 360, chroma * 100, grayscale * 100];
            };
            convert.hsl.hcg = function(hsl) {
              var s = hsl[1] / 100;
              var l = hsl[2] / 100;
              var c2 = 1;
              var f = 0;
              if (l < 0.5) {
                c2 = 2 * s * l;
              } else {
                c2 = 2 * s * (1 - l);
              }
              if (c2 < 1) {
                f = (l - 0.5 * c2) / (1 - c2);
              }
              return [hsl[0], c2 * 100, f * 100];
            };
            convert.hsv.hcg = function(hsv) {
              var s = hsv[1] / 100;
              var v = hsv[2] / 100;
              var c2 = s * v;
              var f = 0;
              if (c2 < 1) {
                f = (v - c2) / (1 - c2);
              }
              return [hsv[0], c2 * 100, f * 100];
            };
            convert.hcg.rgb = function(hcg) {
              var h = hcg[0] / 360;
              var c2 = hcg[1] / 100;
              var g = hcg[2] / 100;
              if (c2 === 0) {
                return [g * 255, g * 255, g * 255];
              }
              var pure = [0, 0, 0];
              var hi = h % 1 * 6;
              var v = hi % 1;
              var w = 1 - v;
              var mg = 0;
              switch (Math.floor(hi)) {
                case 0:
                  pure[0] = 1;
                  pure[1] = v;
                  pure[2] = 0;
                  break;
                case 1:
                  pure[0] = w;
                  pure[1] = 1;
                  pure[2] = 0;
                  break;
                case 2:
                  pure[0] = 0;
                  pure[1] = 1;
                  pure[2] = v;
                  break;
                case 3:
                  pure[0] = 0;
                  pure[1] = w;
                  pure[2] = 1;
                  break;
                case 4:
                  pure[0] = v;
                  pure[1] = 0;
                  pure[2] = 1;
                  break;
                default:
                  pure[0] = 1;
                  pure[1] = 0;
                  pure[2] = w;
              }
              mg = (1 - c2) * g;
              return [
                (c2 * pure[0] + mg) * 255,
                (c2 * pure[1] + mg) * 255,
                (c2 * pure[2] + mg) * 255
              ];
            };
            convert.hcg.hsv = function(hcg) {
              var c2 = hcg[1] / 100;
              var g = hcg[2] / 100;
              var v = c2 + g * (1 - c2);
              var f = 0;
              if (v > 0) {
                f = c2 / v;
              }
              return [hcg[0], f * 100, v * 100];
            };
            convert.hcg.hsl = function(hcg) {
              var c2 = hcg[1] / 100;
              var g = hcg[2] / 100;
              var l = g * (1 - c2) + 0.5 * c2;
              var s = 0;
              if (l > 0 && l < 0.5) {
                s = c2 / (2 * l);
              } else if (l >= 0.5 && l < 1) {
                s = c2 / (2 * (1 - l));
              }
              return [hcg[0], s * 100, l * 100];
            };
            convert.hcg.hwb = function(hcg) {
              var c2 = hcg[1] / 100;
              var g = hcg[2] / 100;
              var v = c2 + g * (1 - c2);
              return [hcg[0], (v - c2) * 100, (1 - v) * 100];
            };
            convert.hwb.hcg = function(hwb) {
              var w = hwb[1] / 100;
              var b = hwb[2] / 100;
              var v = 1 - b;
              var c2 = v - w;
              var g = 0;
              if (c2 < 1) {
                g = (v - c2) / (1 - c2);
              }
              return [hwb[0], c2 * 100, g * 100];
            };
            convert.apple.rgb = function(apple) {
              return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
            };
            convert.rgb.apple = function(rgb) {
              return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
            };
            convert.gray.rgb = function(args) {
              return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
            };
            convert.gray.hsl = convert.gray.hsv = function(args) {
              return [0, 0, args[0]];
            };
            convert.gray.hwb = function(gray2) {
              return [0, 100, gray2[0]];
            };
            convert.gray.cmyk = function(gray2) {
              return [0, 0, 0, gray2[0]];
            };
            convert.gray.lab = function(gray2) {
              return [gray2[0], 0, 0];
            };
            convert.gray.hex = function(gray2) {
              var val = Math.round(gray2[0] / 100 * 255) & 255;
              var integer = (val << 16) + (val << 8) + val;
              var string = integer.toString(16).toUpperCase();
              return "000000".substring(string.length) + string;
            };
            convert.rgb.gray = function(rgb) {
              var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
              return [val / 255 * 100];
            };
          }
        });
        var require_route2 = __commonJS22({
          "node_modules/color-convert/route.js"(exports22, module22) {
            var conversions = require_conversions2();
            function buildGraph() {
              var graph = {};
              var models = Object.keys(conversions);
              for (var len = models.length, i = 0; i < len; i++) {
                graph[models[i]] = {
                  distance: -1,
                  parent: null
                };
              }
              return graph;
            }
            function deriveBFS(fromModel) {
              var graph = buildGraph();
              var queue = [fromModel];
              graph[fromModel].distance = 0;
              while (queue.length) {
                var current = queue.pop();
                var adjacents = Object.keys(conversions[current]);
                for (var len = adjacents.length, i = 0; i < len; i++) {
                  var adjacent = adjacents[i];
                  var node = graph[adjacent];
                  if (node.distance === -1) {
                    node.distance = graph[current].distance + 1;
                    node.parent = current;
                    queue.unshift(adjacent);
                  }
                }
              }
              return graph;
            }
            function link(from, to) {
              return function(args) {
                return to(from(args));
              };
            }
            function wrapConversion(toModel, graph) {
              var path7 = [graph[toModel].parent, toModel];
              var fn = conversions[graph[toModel].parent][toModel];
              var cur = graph[toModel].parent;
              while (graph[cur].parent) {
                path7.unshift(graph[cur].parent);
                fn = link(conversions[graph[cur].parent][cur], fn);
                cur = graph[cur].parent;
              }
              fn.conversion = path7;
              return fn;
            }
            module22.exports = function(fromModel) {
              var graph = deriveBFS(fromModel);
              var conversion = {};
              var models = Object.keys(graph);
              for (var len = models.length, i = 0; i < len; i++) {
                var toModel = models[i];
                var node = graph[toModel];
                if (node.parent === null) {
                  continue;
                }
                conversion[toModel] = wrapConversion(toModel, graph);
              }
              return conversion;
            };
          }
        });
        var require_color_convert2 = __commonJS22({
          "node_modules/color-convert/index.js"(exports22, module22) {
            var conversions = require_conversions2();
            var route = require_route2();
            var convert = {};
            var models = Object.keys(conversions);
            function wrapRaw(fn) {
              var wrappedFn = function(args) {
                if (args === void 0 || args === null) {
                  return args;
                }
                if (arguments.length > 1) {
                  args = Array.prototype.slice.call(arguments);
                }
                return fn(args);
              };
              if ("conversion" in fn) {
                wrappedFn.conversion = fn.conversion;
              }
              return wrappedFn;
            }
            function wrapRounded(fn) {
              var wrappedFn = function(args) {
                if (args === void 0 || args === null) {
                  return args;
                }
                if (arguments.length > 1) {
                  args = Array.prototype.slice.call(arguments);
                }
                var result = fn(args);
                if (typeof result === "object") {
                  for (var len = result.length, i = 0; i < len; i++) {
                    result[i] = Math.round(result[i]);
                  }
                }
                return result;
              };
              if ("conversion" in fn) {
                wrappedFn.conversion = fn.conversion;
              }
              return wrappedFn;
            }
            models.forEach(function(fromModel) {
              convert[fromModel] = {};
              Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
              Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
              var routes = route(fromModel);
              var routeModels = Object.keys(routes);
              routeModels.forEach(function(toModel) {
                var fn = routes[toModel];
                convert[fromModel][toModel] = wrapRounded(fn);
                convert[fromModel][toModel].raw = wrapRaw(fn);
              });
            });
            module22.exports = convert;
          }
        });
        var require_ansi_styles2 = __commonJS22({
          "node_modules/ansi-styles/index.js"(exports22, module22) {
            "use strict";
            var colorConvert = require_color_convert2();
            var wrapAnsi16 = (fn, offset) => function() {
              const code = fn.apply(colorConvert, arguments);
              return `[${code + offset}m`;
            };
            var wrapAnsi256 = (fn, offset) => function() {
              const code = fn.apply(colorConvert, arguments);
              return `[${38 + offset};5;${code}m`;
            };
            var wrapAnsi16m = (fn, offset) => function() {
              const rgb = fn.apply(colorConvert, arguments);
              return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
            };
            function assembleStyles() {
              const codes = new Map();
              const styles = {
                modifier: {
                  reset: [0, 0],
                  bold: [1, 22],
                  dim: [2, 22],
                  italic: [3, 23],
                  underline: [4, 24],
                  inverse: [7, 27],
                  hidden: [8, 28],
                  strikethrough: [9, 29]
                },
                color: {
                  black: [30, 39],
                  red: [31, 39],
                  green: [32, 39],
                  yellow: [33, 39],
                  blue: [34, 39],
                  magenta: [35, 39],
                  cyan: [36, 39],
                  white: [37, 39],
                  gray: [90, 39],
                  redBright: [91, 39],
                  greenBright: [92, 39],
                  yellowBright: [93, 39],
                  blueBright: [94, 39],
                  magentaBright: [95, 39],
                  cyanBright: [96, 39],
                  whiteBright: [97, 39]
                },
                bgColor: {
                  bgBlack: [40, 49],
                  bgRed: [41, 49],
                  bgGreen: [42, 49],
                  bgYellow: [43, 49],
                  bgBlue: [44, 49],
                  bgMagenta: [45, 49],
                  bgCyan: [46, 49],
                  bgWhite: [47, 49],
                  bgBlackBright: [100, 49],
                  bgRedBright: [101, 49],
                  bgGreenBright: [102, 49],
                  bgYellowBright: [103, 49],
                  bgBlueBright: [104, 49],
                  bgMagentaBright: [105, 49],
                  bgCyanBright: [106, 49],
                  bgWhiteBright: [107, 49]
                }
              };
              styles.color.grey = styles.color.gray;
              for (const groupName of Object.keys(styles)) {
                const group = styles[groupName];
                for (const styleName of Object.keys(group)) {
                  const style = group[styleName];
                  styles[styleName] = {
                    open: `[${style[0]}m`,
                    close: `[${style[1]}m`
                  };
                  group[styleName] = styles[styleName];
                  codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                  value: group,
                  enumerable: false
                });
                Object.defineProperty(styles, "codes", {
                  value: codes,
                  enumerable: false
                });
              }
              const ansi2ansi = (n) => n;
              const rgb2rgb = (r, g, b) => [r, g, b];
              styles.color.close = "[39m";
              styles.bgColor.close = "[49m";
              styles.color.ansi = {
                ansi: wrapAnsi16(ansi2ansi, 0)
              };
              styles.color.ansi256 = {
                ansi256: wrapAnsi256(ansi2ansi, 0)
              };
              styles.color.ansi16m = {
                rgb: wrapAnsi16m(rgb2rgb, 0)
              };
              styles.bgColor.ansi = {
                ansi: wrapAnsi16(ansi2ansi, 10)
              };
              styles.bgColor.ansi256 = {
                ansi256: wrapAnsi256(ansi2ansi, 10)
              };
              styles.bgColor.ansi16m = {
                rgb: wrapAnsi16m(rgb2rgb, 10)
              };
              for (let key of Object.keys(colorConvert)) {
                if (typeof colorConvert[key] !== "object") {
                  continue;
                }
                const suite = colorConvert[key];
                if (key === "ansi16") {
                  key = "ansi";
                }
                if ("ansi16" in suite) {
                  styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
                  styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
                }
                if ("ansi256" in suite) {
                  styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
                  styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
                }
                if ("rgb" in suite) {
                  styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
                  styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
                }
              }
              return styles;
            }
            Object.defineProperty(module22, "exports", {
              enumerable: true,
              get: assembleStyles
            });
          }
        });
        var require_has_flag3 = __commonJS22({
          "node_modules/has-flag/index.js"(exports22, module22) {
            "use strict";
            module22.exports = (flag, argv) => {
              argv = argv || process.argv;
              const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
              const pos = argv.indexOf(prefix + flag);
              const terminatorPos = argv.indexOf("--");
              return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
            };
          }
        });
        var require_supports_color3 = __commonJS22({
          "node_modules/supports-color/index.js"(exports22, module22) {
            "use strict";
            var os = require("os");
            var hasFlag = require_has_flag3();
            var env = process.env;
            var forceColor;
            if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
              forceColor = false;
            } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
              forceColor = true;
            }
            if ("FORCE_COLOR" in env) {
              forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
            }
            function translateLevel(level) {
              if (level === 0) {
                return false;
              }
              return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
              };
            }
            function supportsColor(stream) {
              if (forceColor === false) {
                return 0;
              }
              if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
                return 3;
              }
              if (hasFlag("color=256")) {
                return 2;
              }
              if (stream && !stream.isTTY && forceColor !== true) {
                return 0;
              }
              const min = forceColor ? 1 : 0;
              if (process.platform === "win32") {
                const osRelease = os.release().split(".");
                if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
                  return Number(osRelease[2]) >= 14931 ? 3 : 2;
                }
                return 1;
              }
              if ("CI" in env) {
                if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
                  return 1;
                }
                return min;
              }
              if ("TEAMCITY_VERSION" in env) {
                return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
              }
              if (env.COLORTERM === "truecolor") {
                return 3;
              }
              if ("TERM_PROGRAM" in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch (env.TERM_PROGRAM) {
                  case "iTerm.app":
                    return version >= 3 ? 3 : 2;
                  case "Apple_Terminal":
                    return 2;
                }
              }
              if (/-256(color)?$/i.test(env.TERM)) {
                return 2;
              }
              if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
                return 1;
              }
              if ("COLORTERM" in env) {
                return 1;
              }
              if (env.TERM === "dumb") {
                return min;
              }
              return min;
            }
            function getSupportLevel(stream) {
              const level = supportsColor(stream);
              return translateLevel(level);
            }
            module22.exports = {
              supportsColor: getSupportLevel,
              stdout: getSupportLevel(process.stdout),
              stderr: getSupportLevel(process.stderr)
            };
          }
        });
        var require_templates2 = __commonJS22({
          "node_modules/chalk/templates.js"(exports22, module22) {
            "use strict";
            var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
            var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
            var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
            var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
            var ESCAPES = new Map([
              ["n", "\n"],
              ["r", "\r"],
              ["t", "	"],
              ["b", "\b"],
              ["f", "\f"],
              ["v", "\v"],
              ["0", "\0"],
              ["\\", "\\"],
              ["e", ""],
              ["a", "\x07"]
            ]);
            function unescape2(c2) {
              if (c2[0] === "u" && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
                return String.fromCharCode(parseInt(c2.slice(1), 16));
              }
              return ESCAPES.get(c2) || c2;
            }
            function parseArguments(name, args) {
              const results = [];
              const chunks = args.trim().split(/\s*,\s*/g);
              let matches;
              for (const chunk2 of chunks) {
                if (!isNaN(chunk2)) {
                  results.push(Number(chunk2));
                } else if (matches = chunk2.match(STRING_REGEX)) {
                  results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape2(escape) : chr));
                } else {
                  throw new Error(`Invalid Chalk template style argument: ${chunk2} (in style '${name}')`);
                }
              }
              return results;
            }
            function parseStyle(style) {
              STYLE_REGEX.lastIndex = 0;
              const results = [];
              let matches;
              while ((matches = STYLE_REGEX.exec(style)) !== null) {
                const name = matches[1];
                if (matches[2]) {
                  const args = parseArguments(name, matches[2]);
                  results.push([name].concat(args));
                } else {
                  results.push([name]);
                }
              }
              return results;
            }
            function buildStyle(chalk2, styles) {
              const enabled = {};
              for (const layer of styles) {
                for (const style of layer.styles) {
                  enabled[style[0]] = layer.inverse ? null : style.slice(1);
                }
              }
              let current = chalk2;
              for (const styleName of Object.keys(enabled)) {
                if (Array.isArray(enabled[styleName])) {
                  if (!(styleName in current)) {
                    throw new Error(`Unknown Chalk style: ${styleName}`);
                  }
                  if (enabled[styleName].length > 0) {
                    current = current[styleName].apply(current, enabled[styleName]);
                  } else {
                    current = current[styleName];
                  }
                }
              }
              return current;
            }
            module22.exports = (chalk2, tmp) => {
              const styles = [];
              const chunks = [];
              let chunk2 = [];
              tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
                if (escapeChar) {
                  chunk2.push(unescape2(escapeChar));
                } else if (style) {
                  const str = chunk2.join("");
                  chunk2 = [];
                  chunks.push(styles.length === 0 ? str : buildStyle(chalk2, styles)(str));
                  styles.push({ inverse, styles: parseStyle(style) });
                } else if (close) {
                  if (styles.length === 0) {
                    throw new Error("Found extraneous } in Chalk template literal");
                  }
                  chunks.push(buildStyle(chalk2, styles)(chunk2.join("")));
                  chunk2 = [];
                  styles.pop();
                } else {
                  chunk2.push(chr);
                }
              });
              chunks.push(chunk2.join(""));
              if (styles.length > 0) {
                const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
                throw new Error(errMsg);
              }
              return chunks.join("");
            };
          }
        });
        var require_chalk = __commonJS22({
          "node_modules/chalk/index.js"(exports22, module22) {
            "use strict";
            var escapeStringRegexp = require_escape_string_regexp();
            var ansiStyles = require_ansi_styles2();
            var stdoutColor = require_supports_color3().stdout;
            var template = require_templates2();
            var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
            var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
            var skipModels = new Set(["gray"]);
            var styles = Object.create(null);
            function applyOptions(obj, options) {
              options = options || {};
              const scLevel = stdoutColor ? stdoutColor.level : 0;
              obj.level = options.level === void 0 ? scLevel : options.level;
              obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
            }
            function Chalk(options) {
              if (!this || !(this instanceof Chalk) || this.template) {
                const chalk2 = {};
                applyOptions(chalk2, options);
                chalk2.template = function() {
                  const args = [].slice.call(arguments);
                  return chalkTag.apply(null, [chalk2.template].concat(args));
                };
                Object.setPrototypeOf(chalk2, Chalk.prototype);
                Object.setPrototypeOf(chalk2.template, chalk2);
                chalk2.template.constructor = Chalk;
                return chalk2.template;
              }
              applyOptions(this, options);
            }
            if (isSimpleWindowsTerm) {
              ansiStyles.blue.open = "[94m";
            }
            for (const key of Object.keys(ansiStyles)) {
              ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
              styles[key] = {
                get() {
                  const codes = ansiStyles[key];
                  return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
                }
              };
            }
            styles.visible = {
              get() {
                return build.call(this, this._styles || [], true, "visible");
              }
            };
            ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
            for (const model of Object.keys(ansiStyles.color.ansi)) {
              if (skipModels.has(model)) {
                continue;
              }
              styles[model] = {
                get() {
                  const level = this.level;
                  return function() {
                    const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
                    const codes = {
                      open,
                      close: ansiStyles.color.close,
                      closeRe: ansiStyles.color.closeRe
                    };
                    return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
                  };
                }
              };
            }
            ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
            for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
              if (skipModels.has(model)) {
                continue;
              }
              const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
              styles[bgModel] = {
                get() {
                  const level = this.level;
                  return function() {
                    const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
                    const codes = {
                      open,
                      close: ansiStyles.bgColor.close,
                      closeRe: ansiStyles.bgColor.closeRe
                    };
                    return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
                  };
                }
              };
            }
            var proto = Object.defineProperties(() => {
            }, styles);
            function build(_styles, _empty, key) {
              const builder = function() {
                return applyStyle.apply(builder, arguments);
              };
              builder._styles = _styles;
              builder._empty = _empty;
              const self2 = this;
              Object.defineProperty(builder, "level", {
                enumerable: true,
                get() {
                  return self2.level;
                },
                set(level) {
                  self2.level = level;
                }
              });
              Object.defineProperty(builder, "enabled", {
                enumerable: true,
                get() {
                  return self2.enabled;
                },
                set(enabled) {
                  self2.enabled = enabled;
                }
              });
              builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
              builder.__proto__ = proto;
              return builder;
            }
            function applyStyle() {
              const args = arguments;
              const argsLen = args.length;
              let str = String(arguments[0]);
              if (argsLen === 0) {
                return "";
              }
              if (argsLen > 1) {
                for (let a = 1; a < argsLen; a++) {
                  str += " " + args[a];
                }
              }
              if (!this.enabled || this.level <= 0 || !str) {
                return this._empty ? "" : str;
              }
              const originalDim = ansiStyles.dim.open;
              if (isSimpleWindowsTerm && this.hasGrey) {
                ansiStyles.dim.open = "";
              }
              for (const code of this._styles.slice().reverse()) {
                str = code.open + str.replace(code.closeRe, code.open) + code.close;
                str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
              }
              ansiStyles.dim.open = originalDim;
              return str;
            }
            function chalkTag(chalk2, strings) {
              if (!Array.isArray(strings)) {
                return [].slice.call(arguments, 1).join(" ");
              }
              const args = [].slice.call(arguments, 2);
              const parts = [strings.raw[0]];
              for (let i = 1; i < strings.length; i++) {
                parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
                parts.push(String(strings.raw[i]));
              }
              return template(chalk2, parts.join(""));
            }
            Object.defineProperties(Chalk.prototype, styles);
            module22.exports = Chalk();
            module22.exports.supportsColor = stdoutColor;
            module22.exports.default = module22.exports;
          }
        });
        __export22(exports2, {
          aquamarine: () => aquamarine,
          blue: () => blue,
          brightGreen: () => brightGreen,
          captioning: () => captioning,
          coolGold: () => coolGold,
          coolRed: () => coolRed,
          cyan: () => cyan,
          deepOrange: () => deepOrange,
          ensureSlashPrefix: () => ensureSlashPrefix,
          ensureSuffix: () => ensureSuffix,
          fadedBlue: () => fadedBlue,
          fadedSalmon: () => fadedSalmon,
          getAbsFilePath: () => getAbsFilePath_default,
          getBasename: () => getBasename_default,
          getExt: () => getExt,
          getFileStructure: () => getFileStructure_default,
          getFilename: () => getFilename,
          getLinkStructure: () => getLinkStructure_default,
          getPathname: () => getPathname,
          gray: () => gray,
          green: () => green,
          hasDot: () => hasDot,
          hasSlash: () => hasSlash,
          highlight: () => highlight,
          hotpink: () => hotpink,
          isImage: () => isImage_default,
          isJson: () => isJson_default,
          isPdf: () => isPdf_default,
          isVideo: () => isVideo_default,
          isYml: () => isYml_default,
          italic: () => italic,
          lightGold: () => lightGold,
          lightGreen: () => lightGreen,
          lightRed: () => lightRed,
          loadFile: () => loadFile_default,
          loadFileAsDoc: () => loadFileAsDoc,
          loadFiles: () => loadFiles_default,
          loadFilesAsDocs: () => loadFilesAsDocs,
          magenta: () => magenta,
          newline: () => newline,
          normalizePath: () => normalizePath_default,
          orange: () => orange,
          promiseAllSafe: () => promiseAllSafe2,
          readdirSync: () => readdirSync2,
          red: () => red2,
          sortObjPropsByKeys: () => sortObjPropsByKeys,
          stringifyDoc: () => stringifyDoc_default,
          teal: () => teal,
          white: () => white,
          withEngLocale: () => withEngLocale,
          withSuffix: () => withSuffix,
          withTag: () => withTag,
          withYmlExt: () => withYmlExt2,
          withoutExt: () => withoutExt,
          writeFileSync: () => writeFileSync2,
          yellow: () => yellow
        });
        var import_path2 = __toModule22(require("path"));
        var import_path3 = __toModule22(require("path"));
        function normalizePath(...s) {
          let result = (s.length > 1 ? import_path3.default.join(...s) : s[0]).replace(/\\/g, "/");
          if (result.includes("/~/"))
            result = result.replace("~/", "");
          return result;
        }
        var normalizePath_default = normalizePath;
        function getAbsFilePath(...paths) {
          const filepath = normalizePath_default(...paths);
          if ((0, import_path2.isAbsolute)(filepath))
            return filepath;
          return (0, import_path2.resolve)(normalizePath_default(process.cwd(), ...paths));
        }
        var getAbsFilePath_default = getAbsFilePath;
        var import_path32 = __toModule22(require("path"));
        function getBasename(str = "", ext) {
          if (!ext)
            return import_path32.default.posix.basename(str);
          return import_path32.default.posix.basename(str, ext.startsWith(".") ? ext : `.${ext}`);
        }
        var getBasename_default = getBasename;
        var import_path4 = __toModule22(require("path"));
        function isImage(value) {
          return typeof value === "string" && /([./]|image)*(bmp|gif|jpg|jpeg|png|svg|tif)$/i.test(value);
        }
        var isImage_default = isImage;
        function isVideo(value = "") {
          return typeof value === "string" && /([./]|video)*(avi|flac|flv|mkv|mp4|mpg|ogg|wmv)$/i.test(value);
        }
        var isVideo_default = isVideo;
        function getFileStructure(filepath, opts) {
          const parsed = import_path4.default.parse(filepath);
          const structure = {
            dir: parsed.dir,
            ext: parsed.ext,
            filename: parsed.name,
            filepath,
            rootDir: parsed.root
          };
          if (structure.ext === ".yml") {
            if ((opts == null ? void 0 : opts.config) && ((opts == null ? void 0 : opts.config) === parsed.name || (opts == null ? void 0 : opts.config) === parsed.base)) {
              structure.group = "config";
            } else {
              structure.group = "page";
            }
          } else if (isImage_default(parsed.base)) {
            structure.group = "image";
          } else if (structure.ext === ".js") {
            structure.group = "script";
          } else if (/[./]*(doc|docx|json|pdf)$/i.test(parsed.base)) {
            structure.group = "document";
          } else if (isVideo_default(parsed.base)) {
            structure.group = "video";
          } else {
            structure.group = "unknown";
          }
          return structure;
        }
        var getFileStructure_default = getFileStructure;
        var import_path5 = __toModule22(require("path"));
        function getLinkStructure2(link, opts) {
          const parsed = import_path5.default.posix.parse(link);
          const structure = {
            ext: parsed.ext,
            filename: parsed.name,
            isRemote: /^(http|www)/i.test(link),
            url: (opts == null ? void 0 : opts.prefix) ? `${opts.prefix}${opts.prefix.endsWith("/") ? link : `/${link}`}` : link
          };
          if ((opts == null ? void 0 : opts.config) === structure.filename) {
            structure.group = "config";
          } else if (structure.ext.endsWith(".yml")) {
            structure.group = "page";
          } else if (/.*(bmp|gif|jpg|jpeg|png|tif)$/i.test(structure.ext)) {
            structure.group = "image";
          } else if (/.*(doc|docx|json|pdf)$/i.test(structure.ext)) {
            structure.group = "document";
          } else if (/.*(avi|mp4|mkv|wmv)$/i.test(structure.ext)) {
            structure.group = "video";
          } else if (/.*(html|js)$/i.test(structure.ext)) {
            structure.group = "script";
          } else {
            structure.group = "unknown";
          }
          return structure;
        }
        var getLinkStructure_default = getLinkStructure2;
        function isJson(s = "") {
          return s.endsWith(".json");
        }
        var isJson_default = isJson;
        function isPdf(s = "") {
          return s.endsWith(".pdf");
        }
        var isPdf_default = isPdf;
        function isYml(s = "") {
          return s.endsWith(".yml");
        }
        var isYml_default = isYml;
        var u2 = __toModule22(require_dist5());
        var fs = __toModule22(require_lib());
        var import_path6 = __toModule22(require("path"));
        var import_yaml22 = __toModule22(require_dist222());
        function loadFile(filepath, type) {
          if (u2.isStr(filepath)) {
            if (!import_path6.default.isAbsolute(filepath))
              filepath = getAbsFilePath_default(filepath);
            if (fs.existsSync(filepath)) {
              const yml = fs.readFileSync(filepath, "utf8");
              if (type === "doc")
                return (0, import_yaml22.parseDocument)(yml);
              if (type === "json")
                return (0, import_yaml22.parse)(yml);
              return fs.readFileSync(filepath, "utf8");
            }
          }
        }
        var loadFile_default = loadFile;
        var u22 = __toModule22(require_dist5());
        var import_globby = __toModule22(require_globby());
        var import_yaml222 = __toModule22(require_dist222());
        var import_path7 = __toModule22(require("path"));
        function loadFiles(dir, opts = "yml") {
          let ext = "yml";
          let type = "yml";
          if (u22.isStr(dir)) {
            opts === "json" && (ext = "json");
            const glob = `**/*.${ext}`;
            const _path = normalizePath_default(getAbsFilePath_default(import_path7.default.join(dir, glob)));
            if (u22.isStr(opts)) {
              type = opts === "json" ? "json" : opts === "doc" ? "doc" : type;
              return (0, import_globby.sync)(_path, { onlyFiles: true }).map((filepath) => loadFile_default(filepath, type));
            } else if (u22.isObj(opts)) {
              let getKey = function(metadata) {
                return includeExt ? getBasename_default(metadata.filepath) : metadata.filename;
              }, listReducer = function(acc = [], filepath) {
                return acc.concat(loadFile_default(filepath, type));
              }, mapReducer = function(acc, filepath) {
                const metadata = getFileStructure_default(filepath);
                const key = getKey(metadata);
                const data = loadFile_default(filepath, type);
                (0, import_yaml222.isDocument)(data) && data.has(key) && (data.contents = data.get(key));
                if (keysToSpread.includes(key)) {
                  if ((0, import_yaml222.isDocument)(data) && (0, import_yaml222.isMap)(data.contents)) {
                    for (const item of data.contents.items) {
                      const itemKey = item.key;
                      acc.set(itemKey.value, item.value);
                    }
                  } else if (u22.isObj(data)) {
                    for (const [key2, value] of u22.entries(data))
                      acc.set(key2, value);
                  }
                } else {
                  acc.set(key, data);
                }
                return acc;
              }, objectReducer = function(acc, filepath) {
                const metadata = getFileStructure_default(filepath);
                const key = getKey(metadata);
                let data = loadFile_default(filepath, type);
                u22.isObj(data) && key in data && (data = data[key]);
                if (keysToSpread.includes(key) && u22.isObj(data)) {
                  if ((0, import_yaml222.isDocument)(data) && (0, import_yaml222.isMap)(data.contents)) {
                    data.contents.items.forEach((pair) => {
                      acc[String(pair.key)] = pair.value;
                    });
                  } else if (u22.isObj(data)) {
                    u22.assign(acc, data);
                  }
                } else {
                  acc[key] = data;
                }
                return acc;
              };
              type = opts.type || type;
              const includeExt = opts == null ? void 0 : opts.includeExt;
              const keysToSpread = opts.spread ? u22.array(opts.spread) : [];
              const items = (0, import_globby.sync)(_path, { onlyFiles: true });
              if (opts.as === "list")
                return u22.reduce(items, listReducer, []);
              if (opts.as === "map")
                return u22.reduce(items, mapReducer, new Map());
              return u22.reduce(items, objectReducer, {});
            }
          } else if (u22.isObj(dir)) {
          }
        }
        var loadFiles_default = loadFiles;
        var import_yaml3 = __toModule22(require_dist222());
        function stringifyDoc2(doc, opts) {
          let result = "";
          if (doc) {
            if (doc.errors.length) {
              result = (0, import_yaml3.stringify)(doc.errors);
            } else {
              result = doc.toString(__spreadValues2({ singleQuote: true }, opts));
            }
          }
          return result;
        }
        var stringifyDoc_default = stringifyDoc2;
        var u3 = __toModule22(require_dist5());
        var import_chalk2 = __toModule22(require_chalk());
        var import_globby2 = __toModule22(require_globby());
        var import_path8 = __toModule22(require("path"));
        var fs2 = __toModule22(require_lib());
        var import_yaml4 = __toModule22(require_dist222());
        var import_minimatch = __toModule22(require_minimatch());
        var captioning = (...s) => import_chalk2.default.hex("#40E09F")(...s);
        var highlight = (...s) => import_chalk2.default.yellow(...s);
        var italic = (...s) => import_chalk2.default.italic(import_chalk2.default.white(...s));
        var aquamarine = (...s) => import_chalk2.default.keyword("aquamarine")(...s);
        var lightGold = (...s) => import_chalk2.default.keyword("blanchedalmond")(...s);
        var blue = (...s) => import_chalk2.default.keyword("deepskyblue")(...s);
        var fadedBlue = (...s) => import_chalk2.default.blue(...s);
        var cyan = (...s) => import_chalk2.default.cyan(...s);
        var brightGreen = (...s) => import_chalk2.default.keyword("chartreuse")(...s);
        var lightGreen = (...s) => import_chalk2.default.keyword("lightgreen")(...s);
        var green = (...s) => import_chalk2.default.green(...s);
        var coolGold = (...s) => import_chalk2.default.keyword("navajowhite")(...s);
        var gray = (...s) => import_chalk2.default.keyword("lightslategray")(...s);
        var hotpink = (...s) => import_chalk2.default.hex("#F65CA1")(...s);
        var fadedSalmon = (...s) => import_chalk2.default.keyword("darksalmon")(...s);
        var magenta = (...s) => import_chalk2.default.magenta(...s);
        var orange = (...s) => import_chalk2.default.keyword("lightsalmon")(...s);
        var deepOrange = (...s) => import_chalk2.default.hex("#FF8B3F")(...s);
        var lightRed = (...s) => import_chalk2.default.keyword("lightpink")(...s);
        var coolRed = (...s) => import_chalk2.default.keyword("lightcoral")(...s);
        var red2 = (...s) => import_chalk2.default.keyword("tomato")(...s);
        var teal = (...s) => import_chalk2.default.keyword("turquoise")(...s);
        var white = (...s) => import_chalk2.default.whiteBright(...s);
        var yellow = (...s) => import_chalk2.default.yellow(...s);
        var newline = () => console.log("");
        function ensureSlashPrefix(s) {
          if (!s.startsWith("/"))
            s = `/${s}`;
          return s;
        }
        function ensureSuffix(value, s) {
          if (!value.endsWith(s))
            value = `${value}${s}`;
          return value;
        }
        function getExt(str) {
          return hasDot(str) ? str.substring(str.lastIndexOf(".") + 1) : "";
        }
        function getPathname(str) {
          return hasSlash(str) ? str.substring(str.lastIndexOf("/") + 1) : "";
        }
        function getFilename(str) {
          if (!hasSlash(str))
            return str;
          return str.substring(str.lastIndexOf("/") + 1);
        }
        function hasDot(s) {
          return !!(s == null ? void 0 : s.includes("."));
        }
        function hasSlash(s) {
          return !!(s == null ? void 0 : s.includes("/"));
        }
        function loadFileAsDoc(filepath) {
          return (0, import_yaml4.parseDocument)(fs2.readFileSync(filepath, "utf8"));
        }
        function loadFilesAsDocs({
          as = "doc",
          dir,
          includeExt = true,
          recursive = true
        }) {
          const xform = as === "metadataDocs" ? (obj) => ({
            doc: loadFileAsDoc(normalizePath_default(obj.path)),
            name: includeExt ? obj.name : obj.name.includes(".") ? obj.name.substring(0, obj.name.lastIndexOf(".")) : obj.name
          }) : (fpath) => loadFileAsDoc(fpath);
          return (0, import_globby2.sync)(normalizePath_default(dir, recursive ? "**/*.yml" : "*.yml"), {
            stats: as === "metadataDocs",
            onlyFiles: true
          }).map((fpath) => xform(fpath));
        }
        function promiseAllSafe2(...promises) {
          return __async2(this, null, function* () {
            const results = [];
            for (const promise of promises) {
              try {
                const result = yield promise;
                results.push(result);
              } catch (error) {
                results.push(error);
              }
            }
            return results;
          });
        }
        function readdirSync2(dir = __dirname, opts) {
          const args = { encoding: "utf8" };
          const files = [];
          const filepaths = fs2.readdirSync(dir, args);
          const glob = (opts == null ? void 0 : opts.glob) || "**/*";
          for (let filepath of filepaths) {
            filepath = normalizePath_default((0, import_path8.resolve)((0, import_path8.join)(dir, filepath)));
            const stat = fs2.statSync(filepath);
            if (stat.isFile()) {
              if ((0, import_minimatch.default)(filepath, glob))
                files.push(filepath);
            } else if (stat.isDirectory()) {
              files.push(...readdirSync2(filepath, opts));
            }
          }
          return files;
        }
        function sortObjPropsByKeys(obj) {
          return u3.entries(obj).sort((a, b) => {
            if (a[1] > b[1])
              return -1;
            if (a[1] === b[1])
              return 0;
            return 1;
          }).reduce((acc, [key, value]) => Object.assign(acc, { [key]: value }), {});
        }
        function writeFileSync2(filepath = "", data, options) {
          fs2.writeFileSync(normalizePath_default(filepath), data, u3.isStr(options) ? { encoding: options } : __spreadValues2({ encoding: "utf8" }, options));
        }
        function withSuffix(suffix) {
          return function(str) {
            return str.endsWith(suffix) ? str : `${str}${suffix}`;
          };
        }
        var withYmlExt2 = withSuffix(".yml");
        var withEngLocale = withSuffix("_en");
        function withoutExt(str) {
          return hasDot(str) ? str.substring(str.lastIndexOf(".")) : str;
        }
        var withTag = (colorFunc = cyan) => (s) => `[${colorFunc(s)}]`;
      }
    });
    var require_arrayPush = __commonJS2({
      "../../node_modules/lodash/_arrayPush.js"(exports2, module22) {
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        module22.exports = arrayPush;
      }
    });
    var require_freeGlobal = __commonJS2({
      "../../node_modules/lodash/_freeGlobal.js"(exports2, module22) {
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        module22.exports = freeGlobal;
      }
    });
    var require_root = __commonJS2({
      "../../node_modules/lodash/_root.js"(exports2, module22) {
        var freeGlobal = require_freeGlobal();
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        module22.exports = root;
      }
    });
    var require_Symbol = __commonJS2({
      "../../node_modules/lodash/_Symbol.js"(exports2, module22) {
        var root = require_root();
        var Symbol2 = root.Symbol;
        module22.exports = Symbol2;
      }
    });
    var require_getRawTag = __commonJS2({
      "../../node_modules/lodash/_getRawTag.js"(exports2, module22) {
        var Symbol2 = require_Symbol();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        module22.exports = getRawTag;
      }
    });
    var require_objectToString = __commonJS2({
      "../../node_modules/lodash/_objectToString.js"(exports2, module22) {
        var objectProto = Object.prototype;
        var nativeObjectToString = objectProto.toString;
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        module22.exports = objectToString;
      }
    });
    var require_baseGetTag = __commonJS2({
      "../../node_modules/lodash/_baseGetTag.js"(exports2, module22) {
        var Symbol2 = require_Symbol();
        var getRawTag = require_getRawTag();
        var objectToString = require_objectToString();
        var nullTag = "[object Null]";
        var undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        module22.exports = baseGetTag;
      }
    });
    var require_isObjectLike = __commonJS2({
      "../../node_modules/lodash/isObjectLike.js"(exports2, module22) {
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        module22.exports = isObjectLike;
      }
    });
    var require_baseIsArguments = __commonJS2({
      "../../node_modules/lodash/_baseIsArguments.js"(exports2, module22) {
        var baseGetTag = require_baseGetTag();
        var isObjectLike = require_isObjectLike();
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        module22.exports = baseIsArguments;
      }
    });
    var require_isArguments = __commonJS2({
      "../../node_modules/lodash/isArguments.js"(exports2, module22) {
        var baseIsArguments = require_baseIsArguments();
        var isObjectLike = require_isObjectLike();
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        module22.exports = isArguments;
      }
    });
    var require_isArray = __commonJS2({
      "../../node_modules/lodash/isArray.js"(exports2, module22) {
        var isArray = Array.isArray;
        module22.exports = isArray;
      }
    });
    var require_isFlattenable = __commonJS2({
      "../../node_modules/lodash/_isFlattenable.js"(exports2, module22) {
        var Symbol2 = require_Symbol();
        var isArguments = require_isArguments();
        var isArray = require_isArray();
        var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        module22.exports = isFlattenable;
      }
    });
    var require_baseFlatten = __commonJS2({
      "../../node_modules/lodash/_baseFlatten.js"(exports2, module22) {
        var arrayPush = require_arrayPush();
        var isFlattenable = require_isFlattenable();
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        module22.exports = baseFlatten;
      }
    });
    var require_flatten = __commonJS2({
      "../../node_modules/lodash/flatten.js"(exports2, module22) {
        var baseFlatten = require_baseFlatten();
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        module22.exports = flatten2;
      }
    });
    var require_lodash = __commonJS2({
      "node_modules/lodash.get/index.js"(exports2, module22) {
        var FUNC_ERROR_TEXT = "Expected a function";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var INFINITY = 1 / 0;
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var symbolTag = "[object Symbol]";
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
        var reIsPlainProp = /^\w*$/;
        var reLeadingDot = /^\./;
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reEscapeChar = /\\(\\)?/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        var arrayProto = Array.prototype;
        var funcProto = Function.prototype;
        var objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Symbol2 = root.Symbol;
        var splice = arrayProto.splice;
        var Map2 = getNative(root, "Map");
        var nativeCreate = getNative(Object, "create");
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
        var symbolToString = symbolProto ? symbolProto.toString : void 0;
        function Hash(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseGet(object, path2) {
          path2 = isKey(path2, object) ? [path2] : castPath(path2);
          var index = 0, length = path2.length;
          while (object != null && index < length) {
            object = object[toKey(path2[index++])];
          }
          return index && index == length ? object : void 0;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function castPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var stringToPath = memoize(function(string) {
          string = toString(string);
          var result = [];
          if (reLeadingDot.test(string)) {
            result.push("");
          }
          string.replace(rePropName, function(match, number, quote, string2) {
            result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver && typeof resolver != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var isArray = Array.isArray;
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        function get(object, path2, defaultValue) {
          var result = object == null ? void 0 : baseGet(object, path2);
          return result === void 0 ? defaultValue : result;
        }
        module22.exports = get;
      }
    });
    var require_lodash2 = __commonJS2({
      "node_modules/lodash.has/index.js"(exports2, module22) {
        var FUNC_ERROR_TEXT = "Expected a function";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var INFINITY = 1 / 0;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var symbolTag = "[object Symbol]";
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
        var reIsPlainProp = /^\w*$/;
        var reLeadingDot = /^\./;
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reEscapeChar = /\\(\\)?/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        var arrayProto = Array.prototype;
        var funcProto = Function.prototype;
        var objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Symbol2 = root.Symbol;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var splice = arrayProto.splice;
        var Map2 = getNative(root, "Map");
        var nativeCreate = getNative(Object, "create");
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
        var symbolToString = symbolProto ? symbolProto.toString : void 0;
        function Hash(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function castPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        function hasPath(object, path2, hasFunc) {
          path2 = isKey(path2, object) ? [path2] : castPath(path2);
          var result, index = -1, length = path2.length;
          while (++index < length) {
            var key = toKey(path2[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result) {
            return result;
          }
          var length = object ? object.length : 0;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var stringToPath = memoize(function(string) {
          string = toString(string);
          var result = [];
          if (reLeadingDot.test(string)) {
            result.push("");
          }
          string.replace(rePropName, function(match, number, quote, string2) {
            result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver && typeof resolver != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        module22.exports = has;
      }
    });
    var require_lodash3 = __commonJS2({
      "node_modules/lodash.curry/index.js"(exports2, module22) {
        var FUNC_ERROR_TEXT = "Expected a function";
        var PLACEHOLDER = "__lodash_placeholder__";
        var BIND_FLAG = 1;
        var BIND_KEY_FLAG = 2;
        var CURRY_BOUND_FLAG = 4;
        var CURRY_FLAG = 8;
        var CURRY_RIGHT_FLAG = 16;
        var PARTIAL_FLAG = 32;
        var PARTIAL_RIGHT_FLAG = 64;
        var ARY_FLAG = 128;
        var REARG_FLAG = 256;
        var FLIP_FLAG = 512;
        var INFINITY = 1 / 0;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAX_INTEGER = 17976931348623157e292;
        var NAN = 0 / 0;
        var wrapFlags = [
          ["ary", ARY_FLAG],
          ["bind", BIND_FLAG],
          ["bindKey", BIND_KEY_FLAG],
          ["curry", CURRY_FLAG],
          ["curryRight", CURRY_RIGHT_FLAG],
          ["flip", FLIP_FLAG],
          ["partial", PARTIAL_FLAG],
          ["partialRight", PARTIAL_RIGHT_FLAG],
          ["rearg", REARG_FLAG]
        ];
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var symbolTag = "[object Symbol]";
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reTrim = /^\s+|\s+$/g;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
        var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
        var reSplitDetails = /,? & /;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array ? array.length : 0;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayIncludes(array, value) {
          var length = array ? array.length : 0;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          if (value !== value) {
            return baseFindIndex(array, baseIsNaN, fromIndex);
          }
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              result++;
            }
          }
          return result;
        }
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        var funcProto = Function.prototype;
        var objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var objectCreate = Object.create;
        var nativeMax = Math.max;
        var nativeMin = Math.min;
        var defineProperty = function() {
          var func = getNative(Object, "defineProperty"), name = getNative.name;
          return name && name.length > 2 ? func : void 0;
        }();
        function baseCreate(proto) {
          return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
          bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
          if (!(bitmask & CURRY_BOUND_FLAG)) {
            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = void 0;
          }
          ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === void 0 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = void 0;
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary,
            arity
          ];
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
            bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(void 0, newData);
          }
          return setWrapToString(result, func, bitmask);
        }
        function getHolder(func) {
          var object = func;
          return object.placeholder;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function insertWrapDetails(source, details) {
          var length = details.length, lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
          }
          return array;
        }
        var setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {
          var source = reference + "";
          return defineProperty(wrapper, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
          });
        };
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function curry(func, arity, guard) {
          arity = guard ? void 0 : arity;
          var result = createWrap(func, CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result = toFinite(value), remainder = result % 1;
          return result === result ? remainder ? result - remainder : result : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, "");
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        curry.placeholder = {};
        module22.exports = curry;
      }
    });
    var require_lodash4 = __commonJS2({
      "node_modules/lodash.flowright/index.js"(exports2, module22) {
        var FUNC_ERROR_TEXT = "Expected a function";
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var Symbol2 = root.Symbol;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
        var nativeMax = Math.max;
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        function baseRest(func, start) {
          start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = array;
            return apply(func, this, otherArgs);
          };
        }
        function createFlow(fromRight) {
          return baseRest(function(funcs) {
            funcs = baseFlatten(funcs, 1);
            var length = funcs.length, index = length;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              if (typeof funcs[index] != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            return function() {
              var index2 = 0, result = length ? funcs[index2].apply(this, arguments) : arguments[0];
              while (++index2 < length) {
                result = funcs[index2].call(this, result);
              }
              return result;
            };
          });
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        var flowRight = createFlow(true);
        module22.exports = flowRight;
      }
    });
    var require_internal = __commonJS2({
      "node_modules/noodl-utils/dist/_internal.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.unwrapObj = exports2.isFnc = exports2.isUnd = exports2.isStr = exports2.isNum = exports2.isObj = exports2.isBool = exports2.isArr = exports2.array = void 0;
        var array = (o) => exports2.isArr(o) ? o : [o];
        exports2.array = array;
        var isArr2 = (v) => Array.isArray(v);
        exports2.isArr = isArr2;
        var isBool = (v) => typeof v === "boolean";
        exports2.isBool = isBool;
        var isObj = (v) => !!v && !exports2.isArr(v) && typeof v === "object";
        exports2.isObj = isObj;
        var isNum = (v) => typeof v === "number";
        exports2.isNum = isNum;
        var isStr2 = (v) => typeof v === "string";
        exports2.isStr = isStr2;
        var isUnd = (v) => typeof v === "undefined";
        exports2.isUnd = isUnd;
        var isFnc2 = (v) => typeof v === "function";
        exports2.isFnc = isFnc2;
        var unwrapObj = (obj) => exports2.isFnc(obj) ? obj() : obj;
        exports2.unwrapObj = unwrapObj;
      }
    });
    var require_noodl_utils = __commonJS2({
      "node_modules/noodl-utils/dist/noodl-utils.js"(exports2) {
        "use strict";
        var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        });
        var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        });
        var __importStar = exports2 && exports2.__importStar || function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        var __importDefault = exports2 && exports2.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isValidAsset = exports2.isTest = exports2.isStable = exports2.isSerializableStr = exports2.isRootDataKey = exports2.isOutboundLink = exports2.hasNoodlPlaceholder = exports2.getDataValue = exports2.findReferences = exports2.findDataValue = exports2.evalIf = exports2.excludeIteratorVar = exports2.createEmitDataKey = exports2.createNoodlPlaceholderReplacer = exports2.createPlaceholderReplacer = void 0;
        var lodash_get_1 = __importDefault(require_lodash());
        var lodash_has_1 = __importDefault(require_lodash2());
        var lodash_curry_1 = __importDefault(require_lodash3());
        var lodash_flowright_1 = __importDefault(require_lodash4());
        var u2 = __importStar(require_internal());
        function createPlaceholderReplacer(placeholders, flags) {
          const regexp = new RegExp((u2.isArr(placeholders) ? placeholders : [placeholders]).reduce((str, placeholder) => str + (!str ? placeholder : `|${placeholder}`), ""), flags);
          function replace(str, value) {
            if (u2.isStr(str)) {
              return str.replace(regexp, String(value));
            } else if (u2.isObj(str)) {
              const stringified = JSON.stringify(str).replace(regexp, String(value));
              return JSON.parse(stringified);
            }
            return "";
          }
          return replace;
        }
        exports2.createPlaceholderReplacer = createPlaceholderReplacer;
        exports2.createNoodlPlaceholderReplacer = function() {
          const replaceCadlBaseUrl = lodash_curry_1.default(createPlaceholderReplacer("\\${cadlBaseUrl}", "gi"));
          const replaceCadlVersion = lodash_curry_1.default(createPlaceholderReplacer("\\${cadlVersion}", "gi"));
          const replaceDesignSuffix = lodash_curry_1.default(createPlaceholderReplacer("\\${designSuffix}", "gi"));
          const replacerMapper = {
            cadlVersion: replaceCadlVersion,
            designSuffix: replaceDesignSuffix,
            cadlBaseUrl: replaceCadlBaseUrl
          };
          const createReplacer = (keyMap) => {
            let replacers = [];
            let entries = Object.entries(keyMap);
            if (keyMap.cadlBaseUrl && "cadlVersion" in keyMap) {
              keyMap.cadlBaseUrl = replaceCadlBaseUrl(keyMap.cadlBaseUrl, keyMap.cadlVersion);
            }
            for (let index = 0; index < entries.length; index++) {
              const [placeholder, value] = entries[index];
              if (placeholder in replacerMapper) {
                const regexStr = "\\${" + placeholder + "}";
                const regex = new RegExp(regexStr, "gi");
                replacers.push((s) => s.replace(regex, value));
              }
            }
            return lodash_flowright_1.default(...replacers);
          };
          return createReplacer;
        }();
        function createEmitDataKey(dataKey, dataObject, opts) {
          const iteratorVar = (opts === null || opts === void 0 ? void 0 : opts.iteratorVar) || "";
          if (u2.isStr(dataKey)) {
            return exports2.findDataValue(dataObject, excludeIteratorVar(dataKey, iteratorVar));
          } else if (u2.isObj(dataKey)) {
            return Object.keys(dataKey).reduce((acc, property) => {
              acc[property] = exports2.findDataValue(dataObject, excludeIteratorVar(dataKey[property], iteratorVar));
              return acc;
            }, {});
          }
          return dataKey;
        }
        exports2.createEmitDataKey = createEmitDataKey;
        function excludeIteratorVar(dataKey, iteratorVar = "") {
          if (!u2.isStr(dataKey))
            return dataKey;
          if (iteratorVar && dataKey.includes(iteratorVar)) {
            if (dataKey === iteratorVar)
              return "";
            return dataKey.split(`${iteratorVar}.`).join("").replace(iteratorVar, "");
          }
          return dataKey;
        }
        exports2.excludeIteratorVar = excludeIteratorVar;
        function evalIf(fn, ifObj) {
          if (Array.isArray(ifObj.if)) {
            const [val, onTrue, onFalse] = ifObj.if;
            return fn(val, onTrue, onFalse) ? onTrue : onFalse;
          }
          return false;
        }
        exports2.evalIf = evalIf;
        var findDataValue = (objs, path2) => {
          var _a;
          if (!path2)
            return u2.unwrapObj(u2.isArr(objs) ? objs[0] : objs);
          return lodash_get_1.default(u2.unwrapObj((_a = u2.isArr(objs) ? objs : [objs]) === null || _a === void 0 ? void 0 : _a.find((o) => lodash_has_1.default(u2.unwrapObj(o), path2))), path2);
        };
        exports2.findDataValue = findDataValue;
        function findReferences(obj) {
          let results = [];
          (Array.isArray(obj) ? obj : [obj]).forEach((o) => {
            if (u2.isStr(o)) {
              if (o.startsWith("."))
                results.push(o);
            } else if (u2.isArr(o)) {
              results = results.concat(findReferences(o));
            } else if (u2.isObj(o)) {
              for (let key in o) {
                const value = o[key];
                results = results.concat(findReferences(key));
                results = results.concat(findReferences(value));
              }
            }
          });
          return results;
        }
        exports2.findReferences = findReferences;
        function getDataValue(dataObject, dataKey, opts) {
          if (dataObject && typeof dataKey === "string") {
            if (typeof dataObject === "object") {
              let dataPath = "";
              if ((opts === null || opts === void 0 ? void 0 : opts.iteratorVar) && dataKey.startsWith(opts.iteratorVar)) {
                dataPath = dataKey.split(".").slice(1).join(".");
              } else {
                dataPath = dataKey;
              }
              return lodash_get_1.default(dataObject, dataPath);
            }
          }
        }
        exports2.getDataValue = getDataValue;
        exports2.hasNoodlPlaceholder = function() {
          const regex = new RegExp(`(${Object.values({
            cadlBaseUrl: "\\${cadlBaseUrl}",
            cadlVersion: "\\${cadlVersion}",
            designSuffix: "\\${designSuffix}"
          }).join("|")})`, "i");
          function hasPlaceholder(str) {
            return u2.isStr(str) ? regex.test(str) : false;
          }
          return hasPlaceholder;
        }();
        function isOutboundLink(s = "") {
          return /https?:\/\//.test(s);
        }
        exports2.isOutboundLink = isOutboundLink;
        function isRootDataKey(dataKey) {
          if (typeof dataKey === "string") {
            if (dataKey.startsWith(".")) {
              dataKey = dataKey.substring(dataKey.search(/[a-zA-Z]/)).trim();
            }
            if (!/^[a-zA-Z]/i.test(dataKey))
              return false;
            if (dataKey)
              return dataKey[0].toUpperCase() === dataKey[0];
          }
          return false;
        }
        exports2.isRootDataKey = isRootDataKey;
        function isSerializableStr(value) {
          return u2.isStr(value) && /^[a-zA-Z]+[0-9]+/.test(value);
        }
        exports2.isSerializableStr = isSerializableStr;
        function isStable() {
          return process.env.ECOS_ENV === "stable";
        }
        exports2.isStable = isStable;
        function isTest() {
          return process.env.ECOS_ENV === "test";
        }
        exports2.isTest = isTest;
        function isValidAsset2(value) {
          if (value === null || value === void 0 ? void 0 : value.endsWith("..tar"))
            return false;
          return u2.isStr(value) && /(.[a-zA-Z]+)$/i.test(value);
        }
        exports2.isValidAsset = isValidAsset2;
      }
    });
    var require_types = __commonJS2({
      "node_modules/noodl-utils/dist/types.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
      }
    });
    var require_Parser = __commonJS2({
      "node_modules/noodl-utils/dist/Parser.js"(exports2) {
        "use strict";
        var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        });
        var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        });
        var __importStar = exports2 && exports2.__importStar || function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        var u2 = __importStar(require_internal());
        var NoodlUtilsParser = class {
          destination(destination, { denoter = "^", duration = 350 } = {}) {
            var _a;
            const result = {
              destination: "",
              duration,
              id: ""
            };
            if (u2.isStr(destination)) {
              if (destination.includes(denoter)) {
                const denoterIndex = destination.indexOf(denoter);
                result.isSamePage = denoterIndex === 0;
                if (result.isSamePage) {
                  result.destination = "";
                  result.id = destination.replace(denoter, "");
                } else {
                  let parts = (_a = destination.split(denoter)[1]) === null || _a === void 0 ? void 0 : _a.split(";");
                  let propKey = "";
                  let serialized = parts[1] || "";
                  if (serialized.startsWith(";")) {
                    serialized = serialized.replace(";", "");
                  }
                  result.id = parts[0] || "";
                  result.destination = destination.substring(0, denoterIndex);
                  serialized.split(":").forEach((v, index) => index % 2 === 1 ? result[propKey] = v : index % 2 === 0 ? propKey = v : void 0);
                }
              } else {
                result.destination = destination;
                result.isSamePage = false;
              }
            } else {
              result.destination = "";
            }
            return result;
          }
          queryString({ destination = "", pageUrl = "", startPage = "" }) {
            const base = "index.html?";
            pageUrl = pageUrl.startsWith(base) ? pageUrl : pageUrl + base;
            let separator = pageUrl.endsWith("?") ? "" : "-";
            if (destination !== startPage) {
              const questionMarkIndex = pageUrl.indexOf(`?${destination}`);
              const hyphenIndex = pageUrl.indexOf(`-${destination}`);
              if (questionMarkIndex !== -1) {
                pageUrl = pageUrl.substring(0, questionMarkIndex + 1);
                separator = pageUrl.endsWith("?") ? "" : "-";
              } else if (hyphenIndex !== -1) {
                pageUrl = pageUrl.substring(0, hyphenIndex);
                separator = pageUrl.endsWith("?") ? "" : "-";
              }
              pageUrl += `${separator}${destination}`;
            } else {
              pageUrl = base;
            }
            return pageUrl;
          }
        };
        exports2.default = NoodlUtilsParser;
      }
    });
    var require_dist32 = __commonJS2({
      "node_modules/noodl-utils/dist/index.js"(exports2) {
        "use strict";
        var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        });
        var __exportStar = exports2 && exports2.__exportStar || function(m, exports22) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p))
              __createBinding(exports22, m, p);
        };
        var __importDefault = exports2 && exports2.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Parser = void 0;
        __exportStar(require_noodl_utils(), exports2);
        __exportStar(require_types(), exports2);
        var Parser_1 = require_Parser();
        Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
          return __importDefault(Parser_1).default;
        } });
      }
    });
    var require_invariant = __commonJS2({
      "node_modules/invariant/invariant.js"(exports2, module22) {
        "use strict";
        var NODE_ENV = process.env.NODE_ENV;
        var invariant2 = function(condition, format, a, b, c2, d, e, f) {
          if (NODE_ENV !== "production") {
            if (format === void 0) {
              throw new Error("invariant requires an error message argument");
            }
          }
          if (!condition) {
            var error;
            if (format === void 0) {
              error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            } else {
              var args = [a, b, c2, d, e, f];
              var argIndex = 0;
              error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
              }));
              error.name = "Invariant Violation";
            }
            error.framesToPop = 1;
            throw error;
          }
        };
        module22.exports = invariant2;
      }
    });
    var require_bind = __commonJS2({
      "node_modules/axios/lib/helpers/bind.js"(exports2, module22) {
        "use strict";
        module22.exports = function bind(fn, thisArg) {
          return function wrap() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            return fn.apply(thisArg, args);
          };
        };
      }
    });
    var require_utils = __commonJS2({
      "node_modules/axios/lib/utils.js"(exports2, module22) {
        "use strict";
        var bind = require_bind();
        var toString = Object.prototype.toString;
        function isArray(val) {
          return toString.call(val) === "[object Array]";
        }
        function isUndefined(val) {
          return typeof val === "undefined";
        }
        function isBuffer(val) {
          return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
        }
        function isArrayBuffer(val) {
          return toString.call(val) === "[object ArrayBuffer]";
        }
        function isFormData(val) {
          return typeof FormData !== "undefined" && val instanceof FormData;
        }
        function isArrayBufferView(val) {
          var result;
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
            result = ArrayBuffer.isView(val);
          } else {
            result = val && val.buffer && val.buffer instanceof ArrayBuffer;
          }
          return result;
        }
        function isString(val) {
          return typeof val === "string";
        }
        function isNumber(val) {
          return typeof val === "number";
        }
        function isObject(val) {
          return val !== null && typeof val === "object";
        }
        function isPlainObject(val) {
          if (toString.call(val) !== "[object Object]") {
            return false;
          }
          var prototype = Object.getPrototypeOf(val);
          return prototype === null || prototype === Object.prototype;
        }
        function isDate(val) {
          return toString.call(val) === "[object Date]";
        }
        function isFile(val) {
          return toString.call(val) === "[object File]";
        }
        function isBlob(val) {
          return toString.call(val) === "[object Blob]";
        }
        function isFunction(val) {
          return toString.call(val) === "[object Function]";
        }
        function isStream(val) {
          return isObject(val) && isFunction(val.pipe);
        }
        function isURLSearchParams(val) {
          return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
        }
        function trim(str) {
          return str.replace(/^\s*/, "").replace(/\s*$/, "");
        }
        function isStandardBrowserEnv() {
          if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
            return false;
          }
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function forEach(obj, fn) {
          if (obj === null || typeof obj === "undefined") {
            return;
          }
          if (typeof obj !== "object") {
            obj = [obj];
          }
          if (isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; i++) {
              fn.call(null, obj[i], i, obj);
            }
          } else {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
              }
            }
          }
        }
        function merge() {
          var result = {};
          function assignValue(val, key) {
            if (isPlainObject(result[key]) && isPlainObject(val)) {
              result[key] = merge(result[key], val);
            } else if (isPlainObject(val)) {
              result[key] = merge({}, val);
            } else if (isArray(val)) {
              result[key] = val.slice();
            } else {
              result[key] = val;
            }
          }
          for (var i = 0, l = arguments.length; i < l; i++) {
            forEach(arguments[i], assignValue);
          }
          return result;
        }
        function extend(a, b, thisArg) {
          forEach(b, function assignValue(val, key) {
            if (thisArg && typeof val === "function") {
              a[key] = bind(val, thisArg);
            } else {
              a[key] = val;
            }
          });
          return a;
        }
        function stripBOM(content) {
          if (content.charCodeAt(0) === 65279) {
            content = content.slice(1);
          }
          return content;
        }
        module22.exports = {
          isArray,
          isArrayBuffer,
          isBuffer,
          isFormData,
          isArrayBufferView,
          isString,
          isNumber,
          isObject,
          isPlainObject,
          isUndefined,
          isDate,
          isFile,
          isBlob,
          isFunction,
          isStream,
          isURLSearchParams,
          isStandardBrowserEnv,
          forEach,
          merge,
          extend,
          trim,
          stripBOM
        };
      }
    });
    var require_buildURL = __commonJS2({
      "node_modules/axios/lib/helpers/buildURL.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        function encode(val) {
          return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        module22.exports = function buildURL(url, params, paramsSerializer) {
          if (!params) {
            return url;
          }
          var serializedParams;
          if (paramsSerializer) {
            serializedParams = paramsSerializer(params);
          } else if (utils.isURLSearchParams(params)) {
            serializedParams = params.toString();
          } else {
            var parts = [];
            utils.forEach(params, function serialize(val, key) {
              if (val === null || typeof val === "undefined") {
                return;
              }
              if (utils.isArray(val)) {
                key = key + "[]";
              } else {
                val = [val];
              }
              utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) {
                  v = v.toISOString();
                } else if (utils.isObject(v)) {
                  v = JSON.stringify(v);
                }
                parts.push(encode(key) + "=" + encode(v));
              });
            });
            serializedParams = parts.join("&");
          }
          if (serializedParams) {
            var hashmarkIndex = url.indexOf("#");
            if (hashmarkIndex !== -1) {
              url = url.slice(0, hashmarkIndex);
            }
            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
          }
          return url;
        };
      }
    });
    var require_InterceptorManager = __commonJS2({
      "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        function InterceptorManager() {
          this.handlers = [];
        }
        InterceptorManager.prototype.use = function use(fulfilled, rejected) {
          this.handlers.push({
            fulfilled,
            rejected
          });
          return this.handlers.length - 1;
        };
        InterceptorManager.prototype.eject = function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        };
        InterceptorManager.prototype.forEach = function forEach(fn) {
          utils.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
              fn(h);
            }
          });
        };
        module22.exports = InterceptorManager;
      }
    });
    var require_transformData = __commonJS2({
      "node_modules/axios/lib/core/transformData.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        module22.exports = function transformData(data, headers, fns) {
          utils.forEach(fns, function transform(fn) {
            data = fn(data, headers);
          });
          return data;
        };
      }
    });
    var require_isCancel = __commonJS2({
      "node_modules/axios/lib/cancel/isCancel.js"(exports2, module22) {
        "use strict";
        module22.exports = function isCancel(value) {
          return !!(value && value.__CANCEL__);
        };
      }
    });
    var require_normalizeHeaderName = __commonJS2({
      "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        module22.exports = function normalizeHeaderName(headers, normalizedName) {
          utils.forEach(headers, function processHeader(value, name) {
            if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
              headers[normalizedName] = value;
              delete headers[name];
            }
          });
        };
      }
    });
    var require_enhanceError = __commonJS2({
      "node_modules/axios/lib/core/enhanceError.js"(exports2, module22) {
        "use strict";
        module22.exports = function enhanceError(error, config, code, request, response) {
          error.config = config;
          if (code) {
            error.code = code;
          }
          error.request = request;
          error.response = response;
          error.isAxiosError = true;
          error.toJSON = function toJSON() {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: this.config,
              code: this.code
            };
          };
          return error;
        };
      }
    });
    var require_createError = __commonJS2({
      "node_modules/axios/lib/core/createError.js"(exports2, module22) {
        "use strict";
        var enhanceError = require_enhanceError();
        module22.exports = function createError(message, config, code, request, response) {
          var error = new Error(message);
          return enhanceError(error, config, code, request, response);
        };
      }
    });
    var require_settle = __commonJS2({
      "node_modules/axios/lib/core/settle.js"(exports2, module22) {
        "use strict";
        var createError = require_createError();
        module22.exports = function settle(resolve, reject, response) {
          var validateStatus = response.config.validateStatus;
          if (!response.status || !validateStatus || validateStatus(response.status)) {
            resolve(response);
          } else {
            reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
          }
        };
      }
    });
    var require_cookies = __commonJS2({
      "node_modules/axios/lib/helpers/cookies.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        module22.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path2, domain, secure) {
              var cookie = [];
              cookie.push(name + "=" + encodeURIComponent(value));
              if (utils.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
              }
              if (utils.isString(path2)) {
                cookie.push("path=" + path2);
              }
              if (utils.isString(domain)) {
                cookie.push("domain=" + domain);
              }
              if (secure === true) {
                cookie.push("secure");
              }
              document.cookie = cookie.join("; ");
            },
            read: function read(name) {
              var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
              return match ? decodeURIComponent(match[3]) : null;
            },
            remove: function remove(name) {
              this.write(name, "", Date.now() - 864e5);
            }
          };
        }() : function nonStandardBrowserEnv() {
          return {
            write: function write() {
            },
            read: function read() {
              return null;
            },
            remove: function remove() {
            }
          };
        }();
      }
    });
    var require_isAbsoluteURL = __commonJS2({
      "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module22) {
        "use strict";
        module22.exports = function isAbsoluteURL(url) {
          return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
        };
      }
    });
    var require_combineURLs = __commonJS2({
      "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module22) {
        "use strict";
        module22.exports = function combineURLs(baseURL, relativeURL) {
          return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
        };
      }
    });
    var require_buildFullPath = __commonJS2({
      "node_modules/axios/lib/core/buildFullPath.js"(exports2, module22) {
        "use strict";
        var isAbsoluteURL = require_isAbsoluteURL();
        var combineURLs = require_combineURLs();
        module22.exports = function buildFullPath(baseURL, requestedURL) {
          if (baseURL && !isAbsoluteURL(requestedURL)) {
            return combineURLs(baseURL, requestedURL);
          }
          return requestedURL;
        };
      }
    });
    var require_parseHeaders = __commonJS2({
      "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var ignoreDuplicateOf = [
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent"
        ];
        module22.exports = function parseHeaders(headers) {
          var parsed = {};
          var key;
          var val;
          var i;
          if (!headers) {
            return parsed;
          }
          utils.forEach(headers.split("\n"), function parser(line) {
            i = line.indexOf(":");
            key = utils.trim(line.substr(0, i)).toLowerCase();
            val = utils.trim(line.substr(i + 1));
            if (key) {
              if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                return;
              }
              if (key === "set-cookie") {
                parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
              } else {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
              }
            }
          });
          return parsed;
        };
      }
    });
    var require_isURLSameOrigin = __commonJS2({
      "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        module22.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement("a");
          var originURL;
          function resolveURL(url) {
            var href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin(requestURL) {
            var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }() : function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        }();
      }
    });
    var require_xhr = __commonJS2({
      "node_modules/axios/lib/adapters/xhr.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var settle = require_settle();
        var cookies = require_cookies();
        var buildURL = require_buildURL();
        var buildFullPath = require_buildFullPath();
        var parseHeaders = require_parseHeaders();
        var isURLSameOrigin = require_isURLSameOrigin();
        var createError = require_createError();
        module22.exports = function xhrAdapter(config) {
          return new Promise(function dispatchXhrRequest(resolve, reject) {
            var requestData = config.data;
            var requestHeaders = config.headers;
            if (utils.isFormData(requestData)) {
              delete requestHeaders["Content-Type"];
            }
            var request = new XMLHttpRequest();
            if (config.auth) {
              var username = config.auth.username || "";
              var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
              requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
            }
            var fullPath = buildFullPath(config.baseURL, config.url);
            request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
            request.timeout = config.timeout;
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
              var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
              var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
              };
              settle(resolve, reject, response);
              request = null;
            };
            request.onabort = function handleAbort() {
              if (!request) {
                return;
              }
              reject(createError("Request aborted", config, "ECONNABORTED", request));
              request = null;
            };
            request.onerror = function handleError() {
              reject(createError("Network Error", config, null, request));
              request = null;
            };
            request.ontimeout = function handleTimeout() {
              var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
              if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
              }
              reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
              request = null;
            };
            if (utils.isStandardBrowserEnv()) {
              var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
              if (xsrfValue) {
                requestHeaders[config.xsrfHeaderName] = xsrfValue;
              }
            }
            if ("setRequestHeader" in request) {
              utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                  delete requestHeaders[key];
                } else {
                  request.setRequestHeader(key, val);
                }
              });
            }
            if (!utils.isUndefined(config.withCredentials)) {
              request.withCredentials = !!config.withCredentials;
            }
            if (config.responseType) {
              try {
                request.responseType = config.responseType;
              } catch (e) {
                if (config.responseType !== "json") {
                  throw e;
                }
              }
            }
            if (typeof config.onDownloadProgress === "function") {
              request.addEventListener("progress", config.onDownloadProgress);
            }
            if (typeof config.onUploadProgress === "function" && request.upload) {
              request.upload.addEventListener("progress", config.onUploadProgress);
            }
            if (config.cancelToken) {
              config.cancelToken.promise.then(function onCanceled(cancel) {
                if (!request) {
                  return;
                }
                request.abort();
                reject(cancel);
                request = null;
              });
            }
            if (!requestData) {
              requestData = null;
            }
            request.send(requestData);
          });
        };
      }
    });
    var require_ms = __commonJS2({
      "../../node_modules/debug/node_modules/ms/index.js"(exports2, module22) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module22.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
      }
    });
    var require_common = __commonJS2({
      "../../node_modules/debug/src/common.js"(exports2, module22) {
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require_ms();
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            function debug(...args) {
              if (!debug.enabled) {
                return;
              }
              const self2 = debug;
              const curr = Number(new Date());
              const ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self2, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy;
            Object.defineProperty(debug, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug);
            }
            return debug;
          }
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split.length;
            for (i = 0; i < len; i++) {
              if (!split[i]) {
                continue;
              }
              namespaces = split[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }
            return false;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        module22.exports = setup;
      }
    });
    var require_browser = __commonJS2({
      "../../node_modules/debug/src/browser.js"(exports2, module22) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = (() => {
          let warned = false;
          return () => {
            if (!warned) {
              warned = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        })();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module22.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          const c2 = "color: " + this.color;
          args.splice(1, 0, c2, "color: inherit");
          let index = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            if (match === "%%") {
              return;
            }
            index++;
            if (match === "%c") {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c2);
        }
        exports2.log = console.debug || console.log || (() => {
        });
        function save(namespaces) {
          try {
            if (namespaces) {
              exports2.storage.setItem("debug", namespaces);
            } else {
              exports2.storage.removeItem("debug");
            }
          } catch (error) {
          }
        }
        function load() {
          let r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = process.env.DEBUG;
          }
          return r;
        }
        function localstorage() {
          try {
            return localStorage;
          } catch (error) {
          }
        }
        module22.exports = require_common()(exports2);
        var { formatters } = module22.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
          }
        };
      }
    });
    var require_has_flag = __commonJS2({
      "../../node_modules/has-flag/index.js"(exports2, module22) {
        "use strict";
        module22.exports = (flag, argv = process.argv) => {
          const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
          const position = argv.indexOf(prefix + flag);
          const terminatorPosition = argv.indexOf("--");
          return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
        };
      }
    });
    var require_supports_color = __commonJS2({
      "../../node_modules/supports-color/index.js"(exports2, module22) {
        "use strict";
        var os = require("os");
        var tty = require("tty");
        var hasFlag = require_has_flag();
        var { env } = process;
        var forceColor;
        if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
          forceColor = 0;
        } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
          forceColor = 1;
        }
        if ("FORCE_COLOR" in env) {
          if (env.FORCE_COLOR === "true") {
            forceColor = 1;
          } else if (env.FORCE_COLOR === "false") {
            forceColor = 0;
          } else {
            forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
          }
        }
        function translateLevel(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        }
        function supportsColor(haveStream, streamIsTTY) {
          if (forceColor === 0) {
            return 0;
          }
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
            return 3;
          }
          if (hasFlag("color=256")) {
            return 2;
          }
          if (haveStream && !streamIsTTY && forceColor === void 0) {
            return 0;
          }
          const min = forceColor || 0;
          if (env.TERM === "dumb") {
            return min;
          }
          if (process.platform === "win32") {
            const osRelease = os.release().split(".");
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
              return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
          }
          if ("CI" in env) {
            if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
              return 1;
            }
            return min;
          }
          if ("TEAMCITY_VERSION" in env) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          }
          if (env.COLORTERM === "truecolor") {
            return 3;
          }
          if ("TERM_PROGRAM" in env) {
            const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
              case "iTerm.app":
                return version >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          if (/-256(color)?$/i.test(env.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
            return 1;
          }
          if ("COLORTERM" in env) {
            return 1;
          }
          return min;
        }
        function getSupportLevel(stream) {
          const level = supportsColor(stream, stream && stream.isTTY);
          return translateLevel(level);
        }
        module22.exports = {
          supportsColor: getSupportLevel,
          stdout: translateLevel(supportsColor(true, tty.isatty(1))),
          stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
      }
    });
    var require_node = __commonJS2({
      "../../node_modules/debug/src/node.js"(exports2, module22) {
        var tty = require("tty");
        var util = require("util");
        exports2.init = init;
        exports2.log = log2;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.destroy = util.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        exports2.colors = [6, 2, 3, 4, 5, 1];
        try {
          const supportsColor = require_supports_color();
          if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports2.colors = [
              20,
              21,
              26,
              27,
              32,
              33,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              56,
              57,
              62,
              63,
              68,
              69,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              92,
              93,
              98,
              99,
              112,
              113,
              128,
              129,
              134,
              135,
              148,
              149,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              178,
              179,
              184,
              185,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              214,
              215,
              220,
              221
            ];
          }
        } catch (error) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter((key) => {
          return /^debug_/i.test(key);
        }).reduce((obj, key) => {
          const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
        function useColors() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
          const { namespace: name, useColors: useColors2 } = this;
          if (useColors2) {
            const c2 = this.color;
            const colorCode = "[3" + (c2 < 8 ? c2 : "8;5;" + c2);
            const prefix = `  ${colorCode};1m${name} [0m`;
            args[0] = prefix + args[0].split("\n").join("\n" + prefix);
            args.push(colorCode + "m+" + module22.exports.humanize(this.diff) + "[0m");
          } else {
            args[0] = getDate() + name + " " + args[0];
          }
        }
        function getDate() {
          if (exports2.inspectOpts.hideDate) {
            return "";
          }
          return new Date().toISOString() + " ";
        }
        function log2(...args) {
          return process.stderr.write(util.format(...args) + "\n");
        }
        function save(namespaces) {
          if (namespaces) {
            process.env.DEBUG = namespaces;
          } else {
            delete process.env.DEBUG;
          }
        }
        function load() {
          return process.env.DEBUG;
        }
        function init(debug) {
          debug.inspectOpts = {};
          const keys = Object.keys(exports2.inspectOpts);
          for (let i = 0; i < keys.length; i++) {
            debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
          }
        }
        module22.exports = require_common()(exports2);
        var { formatters } = module22.exports;
        formatters.o = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
        };
        formatters.O = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util.inspect(v, this.inspectOpts);
        };
      }
    });
    var require_src = __commonJS2({
      "../../node_modules/debug/src/index.js"(exports2, module22) {
        if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
          module22.exports = require_browser();
        } else {
          module22.exports = require_node();
        }
      }
    });
    var require_debug = __commonJS2({
      "node_modules/follow-redirects/debug.js"(exports2, module22) {
        var debug;
        module22.exports = function() {
          if (!debug) {
            try {
              debug = require_src()("follow-redirects");
            } catch (error) {
              debug = function() {
              };
            }
          }
          debug.apply(null, arguments);
        };
      }
    });
    var require_follow_redirects = __commonJS2({
      "node_modules/follow-redirects/index.js"(exports2, module22) {
        var url = require("url");
        var URL = url.URL;
        var http = require("http");
        var https = require("https");
        var Writable = require("stream").Writable;
        var assert = require("assert");
        var debug = require_debug();
        var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
        var eventHandlers = Object.create(null);
        events.forEach(function(event) {
          eventHandlers[event] = function(arg1, arg2, arg3) {
            this._redirectable.emit(event, arg1, arg2, arg3);
          };
        });
        var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
        var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
        var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
        var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        function RedirectableRequest(options, responseCallback) {
          Writable.call(this);
          this._sanitizeOptions(options);
          this._options = options;
          this._ended = false;
          this._ending = false;
          this._redirectCount = 0;
          this._redirects = [];
          this._requestBodyLength = 0;
          this._requestBodyBuffers = [];
          if (responseCallback) {
            this.on("response", responseCallback);
          }
          var self2 = this;
          this._onNativeResponse = function(response) {
            self2._processResponse(response);
          };
          this._performRequest();
        }
        RedirectableRequest.prototype = Object.create(Writable.prototype);
        RedirectableRequest.prototype.abort = function() {
          abortRequest(this._currentRequest);
          this.emit("abort");
        };
        RedirectableRequest.prototype.write = function(data, encoding, callback) {
          if (this._ending) {
            throw new WriteAfterEndError();
          }
          if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
            throw new TypeError("data should be a string, Buffer or Uint8Array");
          }
          if (typeof encoding === "function") {
            callback = encoding;
            encoding = null;
          }
          if (data.length === 0) {
            if (callback) {
              callback();
            }
            return;
          }
          if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
            this._requestBodyLength += data.length;
            this._requestBodyBuffers.push({ data, encoding });
            this._currentRequest.write(data, encoding, callback);
          } else {
            this.emit("error", new MaxBodyLengthExceededError());
            this.abort();
          }
        };
        RedirectableRequest.prototype.end = function(data, encoding, callback) {
          if (typeof data === "function") {
            callback = data;
            data = encoding = null;
          } else if (typeof encoding === "function") {
            callback = encoding;
            encoding = null;
          }
          if (!data) {
            this._ended = this._ending = true;
            this._currentRequest.end(null, null, callback);
          } else {
            var self2 = this;
            var currentRequest = this._currentRequest;
            this.write(data, encoding, function() {
              self2._ended = true;
              currentRequest.end(null, null, callback);
            });
            this._ending = true;
          }
        };
        RedirectableRequest.prototype.setHeader = function(name, value) {
          this._options.headers[name] = value;
          this._currentRequest.setHeader(name, value);
        };
        RedirectableRequest.prototype.removeHeader = function(name) {
          delete this._options.headers[name];
          this._currentRequest.removeHeader(name);
        };
        RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
          var self2 = this;
          if (callback) {
            this.on("timeout", callback);
          }
          function destroyOnTimeout(socket) {
            socket.setTimeout(msecs);
            socket.removeListener("timeout", socket.destroy);
            socket.addListener("timeout", socket.destroy);
          }
          function startTimer(socket) {
            if (self2._timeout) {
              clearTimeout(self2._timeout);
            }
            self2._timeout = setTimeout(function() {
              self2.emit("timeout");
              clearTimer();
            }, msecs);
            destroyOnTimeout(socket);
          }
          function clearTimer() {
            clearTimeout(this._timeout);
            if (callback) {
              self2.removeListener("timeout", callback);
            }
            if (!this.socket) {
              self2._currentRequest.removeListener("socket", startTimer);
            }
          }
          if (this.socket) {
            startTimer(this.socket);
          } else {
            this._currentRequest.once("socket", startTimer);
          }
          this.on("socket", destroyOnTimeout);
          this.once("response", clearTimer);
          this.once("error", clearTimer);
          return this;
        };
        [
          "flushHeaders",
          "getHeader",
          "setNoDelay",
          "setSocketKeepAlive"
        ].forEach(function(method) {
          RedirectableRequest.prototype[method] = function(a, b) {
            return this._currentRequest[method](a, b);
          };
        });
        ["aborted", "connection", "socket"].forEach(function(property) {
          Object.defineProperty(RedirectableRequest.prototype, property, {
            get: function() {
              return this._currentRequest[property];
            }
          });
        });
        RedirectableRequest.prototype._sanitizeOptions = function(options) {
          if (!options.headers) {
            options.headers = {};
          }
          if (options.host) {
            if (!options.hostname) {
              options.hostname = options.host;
            }
            delete options.host;
          }
          if (!options.pathname && options.path) {
            var searchPos = options.path.indexOf("?");
            if (searchPos < 0) {
              options.pathname = options.path;
            } else {
              options.pathname = options.path.substring(0, searchPos);
              options.search = options.path.substring(searchPos);
            }
          }
        };
        RedirectableRequest.prototype._performRequest = function() {
          var protocol = this._options.protocol;
          var nativeProtocol = this._options.nativeProtocols[protocol];
          if (!nativeProtocol) {
            this.emit("error", new TypeError("Unsupported protocol " + protocol));
            return;
          }
          if (this._options.agents) {
            var scheme = protocol.substr(0, protocol.length - 1);
            this._options.agent = this._options.agents[scheme];
          }
          var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
          this._currentUrl = url.format(this._options);
          request._redirectable = this;
          for (var e = 0; e < events.length; e++) {
            request.on(events[e], eventHandlers[events[e]]);
          }
          if (this._isRedirect) {
            var i = 0;
            var self2 = this;
            var buffers = this._requestBodyBuffers;
            (function writeNext(error) {
              if (request === self2._currentRequest) {
                if (error) {
                  self2.emit("error", error);
                } else if (i < buffers.length) {
                  var buffer = buffers[i++];
                  if (!request.finished) {
                    request.write(buffer.data, buffer.encoding, writeNext);
                  }
                } else if (self2._ended) {
                  request.end();
                }
              }
            })();
          }
        };
        RedirectableRequest.prototype._processResponse = function(response) {
          var statusCode = response.statusCode;
          if (this._options.trackRedirects) {
            this._redirects.push({
              url: this._currentUrl,
              headers: response.headers,
              statusCode
            });
          }
          var location = response.headers.location;
          if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
            abortRequest(this._currentRequest);
            response.destroy();
            if (++this._redirectCount > this._options.maxRedirects) {
              this.emit("error", new TooManyRedirectsError());
              return;
            }
            if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
              this._options.method = "GET";
              this._requestBodyBuffers = [];
              removeMatchingHeaders(/^content-/i, this._options.headers);
            }
            var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
            var redirectUrl = url.resolve(this._currentUrl, location);
            debug("redirecting to", redirectUrl);
            this._isRedirect = true;
            var redirectUrlParts = url.parse(redirectUrl);
            Object.assign(this._options, redirectUrlParts);
            if (redirectUrlParts.hostname !== previousHostName) {
              removeMatchingHeaders(/^authorization$/i, this._options.headers);
            }
            if (typeof this._options.beforeRedirect === "function") {
              var responseDetails = { headers: response.headers };
              try {
                this._options.beforeRedirect.call(null, this._options, responseDetails);
              } catch (err) {
                this.emit("error", err);
                return;
              }
              this._sanitizeOptions(this._options);
            }
            try {
              this._performRequest();
            } catch (cause) {
              var error = new RedirectionError("Redirected request failed: " + cause.message);
              error.cause = cause;
              this.emit("error", error);
            }
          } else {
            response.responseUrl = this._currentUrl;
            response.redirects = this._redirects;
            this.emit("response", response);
            this._requestBodyBuffers = [];
          }
        };
        function wrap(protocols) {
          var exports22 = {
            maxRedirects: 21,
            maxBodyLength: 10 * 1024 * 1024
          };
          var nativeProtocols = {};
          Object.keys(protocols).forEach(function(scheme) {
            var protocol = scheme + ":";
            var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
            var wrappedProtocol = exports22[scheme] = Object.create(nativeProtocol);
            function request(input, options, callback) {
              if (typeof input === "string") {
                var urlStr = input;
                try {
                  input = urlToOptions(new URL(urlStr));
                } catch (err) {
                  input = url.parse(urlStr);
                }
              } else if (URL && input instanceof URL) {
                input = urlToOptions(input);
              } else {
                callback = options;
                options = input;
                input = { protocol };
              }
              if (typeof options === "function") {
                callback = options;
                options = null;
              }
              options = Object.assign({
                maxRedirects: exports22.maxRedirects,
                maxBodyLength: exports22.maxBodyLength
              }, input, options);
              options.nativeProtocols = nativeProtocols;
              assert.equal(options.protocol, protocol, "protocol mismatch");
              debug("options", options);
              return new RedirectableRequest(options, callback);
            }
            function get(input, options, callback) {
              var wrappedRequest = wrappedProtocol.request(input, options, callback);
              wrappedRequest.end();
              return wrappedRequest;
            }
            Object.defineProperties(wrappedProtocol, {
              request: { value: request, configurable: true, enumerable: true, writable: true },
              get: { value: get, configurable: true, enumerable: true, writable: true }
            });
          });
          return exports22;
        }
        function noop() {
        }
        function urlToOptions(urlObject) {
          var options = {
            protocol: urlObject.protocol,
            hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
            hash: urlObject.hash,
            search: urlObject.search,
            pathname: urlObject.pathname,
            path: urlObject.pathname + urlObject.search,
            href: urlObject.href
          };
          if (urlObject.port !== "") {
            options.port = Number(urlObject.port);
          }
          return options;
        }
        function removeMatchingHeaders(regex, headers) {
          var lastValue;
          for (var header in headers) {
            if (regex.test(header)) {
              lastValue = headers[header];
              delete headers[header];
            }
          }
          return lastValue;
        }
        function createErrorType(code, defaultMessage) {
          function CustomError(message) {
            Error.captureStackTrace(this, this.constructor);
            this.message = message || defaultMessage;
          }
          CustomError.prototype = new Error();
          CustomError.prototype.constructor = CustomError;
          CustomError.prototype.name = "Error [" + code + "]";
          CustomError.prototype.code = code;
          return CustomError;
        }
        function abortRequest(request) {
          for (var e = 0; e < events.length; e++) {
            request.removeListener(events[e], eventHandlers[events[e]]);
          }
          request.on("error", noop);
          request.abort();
        }
        module22.exports = wrap({ http, https });
        module22.exports.wrap = wrap;
      }
    });
    var require_package = __commonJS2({
      "node_modules/axios/package.json"(exports2, module22) {
        module22.exports = {
          name: "axios",
          version: "0.21.1",
          description: "Promise based HTTP client for the browser and node.js",
          main: "index.js",
          scripts: {
            test: "grunt test && bundlesize",
            start: "node ./sandbox/server.js",
            build: "NODE_ENV=production grunt build",
            preversion: "npm test",
            version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
            postversion: "git push && git push --tags",
            examples: "node ./examples/server.js",
            coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
            fix: "eslint --fix lib/**/*.js"
          },
          repository: {
            type: "git",
            url: "https://github.com/axios/axios.git"
          },
          keywords: [
            "xhr",
            "http",
            "ajax",
            "promise",
            "node"
          ],
          author: "Matt Zabriskie",
          license: "MIT",
          bugs: {
            url: "https://github.com/axios/axios/issues"
          },
          homepage: "https://github.com/axios/axios",
          devDependencies: {
            bundlesize: "^0.17.0",
            coveralls: "^3.0.0",
            "es6-promise": "^4.2.4",
            grunt: "^1.0.2",
            "grunt-banner": "^0.6.0",
            "grunt-cli": "^1.2.0",
            "grunt-contrib-clean": "^1.1.0",
            "grunt-contrib-watch": "^1.0.0",
            "grunt-eslint": "^20.1.0",
            "grunt-karma": "^2.0.0",
            "grunt-mocha-test": "^0.13.3",
            "grunt-ts": "^6.0.0-beta.19",
            "grunt-webpack": "^1.0.18",
            "istanbul-instrumenter-loader": "^1.0.0",
            "jasmine-core": "^2.4.1",
            karma: "^1.3.0",
            "karma-chrome-launcher": "^2.2.0",
            "karma-coverage": "^1.1.1",
            "karma-firefox-launcher": "^1.1.0",
            "karma-jasmine": "^1.1.1",
            "karma-jasmine-ajax": "^0.1.13",
            "karma-opera-launcher": "^1.0.0",
            "karma-safari-launcher": "^1.0.0",
            "karma-sauce-launcher": "^1.2.0",
            "karma-sinon": "^1.0.5",
            "karma-sourcemap-loader": "^0.3.7",
            "karma-webpack": "^1.7.0",
            "load-grunt-tasks": "^3.5.2",
            minimist: "^1.2.0",
            mocha: "^5.2.0",
            sinon: "^4.5.0",
            typescript: "^2.8.1",
            "url-search-params": "^0.10.0",
            webpack: "^1.13.1",
            "webpack-dev-server": "^1.14.1"
          },
          browser: {
            "./lib/adapters/http.js": "./lib/adapters/xhr.js"
          },
          jsdelivr: "dist/axios.min.js",
          unpkg: "dist/axios.min.js",
          typings: "./index.d.ts",
          dependencies: {
            "follow-redirects": "^1.10.0"
          },
          bundlesize: [
            {
              path: "./dist/axios.min.js",
              threshold: "5kB"
            }
          ]
        };
      }
    });
    var require_http = __commonJS2({
      "node_modules/axios/lib/adapters/http.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var settle = require_settle();
        var buildFullPath = require_buildFullPath();
        var buildURL = require_buildURL();
        var http = require("http");
        var https = require("https");
        var httpFollow = require_follow_redirects().http;
        var httpsFollow = require_follow_redirects().https;
        var url = require("url");
        var zlib = require("zlib");
        var pkg = require_package();
        var createError = require_createError();
        var enhanceError = require_enhanceError();
        var isHttps = /https:?/;
        function setProxy(options, proxy, location) {
          options.hostname = proxy.host;
          options.host = proxy.host;
          options.port = proxy.port;
          options.path = location;
          if (proxy.auth) {
            var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
            options.headers["Proxy-Authorization"] = "Basic " + base64;
          }
          options.beforeRedirect = function beforeRedirect(redirection) {
            redirection.headers.host = redirection.host;
            setProxy(redirection, proxy, redirection.href);
          };
        }
        module22.exports = function httpAdapter(config) {
          return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
            var resolve = function resolve2(value) {
              resolvePromise(value);
            };
            var reject = function reject2(value) {
              rejectPromise(value);
            };
            var data = config.data;
            var headers = config.headers;
            if (!headers["User-Agent"] && !headers["user-agent"]) {
              headers["User-Agent"] = "axios/" + pkg.version;
            }
            if (data && !utils.isStream(data)) {
              if (Buffer.isBuffer(data)) {
              } else if (utils.isArrayBuffer(data)) {
                data = Buffer.from(new Uint8Array(data));
              } else if (utils.isString(data)) {
                data = Buffer.from(data, "utf-8");
              } else {
                return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
              }
              headers["Content-Length"] = data.length;
            }
            var auth = void 0;
            if (config.auth) {
              var username = config.auth.username || "";
              var password = config.auth.password || "";
              auth = username + ":" + password;
            }
            var fullPath = buildFullPath(config.baseURL, config.url);
            var parsed = url.parse(fullPath);
            var protocol = parsed.protocol || "http:";
            if (!auth && parsed.auth) {
              var urlAuth = parsed.auth.split(":");
              var urlUsername = urlAuth[0] || "";
              var urlPassword = urlAuth[1] || "";
              auth = urlUsername + ":" + urlPassword;
            }
            if (auth) {
              delete headers.Authorization;
            }
            var isHttpsRequest = isHttps.test(protocol);
            var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
            var options = {
              path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
              method: config.method.toUpperCase(),
              headers,
              agent,
              agents: { http: config.httpAgent, https: config.httpsAgent },
              auth
            };
            if (config.socketPath) {
              options.socketPath = config.socketPath;
            } else {
              options.hostname = parsed.hostname;
              options.port = parsed.port;
            }
            var proxy = config.proxy;
            if (!proxy && proxy !== false) {
              var proxyEnv = protocol.slice(0, -1) + "_proxy";
              var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
              if (proxyUrl) {
                var parsedProxyUrl = url.parse(proxyUrl);
                var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
                var shouldProxy = true;
                if (noProxyEnv) {
                  var noProxy = noProxyEnv.split(",").map(function trim(s) {
                    return s.trim();
                  });
                  shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                    if (!proxyElement) {
                      return false;
                    }
                    if (proxyElement === "*") {
                      return true;
                    }
                    if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                      return true;
                    }
                    return parsed.hostname === proxyElement;
                  });
                }
                if (shouldProxy) {
                  proxy = {
                    host: parsedProxyUrl.hostname,
                    port: parsedProxyUrl.port,
                    protocol: parsedProxyUrl.protocol
                  };
                  if (parsedProxyUrl.auth) {
                    var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                    proxy.auth = {
                      username: proxyUrlAuth[0],
                      password: proxyUrlAuth[1]
                    };
                  }
                }
              }
            }
            if (proxy) {
              options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
              setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
            }
            var transport;
            var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
            if (config.transport) {
              transport = config.transport;
            } else if (config.maxRedirects === 0) {
              transport = isHttpsProxy ? https : http;
            } else {
              if (config.maxRedirects) {
                options.maxRedirects = config.maxRedirects;
              }
              transport = isHttpsProxy ? httpsFollow : httpFollow;
            }
            if (config.maxBodyLength > -1) {
              options.maxBodyLength = config.maxBodyLength;
            }
            var req = transport.request(options, function handleResponse(res) {
              if (req.aborted)
                return;
              var stream = res;
              var lastRequest = res.req || req;
              if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
                switch (res.headers["content-encoding"]) {
                  case "gzip":
                  case "compress":
                  case "deflate":
                    stream = stream.pipe(zlib.createUnzip());
                    delete res.headers["content-encoding"];
                    break;
                }
              }
              var response = {
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: res.headers,
                config,
                request: lastRequest
              };
              if (config.responseType === "stream") {
                response.data = stream;
                settle(resolve, reject, response);
              } else {
                var responseBuffer = [];
                stream.on("data", function handleStreamData(chunk2) {
                  responseBuffer.push(chunk2);
                  if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
                    stream.destroy();
                    reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
                  }
                });
                stream.on("error", function handleStreamError(err) {
                  if (req.aborted)
                    return;
                  reject(enhanceError(err, config, null, lastRequest));
                });
                stream.on("end", function handleStreamEnd() {
                  var responseData = Buffer.concat(responseBuffer);
                  if (config.responseType !== "arraybuffer") {
                    responseData = responseData.toString(config.responseEncoding);
                    if (!config.responseEncoding || config.responseEncoding === "utf8") {
                      responseData = utils.stripBOM(responseData);
                    }
                  }
                  response.data = responseData;
                  settle(resolve, reject, response);
                });
              }
            });
            req.on("error", function handleRequestError(err) {
              if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
                return;
              reject(enhanceError(err, config, null, req));
            });
            if (config.timeout) {
              req.setTimeout(config.timeout, function handleRequestTimeout() {
                req.abort();
                reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", req));
              });
            }
            if (config.cancelToken) {
              config.cancelToken.promise.then(function onCanceled(cancel) {
                if (req.aborted)
                  return;
                req.abort();
                reject(cancel);
              });
            }
            if (utils.isStream(data)) {
              data.on("error", function handleStreamError(err) {
                reject(enhanceError(err, config, null, req));
              }).pipe(req);
            } else {
              req.end(data);
            }
          });
        };
      }
    });
    var require_defaults = __commonJS2({
      "node_modules/axios/lib/defaults.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var normalizeHeaderName = require_normalizeHeaderName();
        var DEFAULT_CONTENT_TYPE = {
          "Content-Type": "application/x-www-form-urlencoded"
        };
        function setContentTypeIfUnset(headers, value) {
          if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
            headers["Content-Type"] = value;
          }
        }
        function getDefaultAdapter() {
          var adapter;
          if (typeof XMLHttpRequest !== "undefined") {
            adapter = require_xhr();
          } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
            adapter = require_http();
          }
          return adapter;
        }
        var defaults = {
          adapter: getDefaultAdapter(),
          transformRequest: [function transformRequest(data, headers) {
            normalizeHeaderName(headers, "Accept");
            normalizeHeaderName(headers, "Content-Type");
            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
              return data;
            }
            if (utils.isArrayBufferView(data)) {
              return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
              setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
              return data.toString();
            }
            if (utils.isObject(data)) {
              setContentTypeIfUnset(headers, "application/json;charset=utf-8");
              return JSON.stringify(data);
            }
            return data;
          }],
          transformResponse: [function transformResponse(data) {
            if (typeof data === "string") {
              try {
                data = JSON.parse(data);
              } catch (e) {
              }
            }
            return data;
          }],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          }
        };
        defaults.headers = {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        };
        utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
          defaults.headers[method] = {};
        });
        utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
          defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
        });
        module22.exports = defaults;
      }
    });
    var require_dispatchRequest = __commonJS2({
      "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var transformData = require_transformData();
        var isCancel = require_isCancel();
        var defaults = require_defaults();
        function throwIfCancellationRequested(config) {
          if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
          }
        }
        module22.exports = function dispatchRequest(config) {
          throwIfCancellationRequested(config);
          config.headers = config.headers || {};
          config.data = transformData(config.data, config.headers, config.transformRequest);
          config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
          utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
            delete config.headers[method];
          });
          var adapter = config.adapter || defaults.adapter;
          return adapter(config).then(function onAdapterResolution(response) {
            throwIfCancellationRequested(config);
            response.data = transformData(response.data, response.headers, config.transformResponse);
            return response;
          }, function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);
              if (reason && reason.response) {
                reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
              }
            }
            return Promise.reject(reason);
          });
        };
      }
    });
    var require_mergeConfig = __commonJS2({
      "node_modules/axios/lib/core/mergeConfig.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        module22.exports = function mergeConfig(config1, config2) {
          config2 = config2 || {};
          var config = {};
          var valueFromConfig2Keys = ["url", "method", "data"];
          var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
          var defaultToConfig2Keys = [
            "baseURL",
            "transformRequest",
            "transformResponse",
            "paramsSerializer",
            "timeout",
            "timeoutMessage",
            "withCredentials",
            "adapter",
            "responseType",
            "xsrfCookieName",
            "xsrfHeaderName",
            "onUploadProgress",
            "onDownloadProgress",
            "decompress",
            "maxContentLength",
            "maxBodyLength",
            "maxRedirects",
            "transport",
            "httpAgent",
            "httpsAgent",
            "cancelToken",
            "socketPath",
            "responseEncoding"
          ];
          var directMergeKeys = ["validateStatus"];
          function getMergedValue(target, source) {
            if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
              return utils.merge(target, source);
            } else if (utils.isPlainObject(source)) {
              return utils.merge({}, source);
            } else if (utils.isArray(source)) {
              return source.slice();
            }
            return source;
          }
          function mergeDeepProperties(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (!utils.isUndefined(config1[prop])) {
              config[prop] = getMergedValue(void 0, config1[prop]);
            }
          }
          utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(void 0, config2[prop]);
            }
          });
          utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
          utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(void 0, config2[prop]);
            } else if (!utils.isUndefined(config1[prop])) {
              config[prop] = getMergedValue(void 0, config1[prop]);
            }
          });
          utils.forEach(directMergeKeys, function merge(prop) {
            if (prop in config2) {
              config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (prop in config1) {
              config[prop] = getMergedValue(void 0, config1[prop]);
            }
          });
          var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
          var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
            return axiosKeys.indexOf(key) === -1;
          });
          utils.forEach(otherKeys, mergeDeepProperties);
          return config;
        };
      }
    });
    var require_Axios = __commonJS2({
      "node_modules/axios/lib/core/Axios.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var buildURL = require_buildURL();
        var InterceptorManager = require_InterceptorManager();
        var dispatchRequest = require_dispatchRequest();
        var mergeConfig = require_mergeConfig();
        function Axios(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }
        Axios.prototype.request = function request(config) {
          if (typeof config === "string") {
            config = arguments[1] || {};
            config.url = arguments[0];
          } else {
            config = config || {};
          }
          config = mergeConfig(this.defaults, config);
          if (config.method) {
            config.method = config.method.toLowerCase();
          } else if (this.defaults.method) {
            config.method = this.defaults.method.toLowerCase();
          } else {
            config.method = "get";
          }
          var chain = [dispatchRequest, void 0];
          var promise = Promise.resolve(config);
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            chain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            chain.push(interceptor.fulfilled, interceptor.rejected);
          });
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        };
        Axios.prototype.getUri = function getUri(config) {
          config = mergeConfig(this.defaults, config);
          return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
        };
        utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
          Axios.prototype[method] = function(url, config) {
            return this.request(mergeConfig(config || {}, {
              method,
              url,
              data: (config || {}).data
            }));
          };
        });
        utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
          Axios.prototype[method] = function(url, data, config) {
            return this.request(mergeConfig(config || {}, {
              method,
              url,
              data
            }));
          };
        });
        module22.exports = Axios;
      }
    });
    var require_Cancel = __commonJS2({
      "node_modules/axios/lib/cancel/Cancel.js"(exports2, module22) {
        "use strict";
        function Cancel(message) {
          this.message = message;
        }
        Cancel.prototype.toString = function toString() {
          return "Cancel" + (this.message ? ": " + this.message : "");
        };
        Cancel.prototype.__CANCEL__ = true;
        module22.exports = Cancel;
      }
    });
    var require_CancelToken = __commonJS2({
      "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module22) {
        "use strict";
        var Cancel = require_Cancel();
        function CancelToken(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          var resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          var token = this;
          executor(function cancel(message) {
            if (token.reason) {
              return;
            }
            token.reason = new Cancel(message);
            resolvePromise(token.reason);
          });
        }
        CancelToken.prototype.throwIfRequested = function throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        };
        CancelToken.source = function source() {
          var cancel;
          var token = new CancelToken(function executor(c2) {
            cancel = c2;
          });
          return {
            token,
            cancel
          };
        };
        module22.exports = CancelToken;
      }
    });
    var require_spread = __commonJS2({
      "node_modules/axios/lib/helpers/spread.js"(exports2, module22) {
        "use strict";
        module22.exports = function spread(callback) {
          return function wrap(arr) {
            return callback.apply(null, arr);
          };
        };
      }
    });
    var require_isAxiosError = __commonJS2({
      "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module22) {
        "use strict";
        module22.exports = function isAxiosError(payload) {
          return typeof payload === "object" && payload.isAxiosError === true;
        };
      }
    });
    var require_axios = __commonJS2({
      "node_modules/axios/lib/axios.js"(exports2, module22) {
        "use strict";
        var utils = require_utils();
        var bind = require_bind();
        var Axios = require_Axios();
        var mergeConfig = require_mergeConfig();
        var defaults = require_defaults();
        function createInstance(defaultConfig) {
          var context = new Axios(defaultConfig);
          var instance = bind(Axios.prototype.request, context);
          utils.extend(instance, Axios.prototype, context);
          utils.extend(instance, context);
          return instance;
        }
        var axios2 = createInstance(defaults);
        axios2.Axios = Axios;
        axios2.create = function create(instanceConfig) {
          return createInstance(mergeConfig(axios2.defaults, instanceConfig));
        };
        axios2.Cancel = require_Cancel();
        axios2.CancelToken = require_CancelToken();
        axios2.isCancel = require_isCancel();
        axios2.all = function all(promises) {
          return Promise.all(promises);
        };
        axios2.spread = require_spread();
        axios2.isAxiosError = require_isAxiosError();
        module22.exports = axios2;
        module22.exports.default = axios2;
      }
    });
    var require_axios2 = __commonJS2({
      "node_modules/axios/index.js"(exports2, module22) {
        module22.exports = require_axios();
      }
    });
    var require_color_name = __commonJS2({
      "node_modules/color-name/index.js"(exports2, module22) {
        "use strict";
        module22.exports = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
      }
    });
    var require_conversions = __commonJS2({
      "node_modules/color-convert/conversions.js"(exports2, module22) {
        var cssKeywords = require_color_name();
        var reverseKeywords = {};
        for (key in cssKeywords) {
          if (cssKeywords.hasOwnProperty(key)) {
            reverseKeywords[cssKeywords[key]] = key;
          }
        }
        var key;
        var convert = module22.exports = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] }
        };
        for (model in convert) {
          if (convert.hasOwnProperty(model)) {
            if (!("channels" in convert[model])) {
              throw new Error("missing channels property: " + model);
            }
            if (!("labels" in convert[model])) {
              throw new Error("missing channel labels property: " + model);
            }
            if (convert[model].labels.length !== convert[model].channels) {
              throw new Error("channel and label counts mismatch: " + model);
            }
            channels = convert[model].channels;
            labels = convert[model].labels;
            delete convert[model].channels;
            delete convert[model].labels;
            Object.defineProperty(convert[model], "channels", { value: channels });
            Object.defineProperty(convert[model], "labels", { value: labels });
          }
        }
        var channels;
        var labels;
        var model;
        convert.rgb.hsl = function(rgb) {
          var r = rgb[0] / 255;
          var g = rgb[1] / 255;
          var b = rgb[2] / 255;
          var min = Math.min(r, g, b);
          var max = Math.max(r, g, b);
          var delta = max - min;
          var h;
          var s;
          var l;
          if (max === min) {
            h = 0;
          } else if (r === max) {
            h = (g - b) / delta;
          } else if (g === max) {
            h = 2 + (b - r) / delta;
          } else if (b === max) {
            h = 4 + (r - g) / delta;
          }
          h = Math.min(h * 60, 360);
          if (h < 0) {
            h += 360;
          }
          l = (min + max) / 2;
          if (max === min) {
            s = 0;
          } else if (l <= 0.5) {
            s = delta / (max + min);
          } else {
            s = delta / (2 - max - min);
          }
          return [h, s * 100, l * 100];
        };
        convert.rgb.hsv = function(rgb) {
          var rdif;
          var gdif;
          var bdif;
          var h;
          var s;
          var r = rgb[0] / 255;
          var g = rgb[1] / 255;
          var b = rgb[2] / 255;
          var v = Math.max(r, g, b);
          var diff = v - Math.min(r, g, b);
          var diffc = function(c2) {
            return (v - c2) / 6 / diff + 1 / 2;
          };
          if (diff === 0) {
            h = s = 0;
          } else {
            s = diff / v;
            rdif = diffc(r);
            gdif = diffc(g);
            bdif = diffc(b);
            if (r === v) {
              h = bdif - gdif;
            } else if (g === v) {
              h = 1 / 3 + rdif - bdif;
            } else if (b === v) {
              h = 2 / 3 + gdif - rdif;
            }
            if (h < 0) {
              h += 1;
            } else if (h > 1) {
              h -= 1;
            }
          }
          return [
            h * 360,
            s * 100,
            v * 100
          ];
        };
        convert.rgb.hwb = function(rgb) {
          var r = rgb[0];
          var g = rgb[1];
          var b = rgb[2];
          var h = convert.rgb.hsl(rgb)[0];
          var w = 1 / 255 * Math.min(r, Math.min(g, b));
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
          return [h, w * 100, b * 100];
        };
        convert.rgb.cmyk = function(rgb) {
          var r = rgb[0] / 255;
          var g = rgb[1] / 255;
          var b = rgb[2] / 255;
          var c2;
          var m;
          var y;
          var k;
          k = Math.min(1 - r, 1 - g, 1 - b);
          c2 = (1 - r - k) / (1 - k) || 0;
          m = (1 - g - k) / (1 - k) || 0;
          y = (1 - b - k) / (1 - k) || 0;
          return [c2 * 100, m * 100, y * 100, k * 100];
        };
        function comparativeDistance(x, y) {
          return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
        }
        convert.rgb.keyword = function(rgb) {
          var reversed = reverseKeywords[rgb];
          if (reversed) {
            return reversed;
          }
          var currentClosestDistance = Infinity;
          var currentClosestKeyword;
          for (var keyword in cssKeywords) {
            if (cssKeywords.hasOwnProperty(keyword)) {
              var value = cssKeywords[keyword];
              var distance = comparativeDistance(rgb, value);
              if (distance < currentClosestDistance) {
                currentClosestDistance = distance;
                currentClosestKeyword = keyword;
              }
            }
          }
          return currentClosestKeyword;
        };
        convert.keyword.rgb = function(keyword) {
          return cssKeywords[keyword];
        };
        convert.rgb.xyz = function(rgb) {
          var r = rgb[0] / 255;
          var g = rgb[1] / 255;
          var b = rgb[2] / 255;
          r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
          g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
          b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
          var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
          var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
          var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
          return [x * 100, y * 100, z * 100];
        };
        convert.rgb.lab = function(rgb) {
          var xyz = convert.rgb.xyz(rgb);
          var x = xyz[0];
          var y = xyz[1];
          var z = xyz[2];
          var l;
          var a;
          var b;
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
          l = 116 * y - 16;
          a = 500 * (x - y);
          b = 200 * (y - z);
          return [l, a, b];
        };
        convert.hsl.rgb = function(hsl) {
          var h = hsl[0] / 360;
          var s = hsl[1] / 100;
          var l = hsl[2] / 100;
          var t1;
          var t2;
          var t3;
          var rgb;
          var val;
          if (s === 0) {
            val = l * 255;
            return [val, val, val];
          }
          if (l < 0.5) {
            t2 = l * (1 + s);
          } else {
            t2 = l + s - l * s;
          }
          t1 = 2 * l - t2;
          rgb = [0, 0, 0];
          for (var i = 0; i < 3; i++) {
            t3 = h + 1 / 3 * -(i - 1);
            if (t3 < 0) {
              t3++;
            }
            if (t3 > 1) {
              t3--;
            }
            if (6 * t3 < 1) {
              val = t1 + (t2 - t1) * 6 * t3;
            } else if (2 * t3 < 1) {
              val = t2;
            } else if (3 * t3 < 2) {
              val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            } else {
              val = t1;
            }
            rgb[i] = val * 255;
          }
          return rgb;
        };
        convert.hsl.hsv = function(hsl) {
          var h = hsl[0];
          var s = hsl[1] / 100;
          var l = hsl[2] / 100;
          var smin = s;
          var lmin = Math.max(l, 0.01);
          var sv;
          var v;
          l *= 2;
          s *= l <= 1 ? l : 2 - l;
          smin *= lmin <= 1 ? lmin : 2 - lmin;
          v = (l + s) / 2;
          sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
          return [h, sv * 100, v * 100];
        };
        convert.hsv.rgb = function(hsv) {
          var h = hsv[0] / 60;
          var s = hsv[1] / 100;
          var v = hsv[2] / 100;
          var hi = Math.floor(h) % 6;
          var f = h - Math.floor(h);
          var p = 255 * v * (1 - s);
          var q = 255 * v * (1 - s * f);
          var t = 255 * v * (1 - s * (1 - f));
          v *= 255;
          switch (hi) {
            case 0:
              return [v, t, p];
            case 1:
              return [q, v, p];
            case 2:
              return [p, v, t];
            case 3:
              return [p, q, v];
            case 4:
              return [t, p, v];
            case 5:
              return [v, p, q];
          }
        };
        convert.hsv.hsl = function(hsv) {
          var h = hsv[0];
          var s = hsv[1] / 100;
          var v = hsv[2] / 100;
          var vmin = Math.max(v, 0.01);
          var lmin;
          var sl;
          var l;
          l = (2 - s) * v;
          lmin = (2 - s) * vmin;
          sl = s * vmin;
          sl /= lmin <= 1 ? lmin : 2 - lmin;
          sl = sl || 0;
          l /= 2;
          return [h, sl * 100, l * 100];
        };
        convert.hwb.rgb = function(hwb) {
          var h = hwb[0] / 360;
          var wh = hwb[1] / 100;
          var bl = hwb[2] / 100;
          var ratio = wh + bl;
          var i;
          var v;
          var f;
          var n;
          if (ratio > 1) {
            wh /= ratio;
            bl /= ratio;
          }
          i = Math.floor(6 * h);
          v = 1 - bl;
          f = 6 * h - i;
          if ((i & 1) !== 0) {
            f = 1 - f;
          }
          n = wh + f * (v - wh);
          var r;
          var g;
          var b;
          switch (i) {
            default:
            case 6:
            case 0:
              r = v;
              g = n;
              b = wh;
              break;
            case 1:
              r = n;
              g = v;
              b = wh;
              break;
            case 2:
              r = wh;
              g = v;
              b = n;
              break;
            case 3:
              r = wh;
              g = n;
              b = v;
              break;
            case 4:
              r = n;
              g = wh;
              b = v;
              break;
            case 5:
              r = v;
              g = wh;
              b = n;
              break;
          }
          return [r * 255, g * 255, b * 255];
        };
        convert.cmyk.rgb = function(cmyk) {
          var c2 = cmyk[0] / 100;
          var m = cmyk[1] / 100;
          var y = cmyk[2] / 100;
          var k = cmyk[3] / 100;
          var r;
          var g;
          var b;
          r = 1 - Math.min(1, c2 * (1 - k) + k);
          g = 1 - Math.min(1, m * (1 - k) + k);
          b = 1 - Math.min(1, y * (1 - k) + k);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.rgb = function(xyz) {
          var x = xyz[0] / 100;
          var y = xyz[1] / 100;
          var z = xyz[2] / 100;
          var r;
          var g;
          var b;
          r = x * 3.2406 + y * -1.5372 + z * -0.4986;
          g = x * -0.9689 + y * 1.8758 + z * 0.0415;
          b = x * 0.0557 + y * -0.204 + z * 1.057;
          r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
          g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
          b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
          r = Math.min(Math.max(0, r), 1);
          g = Math.min(Math.max(0, g), 1);
          b = Math.min(Math.max(0, b), 1);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.lab = function(xyz) {
          var x = xyz[0];
          var y = xyz[1];
          var z = xyz[2];
          var l;
          var a;
          var b;
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
          l = 116 * y - 16;
          a = 500 * (x - y);
          b = 200 * (y - z);
          return [l, a, b];
        };
        convert.lab.xyz = function(lab) {
          var l = lab[0];
          var a = lab[1];
          var b = lab[2];
          var x;
          var y;
          var z;
          y = (l + 16) / 116;
          x = a / 500 + y;
          z = y - b / 200;
          var y2 = Math.pow(y, 3);
          var x2 = Math.pow(x, 3);
          var z2 = Math.pow(z, 3);
          y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
          x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
          z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
          x *= 95.047;
          y *= 100;
          z *= 108.883;
          return [x, y, z];
        };
        convert.lab.lch = function(lab) {
          var l = lab[0];
          var a = lab[1];
          var b = lab[2];
          var hr;
          var h;
          var c2;
          hr = Math.atan2(b, a);
          h = hr * 360 / 2 / Math.PI;
          if (h < 0) {
            h += 360;
          }
          c2 = Math.sqrt(a * a + b * b);
          return [l, c2, h];
        };
        convert.lch.lab = function(lch) {
          var l = lch[0];
          var c2 = lch[1];
          var h = lch[2];
          var a;
          var b;
          var hr;
          hr = h / 360 * 2 * Math.PI;
          a = c2 * Math.cos(hr);
          b = c2 * Math.sin(hr);
          return [l, a, b];
        };
        convert.rgb.ansi16 = function(args) {
          var r = args[0];
          var g = args[1];
          var b = args[2];
          var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
          value = Math.round(value / 50);
          if (value === 0) {
            return 30;
          }
          var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
          if (value === 2) {
            ansi += 60;
          }
          return ansi;
        };
        convert.hsv.ansi16 = function(args) {
          return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
        };
        convert.rgb.ansi256 = function(args) {
          var r = args[0];
          var g = args[1];
          var b = args[2];
          if (r === g && g === b) {
            if (r < 8) {
              return 16;
            }
            if (r > 248) {
              return 231;
            }
            return Math.round((r - 8) / 247 * 24) + 232;
          }
          var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
          return ansi;
        };
        convert.ansi16.rgb = function(args) {
          var color = args % 10;
          if (color === 0 || color === 7) {
            if (args > 50) {
              color += 3.5;
            }
            color = color / 10.5 * 255;
            return [color, color, color];
          }
          var mult = (~~(args > 50) + 1) * 0.5;
          var r = (color & 1) * mult * 255;
          var g = (color >> 1 & 1) * mult * 255;
          var b = (color >> 2 & 1) * mult * 255;
          return [r, g, b];
        };
        convert.ansi256.rgb = function(args) {
          if (args >= 232) {
            var c2 = (args - 232) * 10 + 8;
            return [c2, c2, c2];
          }
          args -= 16;
          var rem;
          var r = Math.floor(args / 36) / 5 * 255;
          var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
          var b = rem % 6 / 5 * 255;
          return [r, g, b];
        };
        convert.rgb.hex = function(args) {
          var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
          var string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.hex.rgb = function(args) {
          var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!match) {
            return [0, 0, 0];
          }
          var colorString = match[0];
          if (match[0].length === 3) {
            colorString = colorString.split("").map(function(char) {
              return char + char;
            }).join("");
          }
          var integer = parseInt(colorString, 16);
          var r = integer >> 16 & 255;
          var g = integer >> 8 & 255;
          var b = integer & 255;
          return [r, g, b];
        };
        convert.rgb.hcg = function(rgb) {
          var r = rgb[0] / 255;
          var g = rgb[1] / 255;
          var b = rgb[2] / 255;
          var max = Math.max(Math.max(r, g), b);
          var min = Math.min(Math.min(r, g), b);
          var chroma = max - min;
          var grayscale;
          var hue;
          if (chroma < 1) {
            grayscale = min / (1 - chroma);
          } else {
            grayscale = 0;
          }
          if (chroma <= 0) {
            hue = 0;
          } else if (max === r) {
            hue = (g - b) / chroma % 6;
          } else if (max === g) {
            hue = 2 + (b - r) / chroma;
          } else {
            hue = 4 + (r - g) / chroma + 4;
          }
          hue /= 6;
          hue %= 1;
          return [hue * 360, chroma * 100, grayscale * 100];
        };
        convert.hsl.hcg = function(hsl) {
          var s = hsl[1] / 100;
          var l = hsl[2] / 100;
          var c2 = 1;
          var f = 0;
          if (l < 0.5) {
            c2 = 2 * s * l;
          } else {
            c2 = 2 * s * (1 - l);
          }
          if (c2 < 1) {
            f = (l - 0.5 * c2) / (1 - c2);
          }
          return [hsl[0], c2 * 100, f * 100];
        };
        convert.hsv.hcg = function(hsv) {
          var s = hsv[1] / 100;
          var v = hsv[2] / 100;
          var c2 = s * v;
          var f = 0;
          if (c2 < 1) {
            f = (v - c2) / (1 - c2);
          }
          return [hsv[0], c2 * 100, f * 100];
        };
        convert.hcg.rgb = function(hcg) {
          var h = hcg[0] / 360;
          var c2 = hcg[1] / 100;
          var g = hcg[2] / 100;
          if (c2 === 0) {
            return [g * 255, g * 255, g * 255];
          }
          var pure = [0, 0, 0];
          var hi = h % 1 * 6;
          var v = hi % 1;
          var w = 1 - v;
          var mg = 0;
          switch (Math.floor(hi)) {
            case 0:
              pure[0] = 1;
              pure[1] = v;
              pure[2] = 0;
              break;
            case 1:
              pure[0] = w;
              pure[1] = 1;
              pure[2] = 0;
              break;
            case 2:
              pure[0] = 0;
              pure[1] = 1;
              pure[2] = v;
              break;
            case 3:
              pure[0] = 0;
              pure[1] = w;
              pure[2] = 1;
              break;
            case 4:
              pure[0] = v;
              pure[1] = 0;
              pure[2] = 1;
              break;
            default:
              pure[0] = 1;
              pure[1] = 0;
              pure[2] = w;
          }
          mg = (1 - c2) * g;
          return [
            (c2 * pure[0] + mg) * 255,
            (c2 * pure[1] + mg) * 255,
            (c2 * pure[2] + mg) * 255
          ];
        };
        convert.hcg.hsv = function(hcg) {
          var c2 = hcg[1] / 100;
          var g = hcg[2] / 100;
          var v = c2 + g * (1 - c2);
          var f = 0;
          if (v > 0) {
            f = c2 / v;
          }
          return [hcg[0], f * 100, v * 100];
        };
        convert.hcg.hsl = function(hcg) {
          var c2 = hcg[1] / 100;
          var g = hcg[2] / 100;
          var l = g * (1 - c2) + 0.5 * c2;
          var s = 0;
          if (l > 0 && l < 0.5) {
            s = c2 / (2 * l);
          } else if (l >= 0.5 && l < 1) {
            s = c2 / (2 * (1 - l));
          }
          return [hcg[0], s * 100, l * 100];
        };
        convert.hcg.hwb = function(hcg) {
          var c2 = hcg[1] / 100;
          var g = hcg[2] / 100;
          var v = c2 + g * (1 - c2);
          return [hcg[0], (v - c2) * 100, (1 - v) * 100];
        };
        convert.hwb.hcg = function(hwb) {
          var w = hwb[1] / 100;
          var b = hwb[2] / 100;
          var v = 1 - b;
          var c2 = v - w;
          var g = 0;
          if (c2 < 1) {
            g = (v - c2) / (1 - c2);
          }
          return [hwb[0], c2 * 100, g * 100];
        };
        convert.apple.rgb = function(apple) {
          return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
        };
        convert.rgb.apple = function(rgb) {
          return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
        };
        convert.gray.rgb = function(args) {
          return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
        };
        convert.gray.hsl = convert.gray.hsv = function(args) {
          return [0, 0, args[0]];
        };
        convert.gray.hwb = function(gray) {
          return [0, 100, gray[0]];
        };
        convert.gray.cmyk = function(gray) {
          return [0, 0, 0, gray[0]];
        };
        convert.gray.lab = function(gray) {
          return [gray[0], 0, 0];
        };
        convert.gray.hex = function(gray) {
          var val = Math.round(gray[0] / 100 * 255) & 255;
          var integer = (val << 16) + (val << 8) + val;
          var string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.rgb.gray = function(rgb) {
          var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
          return [val / 255 * 100];
        };
      }
    });
    var require_route = __commonJS2({
      "node_modules/color-convert/route.js"(exports2, module22) {
        var conversions = require_conversions();
        function buildGraph() {
          var graph = {};
          var models = Object.keys(conversions);
          for (var len = models.length, i = 0; i < len; i++) {
            graph[models[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            var current = queue.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i = 0; i < len; i++) {
              var adjacent = adjacents[i];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from, to) {
          return function(args) {
            return to(from(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path2 = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path2.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path2;
          return fn;
        }
        module22.exports = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models = Object.keys(graph);
          for (var len = models.length, i = 0; i < len; i++) {
            var toModel = models[i];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
      }
    });
    var require_color_convert = __commonJS2({
      "node_modules/color-convert/index.js"(exports2, module22) {
        var conversions = require_conversions();
        var route = require_route();
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result = fn(args);
            if (typeof result === "object") {
              for (var len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        module22.exports = convert;
      }
    });
    var require_ansi_styles = __commonJS2({
      "node_modules/ansi-styles/index.js"(exports2, module22) {
        "use strict";
        var wrapAnsi16 = (fn, offset) => (...args) => {
          const code = fn(...args);
          return `[${code + offset}m`;
        };
        var wrapAnsi256 = (fn, offset) => (...args) => {
          const code = fn(...args);
          return `[${38 + offset};5;${code}m`;
        };
        var wrapAnsi16m = (fn, offset) => (...args) => {
          const rgb = fn(...args);
          return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
        };
        var ansi2ansi = (n) => n;
        var rgb2rgb = (r, g, b) => [r, g, b];
        var setLazyProperty = (object, property, get) => {
          Object.defineProperty(object, property, {
            get: () => {
              const value = get();
              Object.defineProperty(object, property, {
                value,
                enumerable: true,
                configurable: true
              });
              return value;
            },
            enumerable: true,
            configurable: true
          });
        };
        var colorConvert;
        var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
          if (colorConvert === void 0) {
            colorConvert = require_color_convert();
          }
          const offset = isBackground ? 10 : 0;
          const styles = {};
          for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
            const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
            if (sourceSpace === targetSpace) {
              styles[name] = wrap(identity, offset);
            } else if (typeof suite === "object") {
              styles[name] = wrap(suite[targetSpace], offset);
            }
          }
          return styles;
        };
        function assembleStyles() {
          const codes = new Map();
          const styles = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29]
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39]
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49]
            }
          };
          styles.color.gray = styles.color.blackBright;
          styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
          styles.color.grey = styles.color.blackBright;
          styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
          for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style] of Object.entries(group)) {
              styles[styleName] = {
                open: `[${style[0]}m`,
                close: `[${style[1]}m`
              };
              group[styleName] = styles[styleName];
              codes.set(style[0], style[1]);
            }
            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: false
            });
          }
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
          styles.color.close = "[39m";
          styles.bgColor.close = "[49m";
          setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
          setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
          return styles;
        }
        Object.defineProperty(module22, "exports", {
          enumerable: true,
          get: assembleStyles
        });
      }
    });
    var require_has_flag2 = __commonJS2({
      "node_modules/has-flag/index.js"(exports2, module22) {
        "use strict";
        module22.exports = (flag, argv = process.argv) => {
          const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
          const position = argv.indexOf(prefix + flag);
          const terminatorPosition = argv.indexOf("--");
          return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
        };
      }
    });
    var require_supports_color2 = __commonJS2({
      "node_modules/supports-color/index.js"(exports2, module22) {
        "use strict";
        var os = require("os");
        var tty = require("tty");
        var hasFlag = require_has_flag2();
        var { env } = process;
        var forceColor;
        if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
          forceColor = 0;
        } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
          forceColor = 1;
        }
        if ("FORCE_COLOR" in env) {
          if (env.FORCE_COLOR === "true") {
            forceColor = 1;
          } else if (env.FORCE_COLOR === "false") {
            forceColor = 0;
          } else {
            forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
          }
        }
        function translateLevel(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        }
        function supportsColor(haveStream, streamIsTTY) {
          if (forceColor === 0) {
            return 0;
          }
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
            return 3;
          }
          if (hasFlag("color=256")) {
            return 2;
          }
          if (haveStream && !streamIsTTY && forceColor === void 0) {
            return 0;
          }
          const min = forceColor || 0;
          if (env.TERM === "dumb") {
            return min;
          }
          if (process.platform === "win32") {
            const osRelease = os.release().split(".");
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
              return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
          }
          if ("CI" in env) {
            if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
              return 1;
            }
            return min;
          }
          if ("TEAMCITY_VERSION" in env) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          }
          if (env.COLORTERM === "truecolor") {
            return 3;
          }
          if ("TERM_PROGRAM" in env) {
            const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
              case "iTerm.app":
                return version >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          if (/-256(color)?$/i.test(env.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
            return 1;
          }
          if ("COLORTERM" in env) {
            return 1;
          }
          return min;
        }
        function getSupportLevel(stream) {
          const level = supportsColor(stream, stream && stream.isTTY);
          return translateLevel(level);
        }
        module22.exports = {
          supportsColor: getSupportLevel,
          stdout: translateLevel(supportsColor(true, tty.isatty(1))),
          stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
      }
    });
    var require_util = __commonJS2({
      "node_modules/chalk/source/util.js"(exports2, module22) {
        "use strict";
        var stringReplaceAll = (string, substring, replacer) => {
          let index = string.indexOf(substring);
          if (index === -1) {
            return string;
          }
          const substringLength = substring.length;
          let endIndex = 0;
          let returnValue = "";
          do {
            returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
            endIndex = index + substringLength;
            index = string.indexOf(substring, endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        };
        var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
          let endIndex = 0;
          let returnValue = "";
          do {
            const gotCR = string[index - 1] === "\r";
            returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
            endIndex = index + 1;
            index = string.indexOf("\n", endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        };
        module22.exports = {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        };
      }
    });
    var require_templates = __commonJS2({
      "node_modules/chalk/source/templates.js"(exports2, module22) {
        "use strict";
        var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
        var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
        var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
        var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
        var ESCAPES = new Map([
          ["n", "\n"],
          ["r", "\r"],
          ["t", "	"],
          ["b", "\b"],
          ["f", "\f"],
          ["v", "\v"],
          ["0", "\0"],
          ["\\", "\\"],
          ["e", ""],
          ["a", "\x07"]
        ]);
        function unescape2(c2) {
          const u2 = c2[0] === "u";
          const bracket = c2[1] === "{";
          if (u2 && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
            return String.fromCharCode(parseInt(c2.slice(1), 16));
          }
          if (u2 && bracket) {
            return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
          }
          return ESCAPES.get(c2) || c2;
        }
        function parseArguments(name, arguments_) {
          const results = [];
          const chunks = arguments_.trim().split(/\s*,\s*/g);
          let matches;
          for (const chunk2 of chunks) {
            const number = Number(chunk2);
            if (!Number.isNaN(number)) {
              results.push(number);
            } else if (matches = chunk2.match(STRING_REGEX)) {
              results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
            } else {
              throw new Error(`Invalid Chalk template style argument: ${chunk2} (in style '${name}')`);
            }
          }
          return results;
        }
        function parseStyle(style) {
          STYLE_REGEX.lastIndex = 0;
          const results = [];
          let matches;
          while ((matches = STYLE_REGEX.exec(style)) !== null) {
            const name = matches[1];
            if (matches[2]) {
              const args = parseArguments(name, matches[2]);
              results.push([name].concat(args));
            } else {
              results.push([name]);
            }
          }
          return results;
        }
        function buildStyle(chalk2, styles) {
          const enabled = {};
          for (const layer of styles) {
            for (const style of layer.styles) {
              enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
          }
          let current = chalk2;
          for (const [styleName, styles2] of Object.entries(enabled)) {
            if (!Array.isArray(styles2)) {
              continue;
            }
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
          }
          return current;
        }
        module22.exports = (chalk2, temporary) => {
          const styles = [];
          const chunks = [];
          let chunk2 = [];
          temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
            if (escapeCharacter) {
              chunk2.push(unescape2(escapeCharacter));
            } else if (style) {
              const string = chunk2.join("");
              chunk2 = [];
              chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
              styles.push({ inverse, styles: parseStyle(style) });
            } else if (close) {
              if (styles.length === 0) {
                throw new Error("Found extraneous } in Chalk template literal");
              }
              chunks.push(buildStyle(chalk2, styles)(chunk2.join("")));
              chunk2 = [];
              styles.pop();
            } else {
              chunk2.push(character);
            }
          });
          chunks.push(chunk2.join(""));
          if (styles.length > 0) {
            const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
            throw new Error(errMessage);
          }
          return chunks.join("");
        };
      }
    });
    var require_source = __commonJS2({
      "node_modules/chalk/source/index.js"(exports2, module22) {
        "use strict";
        var ansiStyles = require_ansi_styles();
        var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color2();
        var {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        } = require_util();
        var { isArray } = Array;
        var levelMapping = [
          "ansi",
          "ansi",
          "ansi256",
          "ansi16m"
        ];
        var styles = Object.create(null);
        var applyOptions = (object, options = {}) => {
          if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
            throw new Error("The `level` option should be an integer from 0 to 3");
          }
          const colorLevel = stdoutColor ? stdoutColor.level : 0;
          object.level = options.level === void 0 ? colorLevel : options.level;
        };
        var ChalkClass = class {
          constructor(options) {
            return chalkFactory(options);
          }
        };
        var chalkFactory = (options) => {
          const chalk3 = {};
          applyOptions(chalk3, options);
          chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
          Object.setPrototypeOf(chalk3, Chalk.prototype);
          Object.setPrototypeOf(chalk3.template, chalk3);
          chalk3.template.constructor = () => {
            throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
          };
          chalk3.template.Instance = ChalkClass;
          return chalk3.template;
        };
        function Chalk(options) {
          return chalkFactory(options);
        }
        for (const [styleName, style] of Object.entries(ansiStyles)) {
          styles[styleName] = {
            get() {
              const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
              Object.defineProperty(this, styleName, { value: builder });
              return builder;
            }
          };
        }
        styles.visible = {
          get() {
            const builder = createBuilder(this, this._styler, true);
            Object.defineProperty(this, "visible", { value: builder });
            return builder;
          }
        };
        var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
        for (const model of usedModels) {
          styles[model] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        for (const model of usedModels) {
          const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
          styles[bgModel] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        var proto = Object.defineProperties(() => {
        }, __spreadProps(__spreadValues({}, styles), {
          level: {
            enumerable: true,
            get() {
              return this._generator.level;
            },
            set(level) {
              this._generator.level = level;
            }
          }
        }));
        var createStyler = (open, close, parent) => {
          let openAll;
          let closeAll;
          if (parent === void 0) {
            openAll = open;
            closeAll = close;
          } else {
            openAll = parent.openAll + open;
            closeAll = close + parent.closeAll;
          }
          return {
            open,
            close,
            openAll,
            closeAll,
            parent
          };
        };
        var createBuilder = (self2, _styler, _isEmpty) => {
          const builder = (...arguments_) => {
            if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
              return applyStyle(builder, chalkTag(builder, ...arguments_));
            }
            return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
          };
          Object.setPrototypeOf(builder, proto);
          builder._generator = self2;
          builder._styler = _styler;
          builder._isEmpty = _isEmpty;
          return builder;
        };
        var applyStyle = (self2, string) => {
          if (self2.level <= 0 || !string) {
            return self2._isEmpty ? "" : string;
          }
          let styler = self2._styler;
          if (styler === void 0) {
            return string;
          }
          const { openAll, closeAll } = styler;
          if (string.indexOf("") !== -1) {
            while (styler !== void 0) {
              string = stringReplaceAll(string, styler.close, styler.open);
              styler = styler.parent;
            }
          }
          const lfIndex = string.indexOf("\n");
          if (lfIndex !== -1) {
            string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
          }
          return openAll + string + closeAll;
        };
        var template;
        var chalkTag = (chalk3, ...strings) => {
          const [firstString] = strings;
          if (!isArray(firstString) || !isArray(firstString.raw)) {
            return strings.join(" ");
          }
          const arguments_ = strings.slice(1);
          const parts = [firstString.raw[0]];
          for (let i = 1; i < firstString.length; i++) {
            parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
          }
          if (template === void 0) {
            template = require_templates();
          }
          return template(chalk3, parts.join(""));
        };
        Object.defineProperties(Chalk.prototype, styles);
        var chalk2 = Chalk();
        chalk2.supportsColor = stdoutColor;
        chalk2.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
        chalk2.stderr.supportsColor = stderrColor;
        module22.exports = chalk2;
      }
    });
    var require_Node2 = __commonJS2({
      "node_modules/yaml/dist/nodes/Node.js"(exports2) {
        "use strict";
        var ALIAS = Symbol.for("yaml.alias");
        var DOC = Symbol.for("yaml.document");
        var MAP = Symbol.for("yaml.map");
        var PAIR = Symbol.for("yaml.pair");
        var SCALAR = Symbol.for("yaml.scalar");
        var SEQ = Symbol.for("yaml.seq");
        var NODE_TYPE = Symbol.for("yaml.node.type");
        var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
        var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
        var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
        var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
        var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
        var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
        function isCollection(node) {
          if (node && typeof node === "object")
            switch (node[NODE_TYPE]) {
              case MAP:
              case SEQ:
                return true;
            }
          return false;
        }
        function isNode(node) {
          if (node && typeof node === "object")
            switch (node[NODE_TYPE]) {
              case ALIAS:
              case MAP:
              case SCALAR:
              case SEQ:
                return true;
            }
          return false;
        }
        var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
        var NodeBase = class {
          constructor(type) {
            Object.defineProperty(this, NODE_TYPE, { value: type });
          }
        };
        exports2.ALIAS = ALIAS;
        exports2.DOC = DOC;
        exports2.MAP = MAP;
        exports2.NODE_TYPE = NODE_TYPE;
        exports2.NodeBase = NodeBase;
        exports2.PAIR = PAIR;
        exports2.SCALAR = SCALAR;
        exports2.SEQ = SEQ;
        exports2.hasAnchor = hasAnchor;
        exports2.isAlias = isAlias;
        exports2.isCollection = isCollection;
        exports2.isDocument = isDocument;
        exports2.isMap = isMap;
        exports2.isNode = isNode;
        exports2.isPair = isPair;
        exports2.isScalar = isScalar;
        exports2.isSeq = isSeq;
      }
    });
    var require_visit2 = __commonJS2({
      "node_modules/yaml/dist/visit.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var BREAK = Symbol("break visit");
        var SKIP = Symbol("skip children");
        var REMOVE = Symbol("remove node");
        function visit(node, visitor) {
          if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
            visitor = Object.assign({
              Alias: visitor.Node,
              Map: visitor.Node,
              Scalar: visitor.Node,
              Seq: visitor.Node
            }, visitor.Value && {
              Map: visitor.Value,
              Scalar: visitor.Value,
              Seq: visitor.Value
            }, visitor.Collection && {
              Map: visitor.Collection,
              Seq: visitor.Collection
            }, visitor);
          }
          if (Node.isDocument(node)) {
            const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
            if (cd === REMOVE)
              node.contents = null;
          } else
            _visit(null, node, visitor, Object.freeze([]));
        }
        visit.BREAK = BREAK;
        visit.SKIP = SKIP;
        visit.REMOVE = REMOVE;
        function _visit(key, node, visitor, path2) {
          let ctrl = void 0;
          if (typeof visitor === "function")
            ctrl = visitor(key, node, path2);
          else if (Node.isMap(node)) {
            if (visitor.Map)
              ctrl = visitor.Map(key, node, path2);
          } else if (Node.isSeq(node)) {
            if (visitor.Seq)
              ctrl = visitor.Seq(key, node, path2);
          } else if (Node.isPair(node)) {
            if (visitor.Pair)
              ctrl = visitor.Pair(key, node, path2);
          } else if (Node.isScalar(node)) {
            if (visitor.Scalar)
              ctrl = visitor.Scalar(key, node, path2);
          } else if (Node.isAlias(node)) {
            if (visitor.Alias)
              ctrl = visitor.Alias(key, node, path2);
          }
          if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
            const parent = path2[path2.length - 1];
            if (Node.isCollection(parent)) {
              parent.items[key] = ctrl;
            } else if (Node.isPair(parent)) {
              if (key === "key")
                parent.key = ctrl;
              else
                parent.value = ctrl;
            } else if (Node.isDocument(parent)) {
              parent.contents = ctrl;
            } else {
              const pt = Node.isAlias(parent) ? "alias" : "scalar";
              throw new Error(`Cannot replace node with ${pt} parent`);
            }
            return _visit(key, ctrl, visitor, path2);
          }
          if (typeof ctrl !== "symbol") {
            if (Node.isCollection(node)) {
              path2 = Object.freeze(path2.concat(node));
              for (let i = 0; i < node.items.length; ++i) {
                const ci = _visit(i, node.items[i], visitor, path2);
                if (typeof ci === "number")
                  i = ci - 1;
                else if (ci === BREAK)
                  return BREAK;
                else if (ci === REMOVE) {
                  node.items.splice(i, 1);
                  i -= 1;
                }
              }
            } else if (Node.isPair(node)) {
              path2 = Object.freeze(path2.concat(node));
              const ck = _visit("key", node.key, visitor, path2);
              if (ck === BREAK)
                return BREAK;
              else if (ck === REMOVE)
                node.key = null;
              const cv = _visit("value", node.value, visitor, path2);
              if (cv === BREAK)
                return BREAK;
              else if (cv === REMOVE)
                node.value = null;
            }
          }
          return ctrl;
        }
        exports2.visit = visit;
      }
    });
    var require_directives2 = __commonJS2({
      "node_modules/yaml/dist/doc/directives.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var visit = require_visit2();
        var escapeChars = {
          "!": "%21",
          ",": "%2C",
          "[": "%5B",
          "]": "%5D",
          "{": "%7B",
          "}": "%7D"
        };
        var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
        var Directives = class {
          constructor(yaml2, tags) {
            this.marker = null;
            this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
            this.tags = Object.assign({}, Directives.defaultTags, tags);
          }
          atDocument() {
            const res = new Directives(this.yaml, this.tags);
            switch (this.yaml.version) {
              case "1.1":
                this.atNextDocument = true;
                break;
              case "1.2":
                this.atNextDocument = false;
                this.yaml = {
                  explicit: Directives.defaultYaml.explicit,
                  version: "1.2"
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
            }
            return res;
          }
          add(line, onError) {
            if (this.atNextDocument) {
              this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
              this.tags = Object.assign({}, Directives.defaultTags);
              this.atNextDocument = false;
            }
            const parts = line.trim().split(/[ \t]+/);
            const name = parts.shift();
            switch (name) {
              case "%TAG": {
                if (parts.length !== 2) {
                  onError(0, "%TAG directive should contain exactly two parts");
                  if (parts.length < 2)
                    return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
              }
              case "%YAML": {
                this.yaml.explicit = true;
                if (parts.length < 1) {
                  onError(0, "%YAML directive should contain exactly one part");
                  return false;
                }
                const [version] = parts;
                if (version === "1.1" || version === "1.2") {
                  this.yaml.version = version;
                  return true;
                } else {
                  onError(6, `Unsupported YAML version ${version}`, true);
                  return false;
                }
              }
              default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
            }
          }
          tagName(source, onError) {
            if (source === "!")
              return "!";
            if (source[0] !== "!") {
              onError(`Not a valid tag: ${source}`);
              return null;
            }
            if (source[1] === "<") {
              const verbatim = source.slice(2, -1);
              if (verbatim === "!" || verbatim === "!!") {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
              }
              if (source[source.length - 1] !== ">")
                onError("Verbatim tags must end with a >");
              return verbatim;
            }
            const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
            if (!suffix)
              onError(`The ${source} tag has no suffix`);
            const prefix = this.tags[handle];
            if (prefix)
              return prefix + decodeURIComponent(suffix);
            if (handle === "!")
              return source;
            onError(`Could not resolve tag: ${source}`);
            return null;
          }
          tagString(tag) {
            for (const [handle, prefix] of Object.entries(this.tags)) {
              if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
            }
            return tag[0] === "!" ? tag : `!<${tag}>`;
          }
          toString(doc) {
            const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
            const tagEntries = Object.entries(this.tags);
            let tagNames;
            if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
              const tags = {};
              visit.visit(doc.contents, (_key, node) => {
                if (Node.isNode(node) && node.tag)
                  tags[node.tag] = true;
              });
              tagNames = Object.keys(tags);
            } else
              tagNames = [];
            for (const [handle, prefix] of tagEntries) {
              if (handle === "!!" && prefix === "tag:yaml.org,2002:")
                continue;
              if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
            }
            return lines.join("\n");
          }
        };
        Directives.defaultYaml = { explicit: false, version: "1.2" };
        Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
        exports2.Directives = Directives;
      }
    });
    var require_anchors2 = __commonJS2({
      "node_modules/yaml/dist/doc/anchors.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var visit = require_visit2();
        function anchorIsValid(anchor) {
          if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
            const sa = JSON.stringify(anchor);
            const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
            throw new Error(msg);
          }
          return true;
        }
        function anchorNames(root) {
          const anchors = new Set();
          visit.visit(root, {
            Value(_key, node) {
              if (node.anchor)
                anchors.add(node.anchor);
            }
          });
          return anchors;
        }
        function findNewAnchor(prefix, exclude) {
          for (let i = 1; true; ++i) {
            const name = `${prefix}${i}`;
            if (!exclude.has(name))
              return name;
          }
        }
        function createNodeAnchors(doc, prefix) {
          const aliasObjects = [];
          const sourceObjects = new Map();
          let prevAnchors = null;
          return {
            onAnchor(source) {
              aliasObjects.push(source);
              if (!prevAnchors)
                prevAnchors = anchorNames(doc);
              const anchor = findNewAnchor(prefix, prevAnchors);
              prevAnchors.add(anchor);
              return anchor;
            },
            setAnchors() {
              for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === "object" && ref.anchor && (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
                  ref.node.anchor = ref.anchor;
                } else {
                  const error = new Error("Failed to resolve repeated object (this should not happen)");
                  error.source = source;
                  throw error;
                }
              }
            },
            sourceObjects
          };
        }
        exports2.anchorIsValid = anchorIsValid;
        exports2.anchorNames = anchorNames;
        exports2.createNodeAnchors = createNodeAnchors;
        exports2.findNewAnchor = findNewAnchor;
      }
    });
    var require_Alias2 = __commonJS2({
      "node_modules/yaml/dist/nodes/Alias.js"(exports2) {
        "use strict";
        var anchors = require_anchors2();
        var visit = require_visit2();
        var Node = require_Node2();
        var Alias = class extends Node.NodeBase {
          constructor(source) {
            super(Node.ALIAS);
            this.source = source;
            Object.defineProperty(this, "tag", {
              set() {
                throw new Error("Alias nodes cannot have tags");
              }
            });
          }
          resolve(doc) {
            let found = void 0;
            visit.visit(doc, {
              Node: (_key, node) => {
                if (node === this)
                  return visit.visit.BREAK;
                if (node.anchor === this.source)
                  found = node;
              }
            });
            return found;
          }
          toJSON(_arg, ctx) {
            if (!ctx)
              return { source: this.source };
            const { anchors: anchors2, doc, maxAliasCount } = ctx;
            const source = this.resolve(doc);
            if (!source) {
              const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
              throw new ReferenceError(msg);
            }
            const data = anchors2.get(source);
            if (!data || data.res === void 0) {
              const msg = "This should not happen: Alias anchor was not resolved?";
              throw new ReferenceError(msg);
            }
            if (maxAliasCount >= 0) {
              data.count += 1;
              if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors2);
              if (data.count * data.aliasCount > maxAliasCount) {
                const msg = "Excessive alias count indicates a resource exhaustion attack";
                throw new ReferenceError(msg);
              }
            }
            return data.res;
          }
          toString(ctx, _onComment, _onChompKeep) {
            const src = `*${this.source}`;
            if (ctx) {
              anchors.anchorIsValid(this.source);
              if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
              }
              if (ctx.implicitKey)
                return `${src} `;
            }
            return src;
          }
        };
        function getAliasCount(doc, node, anchors2) {
          if (Node.isAlias(node)) {
            const source = node.resolve(doc);
            const anchor = anchors2 && source && anchors2.get(source);
            return anchor ? anchor.count * anchor.aliasCount : 0;
          } else if (Node.isCollection(node)) {
            let count = 0;
            for (const item of node.items) {
              const c2 = getAliasCount(doc, item, anchors2);
              if (c2 > count)
                count = c2;
            }
            return count;
          } else if (Node.isPair(node)) {
            const kc = getAliasCount(doc, node.key, anchors2);
            const vc = getAliasCount(doc, node.value, anchors2);
            return Math.max(kc, vc);
          }
          return 1;
        }
        exports2.Alias = Alias;
      }
    });
    var require_toJS2 = __commonJS2({
      "node_modules/yaml/dist/nodes/toJS.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        function toJS(value, arg, ctx) {
          if (Array.isArray(value))
            return value.map((v, i) => toJS(v, String(i), ctx));
          if (value && typeof value.toJSON === "function") {
            if (!ctx || !Node.hasAnchor(value))
              return value.toJSON(arg, ctx);
            const data = { aliasCount: 0, count: 1, res: void 0 };
            ctx.anchors.set(value, data);
            ctx.onCreate = (res2) => {
              data.res = res2;
              delete ctx.onCreate;
            };
            const res = value.toJSON(arg, ctx);
            if (ctx.onCreate)
              ctx.onCreate(res);
            return res;
          }
          if (typeof value === "bigint" && !(ctx && ctx.keep))
            return Number(value);
          return value;
        }
        exports2.toJS = toJS;
      }
    });
    var require_Scalar2 = __commonJS2({
      "node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var toJS = require_toJS2();
        var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
        var Scalar = class extends Node.NodeBase {
          constructor(value) {
            super(Node.SCALAR);
            this.value = value;
          }
          toJSON(arg, ctx) {
            return ctx && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
          }
          toString() {
            return String(this.value);
          }
        };
        Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
        Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
        Scalar.PLAIN = "PLAIN";
        Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
        Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
        exports2.Scalar = Scalar;
        exports2.isScalarValue = isScalarValue;
      }
    });
    var require_createNode2 = __commonJS2({
      "node_modules/yaml/dist/doc/createNode.js"(exports2) {
        "use strict";
        var Alias = require_Alias2();
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var defaultTagPrefix = "tag:yaml.org,2002:";
        function findTagObject(value, tagName, tags) {
          if (tagName) {
            const match = tags.filter((t) => t.tag === tagName);
            const tagObj = match.find((t) => !t.format) || match[0];
            if (!tagObj)
              throw new Error(`Tag ${tagName} not found`);
            return tagObj;
          }
          return tags.find((t) => t.identify && t.identify(value) && !t.format);
        }
        function createNode(value, tagName, ctx) {
          var _a, _b;
          if (Node.isNode(value))
            return value;
          if (Node.isPair(value)) {
            const map = (_b = (_a = ctx.schema[Node.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
            map.items.push(value);
            return map;
          }
          if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
            value = value.valueOf();
          }
          const { onAnchor, onTagObj, schema, sourceObjects } = ctx;
          let ref = void 0;
          if (value && typeof value === "object") {
            ref = sourceObjects.get(value);
            if (ref) {
              if (!ref.anchor)
                ref.anchor = onAnchor(value);
              return new Alias.Alias(ref.anchor);
            } else {
              ref = { anchor: null, node: null };
              sourceObjects.set(value, ref);
            }
          }
          if (tagName && tagName.startsWith("!!"))
            tagName = defaultTagPrefix + tagName.slice(2);
          let tagObj = findTagObject(value, tagName, schema.tags);
          if (!tagObj) {
            if (value && typeof value.toJSON === "function")
              value = value.toJSON();
            if (!value || typeof value !== "object")
              return new Scalar.Scalar(value);
            tagObj = value instanceof Map ? schema[Node.MAP] : Symbol.iterator in Object(value) ? schema[Node.SEQ] : schema[Node.MAP];
          }
          if (onTagObj) {
            onTagObj(tagObj);
            delete ctx.onTagObj;
          }
          const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar.Scalar(value);
          if (tagName)
            node.tag = tagName;
          if (ref)
            ref.node = node;
          return node;
        }
        exports2.createNode = createNode;
      }
    });
    var require_Collection2 = __commonJS2({
      "node_modules/yaml/dist/nodes/Collection.js"(exports2) {
        "use strict";
        var createNode = require_createNode2();
        var Node = require_Node2();
        function collectionFromPath(schema, path2, value) {
          let v = value;
          for (let i = path2.length - 1; i >= 0; --i) {
            const k = path2[i];
            if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
              const a = [];
              a[k] = v;
              v = a;
            } else {
              const o = {};
              Object.defineProperty(o, typeof k === "symbol" ? k : String(k), {
                value: v,
                writable: true,
                enumerable: true,
                configurable: true
              });
              v = o;
            }
          }
          return createNode.createNode(v, void 0, {
            onAnchor() {
              throw new Error("Repeated objects are not supported here");
            },
            schema,
            sourceObjects: new Map()
          });
        }
        var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
        var Collection = class extends Node.NodeBase {
          constructor(type, schema) {
            super(type);
            Object.defineProperty(this, "schema", {
              value: schema,
              configurable: true,
              enumerable: false,
              writable: true
            });
          }
          addIn(path2, value) {
            if (isEmptyPath(path2))
              this.add(value);
            else {
              const [key, ...rest] = path2;
              const node = this.get(key, true);
              if (Node.isCollection(node))
                node.addIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
          }
          deleteIn([key, ...rest]) {
            if (rest.length === 0)
              return this.delete(key);
            const node = this.get(key, true);
            if (Node.isCollection(node))
              return node.deleteIn(rest);
            else
              throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
          }
          getIn([key, ...rest], keepScalar) {
            const node = this.get(key, true);
            if (rest.length === 0)
              return !keepScalar && Node.isScalar(node) ? node.value : node;
            else
              return Node.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
          }
          hasAllNullValues(allowScalar) {
            return this.items.every((node) => {
              if (!Node.isPair(node))
                return false;
              const n = node.value;
              return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
            });
          }
          hasIn([key, ...rest]) {
            if (rest.length === 0)
              return this.has(key);
            const node = this.get(key, true);
            return Node.isCollection(node) ? node.hasIn(rest) : false;
          }
          setIn([key, ...rest], value) {
            if (rest.length === 0) {
              this.set(key, value);
            } else {
              const node = this.get(key, true);
              if (Node.isCollection(node))
                node.setIn(rest, value);
              else if (node === void 0 && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
              else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
          }
        };
        Collection.maxFlowStringSingleLineLength = 60;
        exports2.Collection = Collection;
        exports2.collectionFromPath = collectionFromPath;
        exports2.isEmptyPath = isEmptyPath;
      }
    });
    var require_foldFlowLines2 = __commonJS2({
      "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
        "use strict";
        var FOLD_FLOW = "flow";
        var FOLD_BLOCK = "block";
        var FOLD_QUOTED = "quoted";
        function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
          if (!lineWidth || lineWidth < 0)
            return text;
          const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
          if (text.length <= endStep)
            return text;
          const folds = [];
          const escapedFolds = {};
          let end = lineWidth - indent.length;
          if (typeof indentAtStart === "number") {
            if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
              folds.push(0);
            else
              end = lineWidth - indentAtStart;
          }
          let split = void 0;
          let prev = void 0;
          let overflow = false;
          let i = -1;
          let escStart = -1;
          let escEnd = -1;
          if (mode === FOLD_BLOCK) {
            i = consumeMoreIndentedLines(text, i);
            if (i !== -1)
              end = i + endStep;
          }
          for (let ch; ch = text[i += 1]; ) {
            if (mode === FOLD_QUOTED && ch === "\\") {
              escStart = i;
              switch (text[i + 1]) {
                case "x":
                  i += 3;
                  break;
                case "u":
                  i += 5;
                  break;
                case "U":
                  i += 9;
                  break;
                default:
                  i += 1;
              }
              escEnd = i;
            }
            if (ch === "\n") {
              if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
              end = i + endStep;
              split = void 0;
            } else {
              if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
                const next = text[i + 1];
                if (next && next !== " " && next !== "\n" && next !== "	")
                  split = i;
              }
              if (i >= end) {
                if (split) {
                  folds.push(split);
                  end = split + endStep;
                  split = void 0;
                } else if (mode === FOLD_QUOTED) {
                  while (prev === " " || prev === "	") {
                    prev = ch;
                    ch = text[i += 1];
                    overflow = true;
                  }
                  const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                  if (escapedFolds[j])
                    return text;
                  folds.push(j);
                  escapedFolds[j] = true;
                  end = j + endStep;
                  split = void 0;
                } else {
                  overflow = true;
                }
              }
            }
            prev = ch;
          }
          if (overflow && onOverflow)
            onOverflow();
          if (folds.length === 0)
            return text;
          if (onFold)
            onFold();
          let res = text.slice(0, folds[0]);
          for (let i2 = 0; i2 < folds.length; ++i2) {
            const fold = folds[i2];
            const end2 = folds[i2 + 1] || text.length;
            if (fold === 0)
              res = `
${indent}${text.slice(0, end2)}`;
            else {
              if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
              res += `
${indent}${text.slice(fold + 1, end2)}`;
            }
          }
          return res;
        }
        function consumeMoreIndentedLines(text, i) {
          let ch = text[i + 1];
          while (ch === " " || ch === "	") {
            do {
              ch = text[i += 1];
            } while (ch && ch !== "\n");
            ch = text[i + 1];
          }
          return i;
        }
        exports2.FOLD_BLOCK = FOLD_BLOCK;
        exports2.FOLD_FLOW = FOLD_FLOW;
        exports2.FOLD_QUOTED = FOLD_QUOTED;
        exports2.foldFlowLines = foldFlowLines;
      }
    });
    var require_stringifyString2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var foldFlowLines = require_foldFlowLines2();
        var getFoldOptions = (ctx) => ({
          indentAtStart: ctx.indentAtStart,
          lineWidth: ctx.options.lineWidth,
          minContentWidth: ctx.options.minContentWidth
        });
        var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
        function lineLengthOverLimit(str, lineWidth, indentLength) {
          if (!lineWidth || lineWidth < 0)
            return false;
          const limit = lineWidth - indentLength;
          const strLen = str.length;
          if (strLen <= limit)
            return false;
          for (let i = 0, start = 0; i < strLen; ++i) {
            if (str[i] === "\n") {
              if (i - start > limit)
                return true;
              start = i + 1;
              if (strLen - start <= limit)
                return false;
            }
          }
          return true;
        }
        function doubleQuotedString(value, ctx) {
          const json = JSON.stringify(value);
          if (ctx.options.doubleQuotedAsJSON)
            return json;
          const { implicitKey } = ctx;
          const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
          const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
          let str = "";
          let start = 0;
          for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
            if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
              str += json.slice(start, i) + "\\ ";
              i += 1;
              start = i;
              ch = "\\";
            }
            if (ch === "\\")
              switch (json[i + 1]) {
                case "u":
                  {
                    str += json.slice(start, i);
                    const code = json.substr(i + 2, 4);
                    switch (code) {
                      case "0000":
                        str += "\\0";
                        break;
                      case "0007":
                        str += "\\a";
                        break;
                      case "000b":
                        str += "\\v";
                        break;
                      case "001b":
                        str += "\\e";
                        break;
                      case "0085":
                        str += "\\N";
                        break;
                      case "00a0":
                        str += "\\_";
                        break;
                      case "2028":
                        str += "\\L";
                        break;
                      case "2029":
                        str += "\\P";
                        break;
                      default:
                        if (code.substr(0, 2) === "00")
                          str += "\\x" + code.substr(2);
                        else
                          str += json.substr(i, 6);
                    }
                    i += 5;
                    start = i + 1;
                  }
                  break;
                case "n":
                  if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                    i += 1;
                  } else {
                    str += json.slice(start, i) + "\n\n";
                    while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                      str += "\n";
                      i += 2;
                    }
                    str += indent;
                    if (json[i + 2] === " ")
                      str += "\\";
                    i += 1;
                    start = i + 1;
                  }
                  break;
                default:
                  i += 1;
              }
          }
          str = start ? str + json.slice(start) : json;
          return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
        }
        function singleQuotedString(value, ctx) {
          if (ctx.implicitKey) {
            if (/\n/.test(value))
              return doubleQuotedString(value, ctx);
          } else {
            if (/[ \t]\n|\n[ \t]/.test(value))
              return doubleQuotedString(value, ctx);
          }
          const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
          const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
          return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
        }
        function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
          if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
            return doubleQuotedString(value, ctx);
          }
          const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
          const literal = type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, ctx.options.lineWidth, indent.length);
          if (!value)
            return literal ? "|\n" : ">\n";
          let chomp;
          let endStart;
          for (endStart = value.length; endStart > 0; --endStart) {
            const ch = value[endStart - 1];
            if (ch !== "\n" && ch !== "	" && ch !== " ")
              break;
          }
          let end = value.substring(endStart);
          const endNlPos = end.indexOf("\n");
          if (endNlPos === -1) {
            chomp = "-";
          } else if (value === end || endNlPos !== end.length - 1) {
            chomp = "+";
            if (onChompKeep)
              onChompKeep();
          } else {
            chomp = "";
          }
          if (end) {
            value = value.slice(0, -end.length);
            if (end[end.length - 1] === "\n")
              end = end.slice(0, -1);
            end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
          }
          let startWithSpace = false;
          let startEnd;
          let startNlPos = -1;
          for (startEnd = 0; startEnd < value.length; ++startEnd) {
            const ch = value[startEnd];
            if (ch === " ")
              startWithSpace = true;
            else if (ch === "\n")
              startNlPos = startEnd;
            else
              break;
          }
          let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
          if (start) {
            value = value.substring(start.length);
            start = start.replace(/\n+/g, `$&${indent}`);
          }
          const indentSize = indent ? "2" : "1";
          let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
          if (comment) {
            header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
            if (onComment)
              onComment();
          }
          if (literal) {
            value = value.replace(/\n+/g, `$&${indent}`);
            return `${header}
${indent}${start}${value}${end}`;
          }
          value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
          const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
          return `${header}
${indent}${body}`;
        }
        function plainString(item, ctx, onComment, onChompKeep) {
          var _a;
          const { type, value } = item;
          const { actualString, implicitKey, indent, inFlow } = ctx;
          if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
            return doubleQuotedString(value, ctx);
          }
          if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
            const hasDouble = value.indexOf('"') !== -1;
            const hasSingle = value.indexOf("'") !== -1;
            let quotedString;
            if (hasDouble && !hasSingle) {
              quotedString = singleQuotedString;
            } else if (hasSingle && !hasDouble) {
              quotedString = doubleQuotedString;
            } else if (ctx.options.singleQuote) {
              quotedString = singleQuotedString;
            } else {
              quotedString = doubleQuotedString;
            }
            return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
          }
          if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.indexOf("\n") !== -1) {
            return blockString(item, ctx, onComment, onChompKeep);
          }
          if (indent === "" && containsDocumentMarker(value)) {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
          }
          const str = value.replace(/\n+/g, `$&
${indent}`);
          if (actualString) {
            for (const tag of ctx.doc.schema.tags) {
              if (tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))
                return doubleQuotedString(value, ctx);
            }
          }
          return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
        }
        function stringifyString(item, ctx, onComment, onChompKeep) {
          const { implicitKey, inFlow } = ctx;
          const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
          let { type } = item;
          if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
              type = Scalar.Scalar.QUOTE_DOUBLE;
          }
          const _stringify = (_type) => {
            switch (_type) {
              case Scalar.Scalar.BLOCK_FOLDED:
              case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow ? doubleQuotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
              case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
              case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
              case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
              default:
                return null;
            }
          };
          let res = _stringify(type);
          if (res === null) {
            const { defaultKeyType, defaultStringType } = ctx.options;
            const t = implicitKey && defaultKeyType || defaultStringType;
            res = _stringify(t);
            if (res === null)
              throw new Error(`Unsupported default string type ${t}`);
          }
          return res;
        }
        exports2.stringifyString = stringifyString;
      }
    });
    var require_stringify2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringify.js"(exports2) {
        "use strict";
        var anchors = require_anchors2();
        var Node = require_Node2();
        var stringifyString = require_stringifyString2();
        var createStringifyContext = (doc, options) => ({
          anchors: new Set(),
          doc,
          indent: "",
          indentStep: typeof options.indent === "number" ? " ".repeat(options.indent) : "  ",
          options: Object.assign({
            defaultKeyType: null,
            defaultStringType: "PLAIN",
            directives: null,
            doubleQuotedAsJSON: false,
            doubleQuotedMinMultiLineLength: 40,
            falseStr: "false",
            indentSeq: true,
            lineWidth: 80,
            minContentWidth: 20,
            nullStr: "null",
            simpleKeys: false,
            singleQuote: false,
            trueStr: "true",
            verifyAliasOrder: true
          }, options)
        });
        function getTagObject(tags, item) {
          if (item.tag) {
            const match = tags.filter((t) => t.tag === item.tag);
            if (match.length > 0)
              return match.find((t) => t.format === item.format) || match[0];
          }
          let tagObj = void 0;
          let obj;
          if (Node.isScalar(item)) {
            obj = item.value;
            const match = tags.filter((t) => t.identify && t.identify(obj));
            tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
          } else {
            obj = item;
            tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
          }
          if (!tagObj) {
            const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
            throw new Error(`Tag not resolved for ${name} value`);
          }
          return tagObj;
        }
        function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
          const props = [];
          const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
          if (anchor && anchors.anchorIsValid(anchor)) {
            anchors$1.add(anchor);
            props.push(`&${anchor}`);
          }
          if (node.tag) {
            props.push(doc.directives.tagString(node.tag));
          } else if (!tagObj.default) {
            props.push(doc.directives.tagString(tagObj.tag));
          }
          return props.join(" ");
        }
        function stringify(item, ctx, onComment, onChompKeep) {
          if (Node.isPair(item))
            return item.toString(ctx, onComment, onChompKeep);
          if (Node.isAlias(item))
            return item.toString(ctx);
          let tagObj = void 0;
          const node = Node.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
          if (!tagObj)
            tagObj = getTagObject(ctx.doc.schema.tags, node);
          const props = stringifyProps(node, tagObj, ctx);
          if (props.length > 0)
            ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
          const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : Node.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
          if (!props)
            return str;
          return Node.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
        }
        exports2.createStringifyContext = createStringifyContext;
        exports2.stringify = stringify;
      }
    });
    var require_stringifyComment2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
        "use strict";
        var stringifyComment = (comment, indent) => /^\n+$/.test(comment) ? comment.substring(1) : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);
        function addComment(str, indent, comment) {
          return !comment ? str : comment.includes("\n") ? `${str}
` + stringifyComment(comment, indent) : str.endsWith(" ") ? `${str}#${comment}` : `${str} #${comment}`;
        }
        exports2.addComment = addComment;
        exports2.stringifyComment = stringifyComment;
      }
    });
    var require_stringifyPair2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var stringify = require_stringify2();
        var stringifyComment = require_stringifyComment2();
        function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
          const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;
          let keyComment = Node.isNode(key) && key.comment || null;
          if (simpleKeys) {
            if (keyComment) {
              throw new Error("With simple keys, key nodes cannot have comments");
            }
            if (Node.isCollection(key)) {
              const msg = "With simple keys, collection cannot be used as a key value";
              throw new Error(msg);
            }
          }
          let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || Node.isCollection(key) || (Node.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
          ctx = Object.assign({}, ctx, {
            allNullValues: false,
            implicitKey: !explicitKey && (simpleKeys || !allNullValues),
            indent: indent + indentStep
          });
          let keyCommentDone = false;
          let chompKeep = false;
          let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
          if (!explicitKey && !ctx.inFlow && str.length > 1024) {
            if (simpleKeys)
              throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
            explicitKey = true;
          }
          if (ctx.inFlow) {
            if (allNullValues || value == null) {
              if (keyCommentDone && onComment)
                onComment();
              return explicitKey ? `? ${str}` : str;
            }
          } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
            if (keyCommentDone)
              keyComment = null;
            if (chompKeep && !keyComment && onChompKeep)
              onChompKeep();
            return stringifyComment.addComment(`? ${str}`, ctx.indent, keyComment);
          }
          if (keyCommentDone)
            keyComment = null;
          str = explicitKey ? `? ${stringifyComment.addComment(str, ctx.indent, keyComment)}
${indent}:` : stringifyComment.addComment(`${str}:`, ctx.indent, keyComment);
          let vcb = "";
          let valueComment = null;
          if (Node.isNode(value)) {
            if (value.spaceBefore)
              vcb = "\n";
            if (value.commentBefore)
              vcb += `
${stringifyComment.stringifyComment(value.commentBefore, ctx.indent)}`;
            valueComment = value.comment;
          } else if (value && typeof value === "object") {
            value = doc.createNode(value);
          }
          ctx.implicitKey = false;
          if (!explicitKey && !keyComment && Node.isScalar(value))
            ctx.indentAtStart = str.length + 1;
          chompKeep = false;
          if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && Node.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
            ctx.indent = ctx.indent.substr(2);
          }
          let valueCommentDone = false;
          const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
          let ws = " ";
          if (vcb || keyComment) {
            ws = `${vcb}
${ctx.indent}`;
          } else if (!explicitKey && Node.isCollection(value)) {
            const flow = valueStr[0] === "[" || valueStr[0] === "{";
            if (!flow || valueStr.includes("\n"))
              ws = `
${ctx.indent}`;
          } else if (valueStr[0] === "\n")
            ws = "";
          if (ctx.inFlow) {
            if (valueCommentDone && onComment)
              onComment();
            return str + ws + valueStr;
          } else {
            if (valueCommentDone)
              valueComment = null;
            if (chompKeep && !valueComment && onChompKeep)
              onChompKeep();
            return stringifyComment.addComment(str + ws + valueStr, ctx.indent, valueComment);
          }
        }
        exports2.stringifyPair = stringifyPair;
      }
    });
    var require_log2 = __commonJS2({
      "node_modules/yaml/dist/log.js"(exports2) {
        "use strict";
        function debug(logLevel, ...messages) {
          if (logLevel === "debug")
            console.log(...messages);
        }
        function warn(logLevel, warning) {
          if (logLevel === "debug" || logLevel === "warn") {
            if (typeof process !== "undefined" && process.emitWarning)
              process.emitWarning(warning);
            else
              console.warn(warning);
          }
        }
        exports2.debug = debug;
        exports2.warn = warn;
      }
    });
    var require_addPairToJSMap2 = __commonJS2({
      "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
        "use strict";
        var log2 = require_log2();
        var stringify = require_stringify2();
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var toJS = require_toJS2();
        var MERGE_KEY = "<<";
        function addPairToJSMap(ctx, map, { key, value }) {
          if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
            if (Node.isSeq(value))
              for (const it of value.items)
                mergeToJSMap(ctx, map, it);
            else if (Array.isArray(value))
              for (const it of value)
                mergeToJSMap(ctx, map, it);
            else
              mergeToJSMap(ctx, map, value);
          } else {
            const jsKey = toJS.toJS(key, "", ctx);
            if (map instanceof Map) {
              map.set(jsKey, toJS.toJS(value, jsKey, ctx));
            } else if (map instanceof Set) {
              map.add(jsKey);
            } else {
              const stringKey = stringifyKey(key, jsKey, ctx);
              const jsValue = toJS.toJS(value, stringKey, ctx);
              if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                  value: jsValue,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              else
                map[stringKey] = jsValue;
            }
          }
          return map;
        }
        var isMergeKey = (key) => key === MERGE_KEY || Node.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
        function mergeToJSMap(ctx, map, value) {
          const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : null;
          if (!Node.isMap(source))
            throw new Error("Merge sources must be map aliases");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value2] of srcMap) {
            if (map instanceof Map) {
              if (!map.has(key))
                map.set(key, value2);
            } else if (map instanceof Set) {
              map.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
              Object.defineProperty(map, key, {
                value: value2,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
          return map;
        }
        function stringifyKey(key, jsKey, ctx) {
          if (jsKey === null)
            return "";
          if (typeof jsKey !== "object")
            return String(jsKey);
          if (Node.isNode(key) && ctx && ctx.doc) {
            const strCtx = stringify.createStringifyContext(ctx.doc, {});
            strCtx.anchors = new Set();
            for (const node of ctx.anchors.keys())
              strCtx.anchors.add(node.anchor);
            strCtx.inFlow = true;
            strCtx.inStringifyKey = true;
            const strKey = key.toString(strCtx);
            if (!ctx.mapKeyWarned) {
              let jsonStr = JSON.stringify(strKey);
              if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
              log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
              ctx.mapKeyWarned = true;
            }
            return strKey;
          }
          return JSON.stringify(jsKey);
        }
        exports2.addPairToJSMap = addPairToJSMap;
      }
    });
    var require_Pair2 = __commonJS2({
      "node_modules/yaml/dist/nodes/Pair.js"(exports2) {
        "use strict";
        var createNode = require_createNode2();
        var stringifyPair = require_stringifyPair2();
        var addPairToJSMap = require_addPairToJSMap2();
        var Node = require_Node2();
        function createPair(key, value, ctx) {
          const k = createNode.createNode(key, void 0, ctx);
          const v = createNode.createNode(value, void 0, ctx);
          return new Pair(k, v);
        }
        var Pair = class {
          constructor(key, value = null) {
            Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
            this.key = key;
            this.value = value;
          }
          toJSON(_, ctx) {
            const pair = ctx && ctx.mapAsMap ? new Map() : {};
            return addPairToJSMap.addPairToJSMap(ctx, pair, this);
          }
          toString(ctx, onComment, onChompKeep) {
            return ctx && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
          }
        };
        exports2.Pair = Pair;
        exports2.createPair = createPair;
      }
    });
    var require_options2 = __commonJS2({
      "node_modules/yaml/dist/options.js"(exports2) {
        "use strict";
        var defaultOptions = {
          intAsBigInt: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        };
        exports2.defaultOptions = defaultOptions;
      }
    });
    var require_stringifyCollection2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
        "use strict";
        var Collection = require_Collection2();
        var Node = require_Node2();
        var stringify = require_stringify2();
        var stringifyComment = require_stringifyComment2();
        function stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {
          const { indent, indentStep } = ctx;
          const inFlow = flow || ctx.inFlow;
          if (inFlow)
            itemIndent += indentStep;
          ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });
          let singleLineOutput = true;
          let chompKeep = false;
          const nodes = items.reduce((nodes2, item, i) => {
            let comment2 = null;
            if (Node.isNode(item)) {
              if (!chompKeep && item.spaceBefore)
                nodes2.push({ comment: true, str: "" });
              let cb = item.commentBefore;
              if (cb && chompKeep)
                cb = cb.replace(/^\n+/, "");
              if (cb) {
                if (/^\n+$/.test(cb))
                  cb = cb.substring(1);
                for (const line of cb.match(/^.*$/gm)) {
                  const str3 = line === " " ? "#" : line ? `#${line}` : "";
                  nodes2.push({ comment: true, str: str3 });
                }
              }
              if (item.comment) {
                comment2 = item.comment;
                singleLineOutput = false;
              }
            } else if (Node.isPair(item)) {
              const ik = Node.isNode(item.key) ? item.key : null;
              if (ik) {
                if (!chompKeep && ik.spaceBefore)
                  nodes2.push({ comment: true, str: "" });
                let cb = ik.commentBefore;
                if (cb && chompKeep)
                  cb = cb.replace(/^\n+/, "");
                if (cb) {
                  if (/^\n+$/.test(cb))
                    cb = cb.substring(1);
                  for (const line of cb.match(/^.*$/gm)) {
                    const str3 = line === " " ? "#" : line ? `#${line}` : "";
                    nodes2.push({ comment: true, str: str3 });
                  }
                }
                if (ik.comment)
                  singleLineOutput = false;
              }
              if (inFlow) {
                const iv = Node.isNode(item.value) ? item.value : null;
                if (iv) {
                  if (iv.comment)
                    comment2 = iv.comment;
                  if (iv.comment || iv.commentBefore)
                    singleLineOutput = false;
                } else if (item.value == null && ik && ik.comment) {
                  comment2 = ik.comment;
                }
              }
            }
            chompKeep = false;
            let str2 = stringify.stringify(item, ctx, () => comment2 = null, () => chompKeep = true);
            if (inFlow && i < items.length - 1)
              str2 += ",";
            str2 = stringifyComment.addComment(str2, itemIndent, comment2);
            if (chompKeep && (comment2 || inFlow))
              chompKeep = false;
            nodes2.push({ comment: false, str: str2 });
            return nodes2;
          }, []);
          let str;
          if (nodes.length === 0) {
            str = flowChars.start + flowChars.end;
          } else if (inFlow) {
            const { start, end } = flowChars;
            const strings = nodes.map((n) => n.str);
            let singleLineLength = 2;
            for (const node of nodes) {
              if (node.comment || node.str.includes("\n")) {
                singleLineOutput = false;
                break;
              }
              singleLineLength += node.str.length + 2;
            }
            if (!singleLineOutput || singleLineLength > Collection.Collection.maxFlowStringSingleLineLength) {
              str = start;
              for (const s of strings) {
                str += s ? `
${indentStep}${indent}${s}` : "\n";
              }
              str += `
${indent}${end}`;
            } else {
              str = `${start} ${strings.join(" ")} ${end}`;
            }
          } else {
            const strings = nodes.map(blockItem);
            str = strings.shift() || "";
            for (const s of strings)
              str += s ? `
${indent}${s}` : "\n";
          }
          if (comment) {
            str += "\n" + stringifyComment.stringifyComment(comment, indent);
            if (onComment)
              onComment();
          } else if (chompKeep && onChompKeep)
            onChompKeep();
          return str;
        }
        exports2.stringifyCollection = stringifyCollection;
      }
    });
    var require_YAMLMap2 = __commonJS2({
      "node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
        "use strict";
        var stringifyCollection = require_stringifyCollection2();
        var addPairToJSMap = require_addPairToJSMap2();
        var Collection = require_Collection2();
        var Node = require_Node2();
        var Pair = require_Pair2();
        var Scalar = require_Scalar2();
        function findPair(items, key) {
          const k = Node.isScalar(key) ? key.value : key;
          for (const it of items) {
            if (Node.isPair(it)) {
              if (it.key === key || it.key === k)
                return it;
              if (Node.isScalar(it.key) && it.key.value === k)
                return it;
            }
          }
          return void 0;
        }
        var YAMLMap = class extends Collection.Collection {
          constructor(schema) {
            super(Node.MAP, schema);
            this.items = [];
          }
          static get tagName() {
            return "tag:yaml.org,2002:map";
          }
          add(pair, overwrite) {
            let _pair;
            if (Node.isPair(pair))
              _pair = pair;
            else if (!pair || typeof pair !== "object" || !("key" in pair)) {
              _pair = new Pair.Pair(pair, pair.value);
            } else
              _pair = new Pair.Pair(pair.key, pair.value);
            const prev = findPair(this.items, _pair.key);
            const sortEntries = this.schema && this.schema.sortMapEntries;
            if (prev) {
              if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
              if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
              else
                prev.value = _pair.value;
            } else if (sortEntries) {
              const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
              if (i === -1)
                this.items.push(_pair);
              else
                this.items.splice(i, 0, _pair);
            } else {
              this.items.push(_pair);
            }
          }
          delete(key) {
            const it = findPair(this.items, key);
            if (!it)
              return false;
            const del = this.items.splice(this.items.indexOf(it), 1);
            return del.length > 0;
          }
          get(key, keepScalar) {
            const it = findPair(this.items, key);
            const node = it && it.value;
            return !keepScalar && Node.isScalar(node) ? node.value : node;
          }
          has(key) {
            return !!findPair(this.items, key);
          }
          set(key, value) {
            this.add(new Pair.Pair(key, value), true);
          }
          toJSON(_, ctx, Type) {
            const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
            if (ctx && ctx.onCreate)
              ctx.onCreate(map);
            for (const item of this.items)
              addPairToJSMap.addPairToJSMap(ctx, map, item);
            return map;
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            for (const item of this.items) {
              if (!Node.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
            }
            if (!ctx.allNullValues && this.hasAllNullValues(false))
              ctx = Object.assign({}, ctx, { allNullValues: true });
            return stringifyCollection.stringifyCollection(this, ctx, {
              blockItem: (n) => n.str,
              flowChars: { start: "{", end: "}" },
              itemIndent: ctx.indent || "",
              onChompKeep,
              onComment
            });
          }
        };
        exports2.YAMLMap = YAMLMap;
        exports2.findPair = findPair;
      }
    });
    var require_map2 = __commonJS2({
      "node_modules/yaml/dist/schema/common/map.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Pair = require_Pair2();
        var YAMLMap = require_YAMLMap2();
        function createMap(schema, obj, ctx) {
          const { keepUndefined, replacer } = ctx;
          const map2 = new YAMLMap.YAMLMap(schema);
          const add = (key, value) => {
            if (typeof replacer === "function")
              value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
              return;
            if (value !== void 0 || keepUndefined)
              map2.items.push(Pair.createPair(key, value, ctx));
          };
          if (obj instanceof Map) {
            for (const [key, value] of obj)
              add(key, value);
          } else if (obj && typeof obj === "object") {
            for (const key of Object.keys(obj))
              add(key, obj[key]);
          }
          if (typeof schema.sortMapEntries === "function") {
            map2.items.sort(schema.sortMapEntries);
          }
          return map2;
        }
        var map = {
          collection: "map",
          createNode: createMap,
          default: true,
          nodeClass: YAMLMap.YAMLMap,
          tag: "tag:yaml.org,2002:map",
          resolve(map2, onError) {
            if (!Node.isMap(map2))
              onError("Expected a mapping for this tag");
            return map2;
          }
        };
        exports2.map = map;
      }
    });
    var require_YAMLSeq2 = __commonJS2({
      "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
        "use strict";
        var stringifyCollection = require_stringifyCollection2();
        var Collection = require_Collection2();
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var toJS = require_toJS2();
        var YAMLSeq = class extends Collection.Collection {
          constructor(schema) {
            super(Node.SEQ, schema);
            this.items = [];
          }
          static get tagName() {
            return "tag:yaml.org,2002:seq";
          }
          add(value) {
            this.items.push(value);
          }
          delete(key) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              return false;
            const del = this.items.splice(idx, 1);
            return del.length > 0;
          }
          get(key, keepScalar) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              return void 0;
            const it = this.items[idx];
            return !keepScalar && Node.isScalar(it) ? it.value : it;
          }
          has(key) {
            const idx = asItemIndex(key);
            return typeof idx === "number" && idx < this.items.length;
          }
          set(key, value) {
            const idx = asItemIndex(key);
            if (typeof idx !== "number")
              throw new Error(`Expected a valid index, not ${key}.`);
            const prev = this.items[idx];
            if (Node.isScalar(prev) && Scalar.isScalarValue(value))
              prev.value = value;
            else
              this.items[idx] = value;
          }
          toJSON(_, ctx) {
            const seq = [];
            if (ctx && ctx.onCreate)
              ctx.onCreate(seq);
            let i = 0;
            for (const item of this.items)
              seq.push(toJS.toJS(item, String(i++), ctx));
            return seq;
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            return stringifyCollection.stringifyCollection(this, ctx, {
              blockItem: (n) => n.comment ? n.str : `- ${n.str}`,
              flowChars: { start: "[", end: "]" },
              itemIndent: (ctx.indent || "") + "  ",
              onChompKeep,
              onComment
            });
          }
        };
        function asItemIndex(key) {
          let idx = Node.isScalar(key) ? key.value : key;
          if (idx && typeof idx === "string")
            idx = Number(idx);
          return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
        }
        exports2.YAMLSeq = YAMLSeq;
      }
    });
    var require_seq2 = __commonJS2({
      "node_modules/yaml/dist/schema/common/seq.js"(exports2) {
        "use strict";
        var createNode = require_createNode2();
        var Node = require_Node2();
        var YAMLSeq = require_YAMLSeq2();
        function createSeq(schema, obj, ctx) {
          const { replacer } = ctx;
          const seq2 = new YAMLSeq.YAMLSeq(schema);
          if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
              if (typeof replacer === "function") {
                const key = obj instanceof Set ? it : String(i++);
                it = replacer.call(obj, key, it);
              }
              seq2.items.push(createNode.createNode(it, void 0, ctx));
            }
          }
          return seq2;
        }
        var seq = {
          collection: "seq",
          createNode: createSeq,
          default: true,
          nodeClass: YAMLSeq.YAMLSeq,
          tag: "tag:yaml.org,2002:seq",
          resolve(seq2, onError) {
            if (!Node.isSeq(seq2))
              onError("Expected a sequence for this tag");
            return seq2;
          }
        };
        exports2.seq = seq;
      }
    });
    var require_string2 = __commonJS2({
      "node_modules/yaml/dist/schema/common/string.js"(exports2) {
        "use strict";
        var stringifyString = require_stringifyString2();
        var string = {
          identify: (value) => typeof value === "string",
          default: true,
          tag: "tag:yaml.org,2002:str",
          resolve: (str) => str,
          stringify(item, ctx, onComment, onChompKeep) {
            ctx = Object.assign({ actualString: true }, ctx);
            return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
          }
        };
        exports2.string = string;
      }
    });
    var require_null2 = __commonJS2({
      "node_modules/yaml/dist/schema/common/null.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var nullTag = {
          identify: (value) => value == null,
          createNode: () => new Scalar.Scalar(null),
          default: true,
          tag: "tag:yaml.org,2002:null",
          test: /^(?:~|[Nn]ull|NULL)?$/,
          resolve: () => new Scalar.Scalar(null),
          stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
        };
        exports2.nullTag = nullTag;
      }
    });
    var require_bool3 = __commonJS2({
      "node_modules/yaml/dist/schema/core/bool.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var boolTag = {
          identify: (value) => typeof value === "boolean",
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
          resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
          stringify({ source, value }, ctx) {
            if (source && boolTag.test.test(source)) {
              const sv = source[0] === "t" || source[0] === "T";
              if (value === sv)
                return source;
            }
            return value ? ctx.options.trueStr : ctx.options.falseStr;
          }
        };
        exports2.boolTag = boolTag;
      }
    });
    var require_stringifyNumber2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
        "use strict";
        function stringifyNumber({ format, minFractionDigits, tag, value }) {
          if (typeof value === "bigint")
            return String(value);
          const num = typeof value === "number" ? value : Number(value);
          if (!isFinite(num))
            return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
          let n = JSON.stringify(value);
          if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
            let i = n.indexOf(".");
            if (i < 0) {
              i = n.length;
              n += ".";
            }
            let d = minFractionDigits - (n.length - i - 1);
            while (d-- > 0)
              n += "0";
          }
          return n;
        }
        exports2.stringifyNumber = stringifyNumber;
      }
    });
    var require_float3 = __commonJS2({
      "node_modules/yaml/dist/schema/core/float.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var stringifyNumber = require_stringifyNumber2();
        var floatNaN = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
          resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
          stringify: stringifyNumber.stringifyNumber
        };
        var floatExp = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "EXP",
          test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
          resolve: (str) => parseFloat(str),
          stringify: ({ value }) => Number(value).toExponential()
        };
        var float = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
          resolve(str) {
            const node = new Scalar.Scalar(parseFloat(str));
            const dot = str.indexOf(".");
            if (dot !== -1 && str[str.length - 1] === "0")
              node.minFractionDigits = str.length - dot - 1;
            return node;
          },
          stringify: stringifyNumber.stringifyNumber
        };
        exports2.float = float;
        exports2.floatExp = floatExp;
        exports2.floatNaN = floatNaN;
      }
    });
    var require_int3 = __commonJS2({
      "node_modules/yaml/dist/schema/core/int.js"(exports2) {
        "use strict";
        var stringifyNumber = require_stringifyNumber2();
        var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
        var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
        function intStringify(node, radix, prefix) {
          const { value } = node;
          if (intIdentify(value) && value >= 0)
            return prefix + value.toString(radix);
          return stringifyNumber.stringifyNumber(node);
        }
        var intOct = {
          identify: (value) => intIdentify(value) && value >= 0,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "OCT",
          test: /^0o[0-7]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
          stringify: (node) => intStringify(node, 8, "0o")
        };
        var int = {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^[-+]?[0-9]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
          stringify: stringifyNumber.stringifyNumber
        };
        var intHex = {
          identify: (value) => intIdentify(value) && value >= 0,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "HEX",
          test: /^0x[0-9a-fA-F]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
          stringify: (node) => intStringify(node, 16, "0x")
        };
        exports2.int = int;
        exports2.intHex = intHex;
        exports2.intOct = intOct;
      }
    });
    var require_schema4 = __commonJS2({
      "node_modules/yaml/dist/schema/core/schema.js"(exports2) {
        "use strict";
        var map = require_map2();
        var _null = require_null2();
        var seq = require_seq2();
        var string = require_string2();
        var bool = require_bool3();
        var float = require_float3();
        var int = require_int3();
        var schema = [
          map.map,
          seq.seq,
          string.string,
          _null.nullTag,
          bool.boolTag,
          int.intOct,
          int.int,
          int.intHex,
          float.floatNaN,
          float.floatExp,
          float.float
        ];
        exports2.schema = schema;
      }
    });
    var require_schema22 = __commonJS2({
      "node_modules/yaml/dist/schema/json/schema.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var map = require_map2();
        var seq = require_seq2();
        function intIdentify(value) {
          return typeof value === "bigint" || Number.isInteger(value);
        }
        var stringifyJSON = ({ value }) => JSON.stringify(value);
        var jsonScalars = [
          {
            identify: (value) => typeof value === "string",
            default: true,
            tag: "tag:yaml.org,2002:str",
            resolve: (str) => str,
            stringify: stringifyJSON
          },
          {
            identify: (value) => value == null,
            createNode: () => new Scalar.Scalar(null),
            default: true,
            tag: "tag:yaml.org,2002:null",
            test: /^null$/,
            resolve: () => null,
            stringify: stringifyJSON
          },
          {
            identify: (value) => typeof value === "boolean",
            default: true,
            tag: "tag:yaml.org,2002:bool",
            test: /^true|false$/,
            resolve: (str) => str === "true",
            stringify: stringifyJSON
          },
          {
            identify: intIdentify,
            default: true,
            tag: "tag:yaml.org,2002:int",
            test: /^-?(?:0|[1-9][0-9]*)$/,
            resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
            stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
          },
          {
            identify: (value) => typeof value === "number",
            default: true,
            tag: "tag:yaml.org,2002:float",
            test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
            resolve: (str) => parseFloat(str),
            stringify: stringifyJSON
          }
        ];
        var jsonError = {
          default: true,
          tag: "",
          test: /^/,
          resolve(str, onError) {
            onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
            return str;
          }
        };
        var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
        exports2.schema = schema;
      }
    });
    var require_binary2 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var stringifyString = require_stringifyString2();
        var binary = {
          identify: (value) => value instanceof Uint8Array,
          default: false,
          tag: "tag:yaml.org,2002:binary",
          resolve(src, onError) {
            if (typeof Buffer === "function") {
              return Buffer.from(src, "base64");
            } else if (typeof atob === "function") {
              const str = atob(src.replace(/[\n\r]/g, ""));
              const buffer = new Uint8Array(str.length);
              for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
              return buffer;
            } else {
              onError("This environment does not support reading binary tags; either Buffer or atob is required");
              return src;
            }
          },
          stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
            const buf = value;
            let str;
            if (typeof Buffer === "function") {
              str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
            } else if (typeof btoa === "function") {
              let s = "";
              for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
              str = btoa(s);
            } else {
              throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
            }
            if (!type)
              type = Scalar.Scalar.BLOCK_LITERAL;
            if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
              const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
              const n = Math.ceil(str.length / lineWidth);
              const lines = new Array(n);
              for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
              }
              str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
            }
            return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
          }
        };
        exports2.binary = binary;
      }
    });
    var require_pairs2 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Pair = require_Pair2();
        var Scalar = require_Scalar2();
        var YAMLSeq = require_YAMLSeq2();
        function resolvePairs(seq, onError) {
          if (Node.isSeq(seq)) {
            for (let i = 0; i < seq.items.length; ++i) {
              let item = seq.items[i];
              if (Node.isPair(item))
                continue;
              else if (Node.isMap(item)) {
                if (item.items.length > 1)
                  onError("Each pair must have its own sequence indicator");
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                  pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
                if (item.comment) {
                  const cn = pair.value || pair.key;
                  cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
                }
                item = pair;
              }
              seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
            }
          } else
            onError("Expected a sequence for this tag");
          return seq;
        }
        function createPairs(schema, iterable, ctx) {
          const { replacer } = ctx;
          const pairs2 = new YAMLSeq.YAMLSeq(schema);
          pairs2.tag = "tag:yaml.org,2002:pairs";
          let i = 0;
          if (iterable && Symbol.iterator in Object(iterable))
            for (let it of iterable) {
              if (typeof replacer === "function")
                it = replacer.call(iterable, String(i++), it);
              let key, value;
              if (Array.isArray(it)) {
                if (it.length === 2) {
                  key = it[0];
                  value = it[1];
                } else
                  throw new TypeError(`Expected [key, value] tuple: ${it}`);
              } else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                  key = keys[0];
                  value = it[key];
                } else
                  throw new TypeError(`Expected { key: value } tuple: ${it}`);
              } else {
                key = it;
              }
              pairs2.items.push(Pair.createPair(key, value, ctx));
            }
          return pairs2;
        }
        var pairs = {
          collection: "seq",
          default: false,
          tag: "tag:yaml.org,2002:pairs",
          resolve: resolvePairs,
          createNode: createPairs
        };
        exports2.createPairs = createPairs;
        exports2.pairs = pairs;
        exports2.resolvePairs = resolvePairs;
      }
    });
    var require_omap2 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
        "use strict";
        var YAMLSeq = require_YAMLSeq2();
        var toJS = require_toJS2();
        var Node = require_Node2();
        var YAMLMap = require_YAMLMap2();
        var pairs = require_pairs2();
        var YAMLOMap = class extends YAMLSeq.YAMLSeq {
          constructor() {
            super();
            this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
            this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
            this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
            this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
            this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
            this.tag = YAMLOMap.tag;
          }
          toJSON(_, ctx) {
            if (!ctx)
              return super.toJSON(_);
            const map = new Map();
            if (ctx && ctx.onCreate)
              ctx.onCreate(map);
            for (const pair of this.items) {
              let key, value;
              if (Node.isPair(pair)) {
                key = toJS.toJS(pair.key, "", ctx);
                value = toJS.toJS(pair.value, key, ctx);
              } else {
                key = toJS.toJS(pair, "", ctx);
              }
              if (map.has(key))
                throw new Error("Ordered maps must not include duplicate keys");
              map.set(key, value);
            }
            return map;
          }
        };
        YAMLOMap.tag = "tag:yaml.org,2002:omap";
        var omap = {
          collection: "seq",
          identify: (value) => value instanceof Map,
          nodeClass: YAMLOMap,
          default: false,
          tag: "tag:yaml.org,2002:omap",
          resolve(seq, onError) {
            const pairs$1 = pairs.resolvePairs(seq, onError);
            const seenKeys = [];
            for (const { key } of pairs$1.items) {
              if (Node.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                  onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                } else {
                  seenKeys.push(key.value);
                }
              }
            }
            return Object.assign(new YAMLOMap(), pairs$1);
          },
          createNode(schema, iterable, ctx) {
            const pairs$1 = pairs.createPairs(schema, iterable, ctx);
            const omap2 = new YAMLOMap();
            omap2.items = pairs$1.items;
            return omap2;
          }
        };
        exports2.YAMLOMap = YAMLOMap;
        exports2.omap = omap;
      }
    });
    var require_bool22 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        function boolStringify({ value, source }, ctx) {
          const boolObj = value ? trueTag : falseTag;
          if (source && boolObj.test.test(source))
            return source;
          return value ? ctx.options.trueStr : ctx.options.falseStr;
        }
        var trueTag = {
          identify: (value) => value === true,
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
          resolve: () => new Scalar.Scalar(true),
          stringify: boolStringify
        };
        var falseTag = {
          identify: (value) => value === false,
          default: true,
          tag: "tag:yaml.org,2002:bool",
          test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
          resolve: () => new Scalar.Scalar(false),
          stringify: boolStringify
        };
        exports2.falseTag = falseTag;
        exports2.trueTag = trueTag;
      }
    });
    var require_float22 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var stringifyNumber = require_stringifyNumber2();
        var floatNaN = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
          resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
          stringify: stringifyNumber.stringifyNumber
        };
        var floatExp = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "EXP",
          test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
          resolve: (str) => parseFloat(str.replace(/_/g, "")),
          stringify: ({ value }) => Number(value).toExponential()
        };
        var float = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
          resolve(str) {
            const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
            const dot = str.indexOf(".");
            if (dot !== -1) {
              const f = str.substring(dot + 1).replace(/_/g, "");
              if (f[f.length - 1] === "0")
                node.minFractionDigits = f.length;
            }
            return node;
          },
          stringify: stringifyNumber.stringifyNumber
        };
        exports2.float = float;
        exports2.floatExp = floatExp;
        exports2.floatNaN = floatNaN;
      }
    });
    var require_int22 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
        "use strict";
        var stringifyNumber = require_stringifyNumber2();
        var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
        function intResolve(str, offset, radix, { intAsBigInt }) {
          const sign = str[0];
          if (sign === "-" || sign === "+")
            offset += 1;
          str = str.substring(offset).replace(/_/g, "");
          if (intAsBigInt) {
            switch (radix) {
              case 2:
                str = `0b${str}`;
                break;
              case 8:
                str = `0o${str}`;
                break;
              case 16:
                str = `0x${str}`;
                break;
            }
            const n2 = BigInt(str);
            return sign === "-" ? BigInt(-1) * n2 : n2;
          }
          const n = parseInt(str, radix);
          return sign === "-" ? -1 * n : n;
        }
        function intStringify(node, radix, prefix) {
          const { value } = node;
          if (intIdentify(value)) {
            const str = value.toString(radix);
            return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
          }
          return stringifyNumber.stringifyNumber(node);
        }
        var intBin = {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "BIN",
          test: /^[-+]?0b[0-1_]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
          stringify: (node) => intStringify(node, 2, "0b")
        };
        var intOct = {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "OCT",
          test: /^[-+]?0[0-7_]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
          stringify: (node) => intStringify(node, 8, "0")
        };
        var int = {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          test: /^[-+]?[0-9][0-9_]*$/,
          resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
          stringify: stringifyNumber.stringifyNumber
        };
        var intHex = {
          identify: intIdentify,
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "HEX",
          test: /^[-+]?0x[0-9a-fA-F_]+$/,
          resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
          stringify: (node) => intStringify(node, 16, "0x")
        };
        exports2.int = int;
        exports2.intBin = intBin;
        exports2.intHex = intHex;
        exports2.intOct = intOct;
      }
    });
    var require_set2 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Pair = require_Pair2();
        var YAMLMap = require_YAMLMap2();
        var YAMLSet = class extends YAMLMap.YAMLMap {
          constructor(schema) {
            super(schema);
            this.tag = YAMLSet.tag;
          }
          add(key) {
            let pair;
            if (Node.isPair(key))
              pair = key;
            else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
              pair = new Pair.Pair(key.key, null);
            else
              pair = new Pair.Pair(key, null);
            const prev = YAMLMap.findPair(this.items, pair.key);
            if (!prev)
              this.items.push(pair);
          }
          get(key, keepPair) {
            const pair = YAMLMap.findPair(this.items, key);
            return !keepPair && Node.isPair(pair) ? Node.isScalar(pair.key) ? pair.key.value : pair.key : pair;
          }
          set(key, value) {
            if (typeof value !== "boolean")
              throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
            const prev = YAMLMap.findPair(this.items, key);
            if (prev && !value) {
              this.items.splice(this.items.indexOf(prev), 1);
            } else if (!prev && value) {
              this.items.push(new Pair.Pair(key));
            }
          }
          toJSON(_, ctx) {
            return super.toJSON(_, ctx, Set);
          }
          toString(ctx, onComment, onChompKeep) {
            if (!ctx)
              return JSON.stringify(this);
            if (this.hasAllNullValues(true))
              return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
            else
              throw new Error("Set items must all have null values");
          }
        };
        YAMLSet.tag = "tag:yaml.org,2002:set";
        var set = {
          collection: "map",
          identify: (value) => value instanceof Set,
          nodeClass: YAMLSet,
          default: false,
          tag: "tag:yaml.org,2002:set",
          resolve(map, onError) {
            if (Node.isMap(map)) {
              if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
              else
                onError("Set items must all have null values");
            } else
              onError("Expected a mapping for this tag");
            return map;
          },
          createNode(schema, iterable, ctx) {
            const { replacer } = ctx;
            const set2 = new YAMLSet(schema);
            if (iterable && Symbol.iterator in Object(iterable))
              for (let value of iterable) {
                if (typeof replacer === "function")
                  value = replacer.call(iterable, value, value);
                set2.items.push(Pair.createPair(value, null, ctx));
              }
            return set2;
          }
        };
        exports2.YAMLSet = YAMLSet;
        exports2.set = set;
      }
    });
    var require_timestamp2 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
        "use strict";
        var stringifyNumber = require_stringifyNumber2();
        function parseSexagesimal(str, asBigInt) {
          const sign = str[0];
          const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
          const num = (n) => asBigInt ? BigInt(n) : Number(n);
          const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
          return sign === "-" ? num(-1) * res : res;
        }
        function stringifySexagesimal(node) {
          let { value } = node;
          let num = (n) => n;
          if (typeof value === "bigint")
            num = (n) => BigInt(n);
          else if (isNaN(value) || !isFinite(value))
            return stringifyNumber.stringifyNumber(node);
          let sign = "";
          if (value < 0) {
            sign = "-";
            value *= num(-1);
          }
          const _60 = num(60);
          const parts = [value % _60];
          if (value < 60) {
            parts.unshift(0);
          } else {
            value = (value - parts[0]) / _60;
            parts.unshift(value % _60);
            if (value >= 60) {
              value = (value - parts[0]) / _60;
              parts.unshift(value);
            }
          }
          return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
        }
        var intTime = {
          identify: (value) => typeof value === "bigint" || Number.isInteger(value),
          default: true,
          tag: "tag:yaml.org,2002:int",
          format: "TIME",
          test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
          resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
          stringify: stringifySexagesimal
        };
        var floatTime = {
          identify: (value) => typeof value === "number",
          default: true,
          tag: "tag:yaml.org,2002:float",
          format: "TIME",
          test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
          resolve: (str) => parseSexagesimal(str, false),
          stringify: stringifySexagesimal
        };
        var timestamp = {
          identify: (value) => value instanceof Date,
          default: true,
          tag: "tag:yaml.org,2002:timestamp",
          test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
          resolve(str) {
            const match = str.match(timestamp.test);
            if (!match)
              throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
            const [, year, month, day, hour, minute, second] = match.map(Number);
            const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
            let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
            const tz = match[8];
            if (tz && tz !== "Z") {
              let d = parseSexagesimal(tz, false);
              if (Math.abs(d) < 30)
                d *= 60;
              date -= 6e4 * d;
            }
            return new Date(date);
          },
          stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
        };
        exports2.floatTime = floatTime;
        exports2.intTime = intTime;
        exports2.timestamp = timestamp;
      }
    });
    var require_schema32 = __commonJS2({
      "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
        "use strict";
        var map = require_map2();
        var _null = require_null2();
        var seq = require_seq2();
        var string = require_string2();
        var binary = require_binary2();
        var bool = require_bool22();
        var float = require_float22();
        var int = require_int22();
        var omap = require_omap2();
        var pairs = require_pairs2();
        var set = require_set2();
        var timestamp = require_timestamp2();
        var schema = [
          map.map,
          seq.seq,
          string.string,
          _null.nullTag,
          bool.trueTag,
          bool.falseTag,
          int.intBin,
          int.intOct,
          int.int,
          int.intHex,
          float.floatNaN,
          float.floatExp,
          float.float,
          binary.binary,
          omap.omap,
          pairs.pairs,
          set.set,
          timestamp.intTime,
          timestamp.floatTime,
          timestamp.timestamp
        ];
        exports2.schema = schema;
      }
    });
    var require_tags2 = __commonJS2({
      "node_modules/yaml/dist/schema/tags.js"(exports2) {
        "use strict";
        var map = require_map2();
        var _null = require_null2();
        var seq = require_seq2();
        var string = require_string2();
        var bool = require_bool3();
        var float = require_float3();
        var int = require_int3();
        var schema = require_schema4();
        var schema$1 = require_schema22();
        var binary = require_binary2();
        var omap = require_omap2();
        var pairs = require_pairs2();
        var schema$2 = require_schema32();
        var set = require_set2();
        var timestamp = require_timestamp2();
        var schemas = {
          core: schema.schema,
          failsafe: [map.map, seq.seq, string.string],
          json: schema$1.schema,
          yaml11: schema$2.schema,
          "yaml-1.1": schema$2.schema
        };
        var tagsByName = {
          binary: binary.binary,
          bool: bool.boolTag,
          float: float.float,
          floatExp: float.floatExp,
          floatNaN: float.floatNaN,
          floatTime: timestamp.floatTime,
          int: int.int,
          intHex: int.intHex,
          intOct: int.intOct,
          intTime: timestamp.intTime,
          map: map.map,
          null: _null.nullTag,
          omap: omap.omap,
          pairs: pairs.pairs,
          seq: seq.seq,
          set: set.set,
          timestamp: timestamp.timestamp
        };
        var coreKnownTags = {
          "tag:yaml.org,2002:binary": binary.binary,
          "tag:yaml.org,2002:omap": omap.omap,
          "tag:yaml.org,2002:pairs": pairs.pairs,
          "tag:yaml.org,2002:set": set.set,
          "tag:yaml.org,2002:timestamp": timestamp.timestamp
        };
        function getTags(customTags, schemaName) {
          let tags = schemas[schemaName];
          if (!tags) {
            const keys = Object.keys(schemas).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys}`);
          }
          if (Array.isArray(customTags)) {
            for (const tag of customTags)
              tags = tags.concat(tag);
          } else if (typeof customTags === "function") {
            tags = customTags(tags.slice());
          }
          return tags.map((tag) => {
            if (typeof tag !== "string")
              return tag;
            const tagObj = tagsByName[tag];
            if (tagObj)
              return tagObj;
            const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          });
        }
        exports2.coreKnownTags = coreKnownTags;
        exports2.getTags = getTags;
      }
    });
    var require_Schema2 = __commonJS2({
      "node_modules/yaml/dist/schema/Schema.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var map = require_map2();
        var seq = require_seq2();
        var string = require_string2();
        var tags = require_tags2();
        var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
        var Schema = class {
          constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {
            this.merge = !!merge;
            this.name = schema || "core";
            this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
            this.tags = tags.getTags(customTags, this.name);
            Object.defineProperty(this, Node.MAP, { value: map.map });
            Object.defineProperty(this, Node.SCALAR, { value: string.string });
            Object.defineProperty(this, Node.SEQ, { value: seq.seq });
            this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
          }
        };
        exports2.Schema = Schema;
      }
    });
    var require_stringifyDocument2 = __commonJS2({
      "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var stringify = require_stringify2();
        var stringifyComment = require_stringifyComment2();
        function stringifyDocument(doc, options) {
          const lines = [];
          let hasDirectives = options.directives === true;
          if (options.directives !== false) {
            const dir = doc.directives.toString(doc);
            if (dir) {
              lines.push(dir);
              hasDirectives = true;
            } else if (doc.directives.marker)
              hasDirectives = true;
          }
          if (hasDirectives)
            lines.push("---");
          if (doc.commentBefore) {
            if (lines.length !== 1)
              lines.unshift("");
            lines.unshift(stringifyComment.stringifyComment(doc.commentBefore, ""));
          }
          const ctx = stringify.createStringifyContext(doc, options);
          let chompKeep = false;
          let contentComment = null;
          if (doc.contents) {
            if (Node.isNode(doc.contents)) {
              if (doc.contents.spaceBefore && hasDirectives)
                lines.push("");
              if (doc.contents.commentBefore)
                lines.push(stringifyComment.stringifyComment(doc.contents.commentBefore, ""));
              ctx.forceBlockIndent = !!doc.comment;
              contentComment = doc.contents.comment;
            }
            const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
            let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
            if (contentComment)
              body = stringifyComment.addComment(body, "", contentComment);
            if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
              lines[lines.length - 1] = `--- ${body}`;
            } else
              lines.push(body);
          } else {
            lines.push(stringify.stringify(doc.contents, ctx));
          }
          let dc = doc.comment;
          if (dc && chompKeep)
            dc = dc.replace(/^\n+/, "");
          if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
              lines.push("");
            lines.push(stringifyComment.stringifyComment(dc, ""));
          }
          return lines.join("\n") + "\n";
        }
        exports2.stringifyDocument = stringifyDocument;
      }
    });
    var require_applyReviver2 = __commonJS2({
      "node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
        "use strict";
        function applyReviver(reviver, obj, key, val) {
          if (val && typeof val === "object") {
            if (Array.isArray(val)) {
              for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === void 0)
                  delete val[i];
                else if (v1 !== v0)
                  val[i] = v1;
              }
            } else if (val instanceof Map) {
              for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === void 0)
                  val.delete(k);
                else if (v1 !== v0)
                  val.set(k, v1);
              }
            } else if (val instanceof Set) {
              for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === void 0)
                  val.delete(v0);
                else if (v1 !== v0) {
                  val.delete(v0);
                  val.add(v1);
                }
              }
            } else {
              for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === void 0)
                  delete val[k];
                else if (v1 !== v0)
                  val[k] = v1;
              }
            }
          }
          return reviver.call(obj, key, val);
        }
        exports2.applyReviver = applyReviver;
      }
    });
    var require_Document2 = __commonJS2({
      "node_modules/yaml/dist/doc/Document.js"(exports2) {
        "use strict";
        var Alias = require_Alias2();
        var Collection = require_Collection2();
        var Node = require_Node2();
        var Pair = require_Pair2();
        var toJS = require_toJS2();
        var options = require_options2();
        var Schema = require_Schema2();
        var stringify = require_stringify2();
        var stringifyDocument = require_stringifyDocument2();
        var anchors = require_anchors2();
        var applyReviver = require_applyReviver2();
        var createNode = require_createNode2();
        var directives = require_directives2();
        var Document = class {
          constructor(value, replacer, options$1) {
            this.commentBefore = null;
            this.comment = null;
            this.errors = [];
            this.warnings = [];
            Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
            let _replacer = null;
            if (typeof replacer === "function" || Array.isArray(replacer)) {
              _replacer = replacer;
            } else if (options$1 === void 0 && replacer) {
              options$1 = replacer;
              replacer = void 0;
            }
            const opt = Object.assign({}, options.defaultOptions, options$1);
            this.options = opt;
            let { version } = opt;
            if (options$1 === null || options$1 === void 0 ? void 0 : options$1.directives) {
              this.directives = options$1.directives.atDocument();
              if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
            } else
              this.directives = new directives.Directives({ version });
            this.setSchema(version, options$1);
            if (value === void 0)
              this.contents = null;
            else {
              this.contents = this.createNode(value, _replacer, options$1);
            }
          }
          add(value) {
            if (assertCollection(this.contents))
              this.contents.add(value);
          }
          addIn(path2, value) {
            if (assertCollection(this.contents))
              this.contents.addIn(path2, value);
          }
          createAlias(node, name) {
            if (!node.anchor) {
              const prev = anchors.anchorNames(this);
              node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
            }
            return new Alias.Alias(node.anchor);
          }
          createNode(value, replacer, options2) {
            let _replacer = void 0;
            if (typeof replacer === "function") {
              value = replacer.call({ "": value }, "", value);
              _replacer = replacer;
            } else if (Array.isArray(replacer)) {
              const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
              const asStr = replacer.filter(keyToStr).map(String);
              if (asStr.length > 0)
                replacer = replacer.concat(asStr);
              _replacer = replacer;
            } else if (options2 === void 0 && replacer) {
              options2 = replacer;
              replacer = void 0;
            }
            const { anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 || {};
            const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
            const ctx = {
              keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
              onAnchor,
              onTagObj,
              replacer: _replacer,
              schema: this.schema,
              sourceObjects
            };
            const node = createNode.createNode(value, tag, ctx);
            if (flow && Node.isCollection(node))
              node.flow = true;
            setAnchors();
            return node;
          }
          createPair(key, value, options2 = {}) {
            const k = this.createNode(key, null, options2);
            const v = this.createNode(value, null, options2);
            return new Pair.Pair(k, v);
          }
          delete(key) {
            return assertCollection(this.contents) ? this.contents.delete(key) : false;
          }
          deleteIn(path2) {
            if (Collection.isEmptyPath(path2)) {
              if (this.contents == null)
                return false;
              this.contents = null;
              return true;
            }
            return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
          }
          get(key, keepScalar) {
            return Node.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
          }
          getIn(path2, keepScalar) {
            if (Collection.isEmptyPath(path2))
              return !keepScalar && Node.isScalar(this.contents) ? this.contents.value : this.contents;
            return Node.isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
          }
          has(key) {
            return Node.isCollection(this.contents) ? this.contents.has(key) : false;
          }
          hasIn(path2) {
            if (Collection.isEmptyPath(path2))
              return this.contents !== void 0;
            return Node.isCollection(this.contents) ? this.contents.hasIn(path2) : false;
          }
          set(key, value) {
            if (this.contents == null) {
              this.contents = Collection.collectionFromPath(this.schema, [key], value);
            } else if (assertCollection(this.contents)) {
              this.contents.set(key, value);
            }
          }
          setIn(path2, value) {
            if (Collection.isEmptyPath(path2))
              this.contents = value;
            else if (this.contents == null) {
              this.contents = Collection.collectionFromPath(this.schema, Array.from(path2), value);
            } else if (assertCollection(this.contents)) {
              this.contents.setIn(path2, value);
            }
          }
          setSchema(version, options2) {
            let _options;
            switch (String(version)) {
              case "1.1":
                this.directives.yaml.version = "1.1";
                _options = Object.assign({ merge: true, resolveKnownTags: false, schema: "yaml-1.1" }, options2);
                break;
              case "1.2":
                this.directives.yaml.version = "1.2";
                _options = Object.assign({ merge: false, resolveKnownTags: true, schema: "core" }, options2);
                break;
              default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);
              }
            }
            this.schema = new Schema.Schema(_options);
          }
          toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
            const ctx = {
              anchors: new Map(),
              doc: this,
              keep: !json,
              mapAsMap: mapAsMap === true,
              mapKeyWarned: false,
              maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
              stringify: stringify.stringify
            };
            const res = toJS.toJS(this.contents, jsonArg || "", ctx);
            if (typeof onAnchor === "function")
              for (const { count, res: res2 } of ctx.anchors.values())
                onAnchor(res2, count);
            return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
          }
          toJSON(jsonArg, onAnchor) {
            return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
          }
          toString(options2 = {}) {
            if (this.errors.length > 0)
              throw new Error("Document with errors cannot be stringified");
            if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
              const s = JSON.stringify(options2.indent);
              throw new Error(`"indent" option must be a positive integer, not ${s}`);
            }
            return stringifyDocument.stringifyDocument(this, options2);
          }
        };
        function assertCollection(contents) {
          if (Node.isCollection(contents))
            return true;
          throw new Error("Expected a YAML collection as document contents");
        }
        exports2.Document = Document;
      }
    });
    var require_errors2 = __commonJS2({
      "node_modules/yaml/dist/errors.js"(exports2) {
        "use strict";
        var YAMLError = class extends Error {
          constructor(name, pos, code, message) {
            super();
            this.name = name;
            this.code = code;
            this.message = message;
            this.pos = pos;
          }
        };
        var YAMLParseError = class extends YAMLError {
          constructor(pos, code, message) {
            super("YAMLParseError", pos, code, message);
          }
        };
        var YAMLWarning = class extends YAMLError {
          constructor(pos, code, message) {
            super("YAMLWarning", pos, code, message);
          }
        };
        var prettifyError = (src, lc) => (error) => {
          if (error.pos[0] === -1)
            return;
          error.linePos = error.pos.map((pos) => lc.linePos(pos));
          const { line, col } = error.linePos[0];
          error.message += ` at line ${line}, column ${col}`;
          let ci = col - 1;
          let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
          if (ci >= 60 && lineStr.length > 80) {
            const trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = "\u2026" + lineStr.substring(trimStart);
            ci -= trimStart - 1;
          }
          if (lineStr.length > 80)
            lineStr = lineStr.substring(0, 79) + "\u2026";
          if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            if (prev.length > 80)
              prev = prev.substring(0, 79) + "\u2026\n";
            lineStr = prev + lineStr;
          }
          if (/[^ ]/.test(lineStr)) {
            let count = 1;
            const end = error.linePos[1];
            if (end && end.line === line && end.col > col) {
              count = Math.min(end.col - col, 80 - ci);
            }
            const pointer = " ".repeat(ci) + "^".repeat(count);
            error.message += `:

${lineStr}
${pointer}
`;
          }
        };
        exports2.YAMLError = YAMLError;
        exports2.YAMLParseError = YAMLParseError;
        exports2.YAMLWarning = YAMLWarning;
        exports2.prettifyError = prettifyError;
      }
    });
    var require_resolve_props2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
        "use strict";
        function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
          let spaceBefore = false;
          let atNewline = startOnNewline;
          let hasSpace = startOnNewline;
          let comment = "";
          let commentSep = "";
          let hasNewline = false;
          let reqSpace = false;
          let anchor = null;
          let tag = null;
          let comma = null;
          let found = null;
          let start = null;
          for (const token of tokens) {
            if (reqSpace) {
              if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
                onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
              reqSpace = false;
            }
            switch (token.type) {
              case "space":
                if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
                  onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
                hasSpace = true;
                break;
              case "comment": {
                if (!hasSpace)
                  onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                const cb = token.source.substring(1) || " ";
                if (!comment)
                  comment = cb;
                else
                  comment += commentSep + cb;
                commentSep = "";
                atNewline = false;
                break;
              }
              case "newline":
                if (atNewline) {
                  if (comment)
                    comment += token.source;
                  else
                    spaceBefore = true;
                } else
                  commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                hasSpace = true;
                break;
              case "anchor":
                if (anchor)
                  onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
                anchor = token;
                if (start === null)
                  start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
              case "tag": {
                if (tag)
                  onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
                tag = token;
                if (start === null)
                  start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
              }
              case indicator:
                if (anchor || tag)
                  onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
              case "comma":
                if (flow) {
                  if (comma)
                    onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
                  comma = token;
                  atNewline = false;
                  hasSpace = false;
                  break;
                }
              default:
                onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
            }
          }
          const last = tokens[tokens.length - 1];
          const end = last ? last.offset + last.source.length : offset;
          if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
            onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          return {
            comma,
            found,
            spaceBefore,
            comment,
            hasNewline,
            anchor,
            tag,
            end,
            start: start !== null && start !== void 0 ? start : end
          };
        }
        exports2.resolveProps = resolveProps;
      }
    });
    var require_util_contains_newline2 = __commonJS2({
      "node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
        "use strict";
        function containsNewline(key) {
          if (!key)
            return null;
          switch (key.type) {
            case "alias":
            case "scalar":
            case "double-quoted-scalar":
            case "single-quoted-scalar":
              if (key.source.includes("\n"))
                return true;
              if (key.end) {
                for (const st of key.end)
                  if (st.type === "newline")
                    return true;
              }
              return false;
            case "flow-collection":
              for (const it of key.items) {
                for (const st of it.start)
                  if (st.type === "newline")
                    return true;
                if (it.sep) {
                  for (const st of it.sep)
                    if (st.type === "newline")
                      return true;
                }
                if (containsNewline(it.key) || containsNewline(it.value))
                  return true;
              }
              return false;
            default:
              return true;
          }
        }
        exports2.containsNewline = containsNewline;
      }
    });
    var require_util_map_includes2 = __commonJS2({
      "node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        function mapIncludes(ctx, items, search) {
          const { uniqueKeys } = ctx.options;
          if (uniqueKeys === false)
            return false;
          const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || Node.isScalar(a) && Node.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
          return items.some((pair) => isEqual(pair.key, search));
        }
        exports2.mapIncludes = mapIncludes;
      }
    });
    var require_resolve_block_map2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
        "use strict";
        var Pair = require_Pair2();
        var YAMLMap = require_YAMLMap2();
        var resolveProps = require_resolve_props2();
        var utilContainsNewline = require_util_contains_newline2();
        var utilMapIncludes = require_util_map_includes2();
        var startColMsg = "All mapping items must start at the same column";
        function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
          var _a;
          const map = new YAMLMap.YAMLMap(ctx.schema);
          let offset = bm.offset;
          for (const { start, key, sep, value } of bm.items) {
            const keyProps = resolveProps.resolveProps(start, {
              indicator: "explicit-key-ind",
              next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
              offset,
              onError,
              startOnNewline: true
            });
            const implicitKey = !keyProps.found;
            if (implicitKey) {
              if (key) {
                if (key.type === "block-seq")
                  onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
                else if ("indent" in key && key.indent !== bm.indent)
                  onError(offset, "BAD_INDENT", startColMsg);
              }
              if (!keyProps.anchor && !keyProps.tag && !sep) {
                if (keyProps.comment) {
                  if (map.comment)
                    map.comment += "\n" + keyProps.comment;
                  else
                    map.comment = keyProps.comment;
                }
                continue;
              }
            } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
            if (implicitKey && utilContainsNewline.containsNewline(key))
              onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
            const keyStart = keyProps.end;
            const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            const valueProps = resolveProps.resolveProps(sep || [], {
              indicator: "map-value-ind",
              next: value,
              offset: keyNode.range[2],
              onError,
              startOnNewline: !key || key.type === "block-scalar"
            });
            offset = valueProps.end;
            if (valueProps.found) {
              if (implicitKey) {
                if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
                  onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
                if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
                  onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
              }
              const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
              offset = valueNode.range[2];
              map.items.push(new Pair.Pair(keyNode, valueNode));
            } else {
              if (implicitKey)
                onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
              if (valueProps.comment) {
                if (keyNode.comment)
                  keyNode.comment += "\n" + valueProps.comment;
                else
                  keyNode.comment = valueProps.comment;
              }
              map.items.push(new Pair.Pair(keyNode));
            }
          }
          map.range = [bm.offset, offset, offset];
          return map;
        }
        exports2.resolveBlockMap = resolveBlockMap;
      }
    });
    var require_resolve_block_seq2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
        "use strict";
        var YAMLSeq = require_YAMLSeq2();
        var resolveProps = require_resolve_props2();
        function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
          const seq = new YAMLSeq.YAMLSeq(ctx.schema);
          let offset = bs.offset;
          for (const { start, value } of bs.items) {
            const props = resolveProps.resolveProps(start, {
              indicator: "seq-item-ind",
              next: value,
              offset,
              onError,
              startOnNewline: true
            });
            offset = props.end;
            if (!props.found) {
              if (props.anchor || props.tag || value) {
                if (value && value.type === "block-seq")
                  onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
                else
                  onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
              } else {
                if (props.comment)
                  seq.comment = props.comment;
                continue;
              }
            }
            const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, offset, start, null, props, onError);
            offset = node.range[2];
            seq.items.push(node);
          }
          seq.range = [bs.offset, offset, offset];
          return seq;
        }
        exports2.resolveBlockSeq = resolveBlockSeq;
      }
    });
    var require_resolve_end2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
        "use strict";
        function resolveEnd(end, offset, reqSpace, onError) {
          let comment = "";
          if (end) {
            let hasSpace = false;
            let sep = "";
            for (const token of end) {
              const { source, type } = token;
              switch (type) {
                case "space":
                  hasSpace = true;
                  break;
                case "comment": {
                  if (reqSpace && !hasSpace)
                    onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                  const cb = source.substring(1) || " ";
                  if (!comment)
                    comment = cb;
                  else
                    comment += sep + cb;
                  sep = "";
                  break;
                }
                case "newline":
                  if (comment)
                    sep += source;
                  hasSpace = true;
                  break;
                default:
                  onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
              }
              offset += source.length;
            }
          }
          return { comment, offset };
        }
        exports2.resolveEnd = resolveEnd;
      }
    });
    var require_resolve_flow_collection2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Pair = require_Pair2();
        var YAMLMap = require_YAMLMap2();
        var YAMLSeq = require_YAMLSeq2();
        var resolveEnd = require_resolve_end2();
        var resolveProps = require_resolve_props2();
        var utilContainsNewline = require_util_contains_newline2();
        var utilMapIncludes = require_util_map_includes2();
        var blockMsg = "Block collections are not allowed within flow collections";
        var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
        function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
          const isMap = fc.start.source === "{";
          const fcName = isMap ? "flow map" : "flow sequence";
          const coll = isMap ? new YAMLMap.YAMLMap(ctx.schema) : new YAMLSeq.YAMLSeq(ctx.schema);
          coll.flow = true;
          let offset = fc.offset;
          for (let i = 0; i < fc.items.length; ++i) {
            const { start, key, sep, value } = fc.items[i];
            const props = resolveProps.resolveProps(start, {
              flow: fcName,
              indicator: "explicit-key-ind",
              next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
              offset,
              onError,
              startOnNewline: false
            });
            if (!props.found) {
              if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                  onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                  onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                  if (coll.comment)
                    coll.comment += "\n" + props.comment;
                  else
                    coll.comment = props.comment;
                }
                continue;
              }
              if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
            }
            if (i === 0) {
              if (props.comma)
                onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            } else {
              if (!props.comma)
                onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
              if (props.comment) {
                let prevItemComment = "";
                loop:
                  for (const st of start) {
                    switch (st.type) {
                      case "comma":
                      case "space":
                        break;
                      case "comment":
                        prevItemComment = st.source.substring(1);
                        break loop;
                      default:
                        break loop;
                    }
                  }
                if (prevItemComment) {
                  let prev = coll.items[coll.items.length - 1];
                  if (Node.isPair(prev))
                    prev = prev.value || prev.key;
                  if (prev.comment)
                    prev.comment += "\n" + prevItemComment;
                  else
                    prev.comment = prevItemComment;
                  props.comment = props.comment.substring(prevItemComment.length + 1);
                }
              }
            }
            if (!isMap && !sep && !props.found) {
              const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
              coll.items.push(valueNode);
              offset = valueNode.range[2];
              if (isBlock(value))
                onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
            } else {
              const keyStart = props.end;
              const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
              if (isBlock(key))
                onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
              const valueProps = resolveProps.resolveProps(sep || [], {
                flow: fcName,
                indicator: "map-value-ind",
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
              });
              if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                  if (sep)
                    for (const st of sep) {
                      if (st === valueProps.found)
                        break;
                      if (st.type === "newline") {
                        onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                        break;
                      }
                    }
                  if (props.start < valueProps.found.offset - 1024)
                    onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                }
              } else if (value) {
                if ("source" in value && value.source && value.source[0] === ":")
                  onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
                else
                  onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
              }
              const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
              if (valueNode) {
                if (isBlock(value))
                  onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
              } else if (valueProps.comment) {
                if (keyNode.comment)
                  keyNode.comment += "\n" + valueProps.comment;
                else
                  keyNode.comment = valueProps.comment;
              }
              const pair = new Pair.Pair(keyNode, valueNode);
              if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                  onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
                map.items.push(pair);
              } else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
              }
              offset = valueNode ? valueNode.range[2] : valueProps.end;
            }
          }
          const expectedEnd = isMap ? "}" : "]";
          const [ce, ...ee] = fc.end;
          let cePos = offset;
          if (ce && ce.source === expectedEnd)
            cePos = ce.offset + ce.source.length;
          else {
            onError(offset + 1, "MISSING_CHAR", `Expected ${fcName} to end with ${expectedEnd}`);
            if (ce && ce.source.length !== 1)
              ee.unshift(ce);
          }
          if (ee.length > 0) {
            const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
            if (end.comment) {
              if (coll.comment)
                coll.comment += "\n" + end.comment;
              else
                coll.comment = end.comment;
            }
            coll.range = [fc.offset, cePos, end.offset];
          } else {
            coll.range = [fc.offset, cePos, cePos];
          }
          return coll;
        }
        exports2.resolveFlowCollection = resolveFlowCollection;
      }
    });
    var require_compose_collection2 = __commonJS2({
      "node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var resolveBlockMap = require_resolve_block_map2();
        var resolveBlockSeq = require_resolve_block_seq2();
        var resolveFlowCollection = require_resolve_flow_collection2();
        function composeCollection(CN, ctx, token, tagToken, onError) {
          let coll;
          switch (token.type) {
            case "block-map": {
              coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
              break;
            }
            case "block-seq": {
              coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
              break;
            }
            case "flow-collection": {
              coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
              break;
            }
          }
          if (!tagToken)
            return coll;
          const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
          if (!tagName)
            return coll;
          const Coll = coll.constructor;
          if (tagName === "!" || tagName === Coll.tagName) {
            coll.tag = Coll.tagName;
            return coll;
          }
          const expType = Node.isMap(coll) ? "map" : "seq";
          let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
          if (!tag) {
            const kt = ctx.schema.knownTags[tagName];
            if (kt && kt.collection === expType) {
              ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
              tag = kt;
            } else {
              onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
              coll.tag = tagName;
              return coll;
            }
          }
          const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
          const node = Node.isNode(res) ? res : new Scalar.Scalar(res);
          node.range = coll.range;
          node.tag = tagName;
          if (tag === null || tag === void 0 ? void 0 : tag.format)
            node.format = tag.format;
          return node;
        }
        exports2.composeCollection = composeCollection;
      }
    });
    var require_resolve_block_scalar2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        function resolveBlockScalar(scalar, strict, onError) {
          const start = scalar.offset;
          const header = parseBlockScalarHeader(scalar, strict, onError);
          if (!header)
            return { value: "", type: null, comment: "", range: [start, start, start] };
          const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
          const lines = scalar.source ? splitLines(scalar.source) : [];
          let chompStart = lines.length;
          for (let i = lines.length - 1; i >= 0; --i) {
            const content = lines[i][1];
            if (content === "" || content === "\r")
              chompStart = i;
            else
              break;
          }
          if (!scalar.source || chompStart === 0) {
            const value2 = header.chomp === "+" ? lines.map((line) => line[0]).join("\n") : "";
            let end2 = start + header.length;
            if (scalar.source)
              end2 += scalar.source.length;
            return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
          }
          let trimIndent = scalar.indent + header.indent;
          let offset = scalar.offset + header.length;
          let contentStart = 0;
          for (let i = 0; i < chompStart; ++i) {
            const [indent, content] = lines[i];
            if (content === "" || content === "\r") {
              if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
            } else {
              if (indent.length < trimIndent) {
                const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                onError(offset + indent.length, "MISSING_CHAR", message);
              }
              if (header.indent === 0)
                trimIndent = indent.length;
              contentStart = i;
              break;
            }
            offset += indent.length + content.length + 1;
          }
          let value = "";
          let sep = "";
          let prevMoreIndented = false;
          for (let i = 0; i < contentStart; ++i)
            value += lines[i][0].slice(trimIndent) + "\n";
          for (let i = contentStart; i < chompStart; ++i) {
            let [indent, content] = lines[i];
            offset += indent.length + content.length + 1;
            const crlf = content[content.length - 1] === "\r";
            if (crlf)
              content = content.slice(0, -1);
            if (content && indent.length < trimIndent) {
              const src = header.indent ? "explicit indentation indicator" : "first line";
              const message = `Block scalar lines must not be less indented than their ${src}`;
              onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
              indent = "";
            }
            if (type === Scalar.Scalar.BLOCK_LITERAL) {
              value += sep + indent.slice(trimIndent) + content;
              sep = "\n";
            } else if (indent.length > trimIndent || content[0] === "	") {
              if (sep === " ")
                sep = "\n";
              else if (!prevMoreIndented && sep === "\n")
                sep = "\n\n";
              value += sep + indent.slice(trimIndent) + content;
              sep = "\n";
              prevMoreIndented = true;
            } else if (content === "") {
              if (sep === "\n")
                value += "\n";
              else
                sep = "\n";
            } else {
              value += sep + content;
              sep = " ";
              prevMoreIndented = false;
            }
          }
          switch (header.chomp) {
            case "-":
              break;
            case "+":
              for (let i = chompStart; i < lines.length; ++i)
                value += "\n" + lines[i][0].slice(trimIndent);
              if (value[value.length - 1] !== "\n")
                value += "\n";
              break;
            default:
              value += "\n";
          }
          const end = start + header.length + scalar.source.length;
          return { value, type, comment: header.comment, range: [start, end, end] };
        }
        function parseBlockScalarHeader({ offset, props }, strict, onError) {
          if (props[0].type !== "block-scalar-header") {
            onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
            return null;
          }
          const { source } = props[0];
          const mode = source[0];
          let indent = 0;
          let chomp = "";
          let error = -1;
          for (let i = 1; i < source.length; ++i) {
            const ch = source[i];
            if (!chomp && (ch === "-" || ch === "+"))
              chomp = ch;
            else {
              const n = Number(ch);
              if (!indent && n)
                indent = n;
              else if (error === -1)
                error = offset + i;
            }
          }
          if (error !== -1)
            onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
          let hasSpace = false;
          let comment = "";
          let length = source.length;
          for (let i = 1; i < props.length; ++i) {
            const token = props[i];
            switch (token.type) {
              case "space":
                hasSpace = true;
              case "newline":
                length += token.source.length;
                break;
              case "comment":
                if (strict && !hasSpace) {
                  const message = "Comments must be separated from other tokens by white space characters";
                  onError(token, "MISSING_CHAR", message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
              case "error":
                onError(token, "UNEXPECTED_TOKEN", token.message);
                length += token.source.length;
                break;
              default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, "UNEXPECTED_TOKEN", message);
                const ts = token.source;
                if (ts && typeof ts === "string")
                  length += ts.length;
              }
            }
          }
          return { mode, indent, chomp, comment, length };
        }
        function splitLines(source) {
          const split = source.split(/\n( *)/);
          const first = split[0];
          const m = first.match(/^( *)/);
          const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
          const lines = [line0];
          for (let i = 1; i < split.length; i += 2)
            lines.push([split[i], split[i + 1]]);
          return lines;
        }
        exports2.resolveBlockScalar = resolveBlockScalar;
      }
    });
    var require_resolve_flow_scalar2 = __commonJS2({
      "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
        "use strict";
        var Scalar = require_Scalar2();
        var resolveEnd = require_resolve_end2();
        function resolveFlowScalar(scalar, strict, onError) {
          const { offset, type, source, end } = scalar;
          let _type;
          let value;
          const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
          switch (type) {
            case "scalar":
              _type = Scalar.Scalar.PLAIN;
              value = plainValue(source, _onError);
              break;
            case "single-quoted-scalar":
              _type = Scalar.Scalar.QUOTE_SINGLE;
              value = singleQuotedValue(source, _onError);
              break;
            case "double-quoted-scalar":
              _type = Scalar.Scalar.QUOTE_DOUBLE;
              value = doubleQuotedValue(source, _onError);
              break;
            default:
              onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
              return {
                value: "",
                type: null,
                comment: "",
                range: [offset, offset + source.length, offset + source.length]
              };
          }
          const valueEnd = offset + source.length;
          const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
          return {
            value,
            type: _type,
            comment: re.comment,
            range: [offset, valueEnd, re.offset]
          };
        }
        function plainValue(source, onError) {
          let message = "";
          switch (source[0]) {
            case "	":
              message = "Plain value cannot start with a tab character";
              break;
            case "|":
            case ">": {
              message = `Plain value cannot start with block scalar indicator ${source[0]}`;
              break;
            }
            case "@":
            case "`": {
              message = `Plain value cannot start with reserved character ${source[0]}`;
              break;
            }
          }
          if (message)
            onError(0, "BAD_SCALAR_START", message);
          return foldLines(source);
        }
        function singleQuotedValue(source, onError) {
          if (source[source.length - 1] !== "'" || source.length === 1)
            onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
          return foldLines(source.slice(1, -1)).replace(/''/g, "'");
        }
        function foldLines(source) {
          let first, line;
          try {
            first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
            line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
          } catch (_) {
            first = /(.*?)[ \t]*\r?\n/sy;
            line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
          }
          let match = first.exec(source);
          if (!match)
            return source;
          let res = match[1];
          let sep = " ";
          let pos = first.lastIndex;
          line.lastIndex = pos;
          while (match = line.exec(source)) {
            if (match[1] === "") {
              if (sep === "\n")
                res += sep;
              else
                sep = "\n";
            } else {
              res += sep + match[1];
              sep = " ";
            }
            pos = line.lastIndex;
          }
          const last = /[ \t]*(.*)/sy;
          last.lastIndex = pos;
          match = last.exec(source);
          return res + sep + (match && match[1] || "");
        }
        function doubleQuotedValue(source, onError) {
          let res = "";
          for (let i = 1; i < source.length - 1; ++i) {
            const ch = source[i];
            if (ch === "\r" && source[i + 1] === "\n")
              continue;
            if (ch === "\n") {
              const { fold, offset } = foldNewline(source, i);
              res += fold;
              i = offset;
            } else if (ch === "\\") {
              let next = source[++i];
              const cc = escapeCodes[next];
              if (cc)
                res += cc;
              else if (next === "\n") {
                next = source[i + 1];
                while (next === " " || next === "	")
                  next = source[++i + 1];
              } else if (next === "x" || next === "u" || next === "U") {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
              } else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
                res += raw;
              }
            } else if (ch === " " || ch === "	") {
              const wsStart = i;
              let next = source[i + 1];
              while (next === " " || next === "	")
                next = source[++i + 1];
              if (next !== "\n")
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
            } else {
              res += ch;
            }
          }
          if (source[source.length - 1] !== '"' || source.length === 1)
            onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
          return res;
        }
        function foldNewline(source, offset) {
          let fold = "";
          let ch = source[offset + 1];
          while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
            if (ch === "\r" && source[offset + 2] !== "\n")
              break;
            if (ch === "\n")
              fold += "\n";
            offset += 1;
            ch = source[offset + 1];
          }
          if (!fold)
            fold = " ";
          return { fold, offset };
        }
        var escapeCodes = {
          "0": "\0",
          a: "\x07",
          b: "\b",
          e: "",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	",
          v: "\v",
          N: "\x85",
          _: "\xA0",
          L: "\u2028",
          P: "\u2029",
          " ": " ",
          '"': '"',
          "/": "/",
          "\\": "\\",
          "	": "	"
        };
        function parseCharCode(source, offset, length, onError) {
          const cc = source.substr(offset, length);
          const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
          const code = ok ? parseInt(cc, 16) : NaN;
          if (isNaN(code)) {
            const raw = source.substr(offset - 2, length + 2);
            onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            return raw;
          }
          return String.fromCodePoint(code);
        }
        exports2.resolveFlowScalar = resolveFlowScalar;
      }
    });
    var require_compose_scalar2 = __commonJS2({
      "node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
        "use strict";
        var Node = require_Node2();
        var Scalar = require_Scalar2();
        var resolveBlockScalar = require_resolve_block_scalar2();
        var resolveFlowScalar = require_resolve_flow_scalar2();
        function composeScalar(ctx, token, tagToken, onError) {
          const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
          const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
          const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : findScalarTagByTest(ctx.schema, value, token.type === "scalar");
          let scalar;
          try {
            const res = tag.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
            scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
          } catch (error) {
            onError(tagToken || token, "TAG_RESOLVE_FAILED", error.message);
            scalar = new Scalar.Scalar(value);
          }
          scalar.range = range;
          scalar.source = value;
          if (type)
            scalar.type = type;
          if (tagName)
            scalar.tag = tagName;
          if (tag.format)
            scalar.format = tag.format;
          if (comment)
            scalar.comment = comment;
          return scalar;
        }
        function findScalarTagByName(schema, value, tagName, tagToken, onError) {
          var _a;
          if (tagName === "!")
            return schema[Node.SCALAR];
          const matchWithTest = [];
          for (const tag of schema.tags) {
            if (!tag.collection && tag.tag === tagName) {
              if (tag.default && tag.test)
                matchWithTest.push(tag);
              else
                return tag;
            }
          }
          for (const tag of matchWithTest)
            if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
              return tag;
          const kt = schema.knownTags[tagName];
          if (kt && !kt.collection) {
            schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
            return kt;
          }
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
          return schema[Node.SCALAR];
        }
        function findScalarTagByTest(schema, value, apply) {
          var _a;
          if (apply) {
            for (const tag of schema.tags) {
              if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))
                return tag;
            }
          }
          return schema[Node.SCALAR];
        }
        exports2.composeScalar = composeScalar;
      }
    });
    var require_util_empty_scalar_position2 = __commonJS2({
      "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
        "use strict";
        function emptyScalarPosition(offset, before, pos) {
          if (before) {
            if (pos === null)
              pos = before.length;
            for (let i = pos - 1; i >= 0; --i) {
              let st = before[i];
              switch (st.type) {
                case "space":
                case "comment":
                case "newline":
                  offset -= st.source.length;
                  continue;
              }
              st = before[++i];
              while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
                offset += st.source.length;
                st = before[++i];
              }
              break;
            }
          }
          return offset;
        }
        exports2.emptyScalarPosition = emptyScalarPosition;
      }
    });
    var require_compose_node2 = __commonJS2({
      "node_modules/yaml/dist/compose/compose-node.js"(exports2) {
        "use strict";
        var Alias = require_Alias2();
        var composeCollection = require_compose_collection2();
        var composeScalar = require_compose_scalar2();
        var resolveEnd = require_resolve_end2();
        var utilEmptyScalarPosition = require_util_empty_scalar_position2();
        var CN = { composeNode, composeEmptyNode };
        function composeNode(ctx, token, props, onError) {
          const { spaceBefore, comment, anchor, tag } = props;
          let node;
          switch (token.type) {
            case "alias":
              node = composeAlias(ctx, token, onError);
              if (anchor || tag)
                onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
              break;
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
            case "block-scalar":
              node = composeScalar.composeScalar(ctx, token, tag, onError);
              if (anchor)
                node.anchor = anchor.source.substring(1);
              break;
            case "block-map":
            case "block-seq":
            case "flow-collection":
              node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
              if (anchor)
                node.anchor = anchor.source.substring(1);
              break;
            default:
              console.log(token);
              throw new Error(`Unsupporten token type: ${token.type}`);
          }
          if (spaceBefore)
            node.spaceBefore = true;
          if (comment) {
            if (token.type === "scalar" && token.source === "")
              node.comment = comment;
            else
              node.commentBefore = comment;
          }
          return node;
        }
        function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
          const token = {
            type: "scalar",
            offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
            indent: -1,
            source: ""
          };
          const node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          if (spaceBefore)
            node.spaceBefore = true;
          if (comment)
            node.comment = comment;
          return node;
        }
        function composeAlias({ options }, { offset, source, end }, onError) {
          const alias = new Alias.Alias(source.substring(1));
          const valueEnd = offset + source.length;
          const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
          alias.range = [offset, valueEnd, re.offset];
          if (re.comment)
            alias.comment = re.comment;
          return alias;
        }
        exports2.composeEmptyNode = composeEmptyNode;
        exports2.composeNode = composeNode;
      }
    });
    var require_compose_doc2 = __commonJS2({
      "node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
        "use strict";
        var Document = require_Document2();
        var composeNode = require_compose_node2();
        var resolveEnd = require_resolve_end2();
        var resolveProps = require_resolve_props2();
        function composeDoc(options, directives, { offset, start, value, end }, onError) {
          const opts = Object.assign({ directives }, options);
          const doc = new Document.Document(void 0, opts);
          const ctx = {
            directives: doc.directives,
            options: doc.options,
            schema: doc.schema
          };
          const props = resolveProps.resolveProps(start, {
            indicator: "doc-start",
            next: value || (end === null || end === void 0 ? void 0 : end[0]),
            offset,
            onError,
            startOnNewline: true
          });
          if (props.found) {
            doc.directives.marker = true;
            if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
              onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
          }
          doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
          const contentEnd = doc.contents.range[2];
          const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
          if (re.comment)
            doc.comment = re.comment;
          doc.range = [offset, contentEnd, re.offset];
          return doc;
        }
        exports2.composeDoc = composeDoc;
      }
    });
    var require_composer2 = __commonJS2({
      "node_modules/yaml/dist/compose/composer.js"(exports2) {
        "use strict";
        var directives = require_directives2();
        var Document = require_Document2();
        var errors = require_errors2();
        var Node = require_Node2();
        var options = require_options2();
        var composeDoc = require_compose_doc2();
        var resolveEnd = require_resolve_end2();
        function getErrorPos(src) {
          if (typeof src === "number")
            return [src, src + 1];
          if (Array.isArray(src))
            return src.length === 2 ? src : [src[0], src[1]];
          const { offset, source } = src;
          return [offset, offset + (typeof source === "string" ? source.length : 1)];
        }
        function parsePrelude(prelude) {
          let comment = "";
          let atComment = false;
          let afterEmptyLine = false;
          for (let i = 0; i < prelude.length; ++i) {
            const source = prelude[i];
            switch (source[0]) {
              case "#":
                comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
                atComment = true;
                afterEmptyLine = false;
                break;
              case "%":
                if (prelude[i + 1][0] !== "#")
                  i += 1;
                atComment = false;
                break;
              default:
                if (!atComment)
                  afterEmptyLine = true;
                atComment = false;
            }
          }
          return { comment, afterEmptyLine };
        }
        var Composer = class {
          constructor(options$1 = {}) {
            this.doc = null;
            this.atDirectives = false;
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
            this.onError = (source, code, message, warning) => {
              const pos = getErrorPos(source);
              if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
              else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
            };
            this.directives = new directives.Directives({
              version: options$1.version || options.defaultOptions.version
            });
            this.options = options$1;
          }
          decorate(doc, afterDoc) {
            const { comment, afterEmptyLine } = parsePrelude(this.prelude);
            if (comment) {
              const dc = doc.contents;
              if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
              } else if (afterEmptyLine || doc.directives.marker || !dc) {
                doc.commentBefore = comment;
              } else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (Node.isPair(it))
                  it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}
${cb}` : comment;
              } else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}
${cb}` : comment;
              }
            }
            if (afterDoc) {
              Array.prototype.push.apply(doc.errors, this.errors);
              Array.prototype.push.apply(doc.warnings, this.warnings);
            } else {
              doc.errors = this.errors;
              doc.warnings = this.warnings;
            }
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
          }
          streamInfo() {
            return {
              comment: parsePrelude(this.prelude).comment,
              directives: this.directives,
              errors: this.errors,
              warnings: this.warnings
            };
          }
          *compose(tokens, forceDoc = false, endOffset = -1) {
            for (const token of tokens)
              yield* this.next(token);
            yield* this.end(forceDoc, endOffset);
          }
          *next(token) {
            if (process.env.LOG_STREAM)
              console.dir(token, { depth: null });
            switch (token.type) {
              case "directive":
                this.directives.add(token.source, (offset, message, warning) => {
                  const pos = getErrorPos(token);
                  pos[0] += offset;
                  this.onError(pos, "BAD_DIRECTIVE", message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
              case "document": {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.marker)
                  this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
                this.decorate(doc, false);
                if (this.doc)
                  yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
              }
              case "byte-order-mark":
              case "space":
                break;
              case "comment":
              case "newline":
                this.prelude.push(token.source);
                break;
              case "error": {
                const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
                if (this.atDirectives || !this.doc)
                  this.errors.push(error);
                else
                  this.doc.errors.push(error);
                break;
              }
              case "doc-end": {
                if (!this.doc) {
                  const msg = "Unexpected doc-end without preceding document";
                  this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                  break;
                }
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                  const dc = this.doc.comment;
                  this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
              }
              default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
            }
          }
          *end(forceDoc = false, endOffset = -1) {
            if (this.doc) {
              this.decorate(this.doc, true);
              yield this.doc;
              this.doc = null;
            } else if (forceDoc) {
              const opts = Object.assign({ directives: this.directives }, this.options);
              const doc = new Document.Document(void 0, opts);
              if (this.atDirectives)
                this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
              doc.range = [0, endOffset, endOffset];
              this.decorate(doc, false);
              yield doc;
            }
          }
        };
        exports2.Composer = Composer;
      }
    });
    var require_cst_scalar2 = __commonJS2({
      "node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
        "use strict";
        var resolveBlockScalar = require_resolve_block_scalar2();
        var resolveFlowScalar = require_resolve_flow_scalar2();
        var errors = require_errors2();
        var stringifyString = require_stringifyString2();
        function resolveAsScalar(token, strict = true, onError) {
          if (token) {
            const _onError = (pos, code, message) => {
              const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
              if (onError)
                onError(offset, code, message);
              else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
            };
            switch (token.type) {
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
              case "block-scalar":
                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
            }
          }
          return null;
        }
        function createScalarToken(value, context) {
          var _a;
          const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
          const source = stringifyString.stringifyString({ type, value }, {
            implicitKey,
            indent: indent > 0 ? " ".repeat(indent) : "",
            inFlow,
            options: { lineWidth: -1 }
          });
          const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
            { type: "newline", offset: -1, indent, source: "\n" }
          ];
          switch (source[0]) {
            case "|":
            case ">": {
              const he = source.indexOf("\n");
              const head = source.substring(0, he);
              const body = source.substring(he + 1) + "\n";
              const props = [
                { type: "block-scalar-header", offset, indent, source: head }
              ];
              if (!addEndtoBlockProps(props, end))
                props.push({ type: "newline", offset: -1, indent, source: "\n" });
              return { type: "block-scalar", offset, indent, props, source: body };
            }
            case '"':
              return { type: "double-quoted-scalar", offset, indent, source, end };
            case "'":
              return { type: "single-quoted-scalar", offset, indent, source, end };
            default:
              return { type: "scalar", offset, indent, source, end };
          }
        }
        function setScalarValue(token, value, context = {}) {
          let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
          let indent = "indent" in token ? token.indent : null;
          if (afterKey && typeof indent === "number")
            indent += 2;
          if (!type)
            switch (token.type) {
              case "single-quoted-scalar":
                type = "QUOTE_SINGLE";
                break;
              case "double-quoted-scalar":
                type = "QUOTE_DOUBLE";
                break;
              case "block-scalar": {
                const header = token.props[0];
                if (header.type !== "block-scalar-header")
                  throw new Error("Invalid block scalar header");
                type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                break;
              }
              default:
                type = "PLAIN";
            }
          const source = stringifyString.stringifyString({ type, value }, {
            implicitKey: implicitKey || indent === null,
            indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
            inFlow,
            options: { lineWidth: -1 }
          });
          switch (source[0]) {
            case "|":
            case ">":
              setBlockScalarValue(token, source);
              break;
            case '"':
              setFlowScalarValue(token, source, "double-quoted-scalar");
              break;
            case "'":
              setFlowScalarValue(token, source, "single-quoted-scalar");
              break;
            default:
              setFlowScalarValue(token, source, "scalar");
          }
        }
        function setBlockScalarValue(token, source) {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          if (token.type === "block-scalar") {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            header.source = head;
            token.source = body;
          } else {
            const { offset } = token;
            const indent = "indent" in token ? token.indent : -1;
            const props = [
              { type: "block-scalar-header", offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
              props.push({ type: "newline", offset: -1, indent, source: "\n" });
            for (const key of Object.keys(token))
              if (key !== "type" && key !== "offset")
                delete token[key];
            Object.assign(token, { type: "block-scalar", indent, props, source: body });
          }
        }
        function addEndtoBlockProps(props, end) {
          if (end)
            for (const st of end)
              switch (st.type) {
                case "space":
                case "comment":
                  props.push(st);
                  break;
                case "newline":
                  props.push(st);
                  return true;
              }
          return false;
        }
        function setFlowScalarValue(token, source, type) {
          switch (token.type) {
            case "scalar":
            case "double-quoted-scalar":
            case "single-quoted-scalar":
              token.type = type;
              token.source = source;
              break;
            case "block-scalar": {
              const end = token.props.slice(1);
              let oa = source.length;
              if (token.props[0].type === "block-scalar-header")
                oa -= token.props[0].source.length;
              for (const tok of end)
                tok.offset += oa;
              delete token.props;
              Object.assign(token, { type, source, end });
              break;
            }
            case "block-map":
            case "block-seq": {
              const offset = token.offset + source.length;
              const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
              delete token.items;
              Object.assign(token, { type, source, end: [nl] });
              break;
            }
            default: {
              const indent = "indent" in token ? token.indent : -1;
              const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
              for (const key of Object.keys(token))
                if (key !== "type" && key !== "offset")
                  delete token[key];
              Object.assign(token, { type, indent, source, end });
            }
          }
        }
        exports2.createScalarToken = createScalarToken;
        exports2.resolveAsScalar = resolveAsScalar;
        exports2.setScalarValue = setScalarValue;
      }
    });
    var require_cst_stringify2 = __commonJS2({
      "node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
        "use strict";
        var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
        function stringifyToken(token) {
          switch (token.type) {
            case "block-scalar": {
              let res = "";
              for (const tok of token.props)
                res += stringifyToken(tok);
              return res + token.source;
            }
            case "block-map":
            case "block-seq": {
              let res = "";
              for (const item of token.items)
                res += stringifyItem(item);
              return res;
            }
            case "flow-collection": {
              let res = token.start.source;
              for (const item of token.items)
                res += stringifyItem(item);
              for (const st of token.end)
                res += st.source;
              return res;
            }
            case "document": {
              let res = stringifyItem(token);
              if (token.end)
                for (const st of token.end)
                  res += st.source;
              return res;
            }
            default: {
              let res = token.source;
              if ("end" in token && token.end)
                for (const st of token.end)
                  res += st.source;
              return res;
            }
          }
        }
        function stringifyItem({ start, key, sep, value }) {
          let res = "";
          for (const st of start)
            res += st.source;
          if (key)
            res += stringifyToken(key);
          if (sep)
            for (const st of sep)
              res += st.source;
          if (value)
            res += stringifyToken(value);
          return res;
        }
        exports2.stringify = stringify;
      }
    });
    var require_cst_visit2 = __commonJS2({
      "node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
        "use strict";
        var BREAK = Symbol("break visit");
        var SKIP = Symbol("skip children");
        var REMOVE = Symbol("remove item");
        function visit(cst, visitor) {
          if ("type" in cst && cst.type === "document")
            cst = { start: cst.start, value: cst.value };
          _visit(Object.freeze([]), cst, visitor);
        }
        visit.BREAK = BREAK;
        visit.SKIP = SKIP;
        visit.REMOVE = REMOVE;
        visit.itemAtPath = (cst, path2) => {
          let item = cst;
          for (const [field, index] of path2) {
            const tok = item && item[field];
            if (tok && "items" in tok) {
              item = tok.items[index];
            } else
              return void 0;
          }
          return item;
        };
        visit.parentCollection = (cst, path2) => {
          const parent = visit.itemAtPath(cst, path2.slice(0, -1));
          const field = path2[path2.length - 1][0];
          const coll = parent && parent[field];
          if (coll && "items" in coll)
            return coll;
          throw new Error("Parent collection not found");
        };
        function _visit(path2, item, visitor) {
          let ctrl = visitor(item, path2);
          if (typeof ctrl === "symbol")
            return ctrl;
          for (const field of ["key", "value"]) {
            const token = item[field];
            if (token && "items" in token) {
              for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path2.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === "number")
                  i = ci - 1;
                else if (ci === BREAK)
                  return BREAK;
                else if (ci === REMOVE) {
                  token.items.splice(i, 1);
                  i -= 1;
                }
              }
              if (typeof ctrl === "function" && field === "key")
                ctrl = ctrl(item, path2);
            }
          }
          return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
        }
        exports2.visit = visit;
      }
    });
    var require_cst2 = __commonJS2({
      "node_modules/yaml/dist/parse/cst.js"(exports2) {
        "use strict";
        var cstScalar = require_cst_scalar2();
        var cstStringify = require_cst_stringify2();
        var cstVisit = require_cst_visit2();
        var BOM = "\uFEFF";
        var DOCUMENT = "";
        var FLOW_END = "";
        var SCALAR = "";
        var isCollection = (token) => !!token && "items" in token;
        var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
        function prettyToken(token) {
          switch (token) {
            case BOM:
              return "<BOM>";
            case DOCUMENT:
              return "<DOC>";
            case FLOW_END:
              return "<FLOW_END>";
            case SCALAR:
              return "<SCALAR>";
            default:
              return JSON.stringify(token);
          }
        }
        function tokenType(source) {
          switch (source) {
            case BOM:
              return "byte-order-mark";
            case DOCUMENT:
              return "doc-mode";
            case FLOW_END:
              return "flow-error-end";
            case SCALAR:
              return "scalar";
            case "---":
              return "doc-start";
            case "...":
              return "doc-end";
            case "":
            case "\n":
            case "\r\n":
              return "newline";
            case "-":
              return "seq-item-ind";
            case "?":
              return "explicit-key-ind";
            case ":":
              return "map-value-ind";
            case "{":
              return "flow-map-start";
            case "}":
              return "flow-map-end";
            case "[":
              return "flow-seq-start";
            case "]":
              return "flow-seq-end";
            case ",":
              return "comma";
          }
          switch (source[0]) {
            case " ":
            case "	":
              return "space";
            case "#":
              return "comment";
            case "%":
              return "directive-line";
            case "*":
              return "alias";
            case "&":
              return "anchor";
            case "!":
              return "tag";
            case "'":
              return "single-quoted-scalar";
            case '"':
              return "double-quoted-scalar";
            case "|":
            case ">":
              return "block-scalar-header";
          }
          return null;
        }
        exports2.createScalarToken = cstScalar.createScalarToken;
        exports2.resolveAsScalar = cstScalar.resolveAsScalar;
        exports2.setScalarValue = cstScalar.setScalarValue;
        exports2.stringify = cstStringify.stringify;
        exports2.visit = cstVisit.visit;
        exports2.BOM = BOM;
        exports2.DOCUMENT = DOCUMENT;
        exports2.FLOW_END = FLOW_END;
        exports2.SCALAR = SCALAR;
        exports2.isCollection = isCollection;
        exports2.isScalar = isScalar;
        exports2.prettyToken = prettyToken;
        exports2.tokenType = tokenType;
      }
    });
    var require_lexer2 = __commonJS2({
      "node_modules/yaml/dist/parse/lexer.js"(exports2) {
        "use strict";
        var cst = require_cst2();
        function isEmpty(ch) {
          switch (ch) {
            case void 0:
            case " ":
            case "\n":
            case "\r":
            case "	":
              return true;
            default:
              return false;
          }
        }
        var invalidFlowScalarChars = [",", "[", "]", "{", "}"];
        var invalidIdentifierChars = [" ", ",", "[", "]", "{", "}", "\n", "\r", "	"];
        var isNotIdentifierChar = (ch) => !ch || invalidIdentifierChars.includes(ch);
        var Lexer = class {
          constructor() {
            this.atEnd = false;
            this.blockScalarIndent = -1;
            this.blockScalarKeep = false;
            this.buffer = "";
            this.flowKey = false;
            this.flowLevel = 0;
            this.indentNext = 0;
            this.indentValue = 0;
            this.next = null;
            this.pos = 0;
          }
          *lex(source, incomplete = false) {
            if (source)
              this.buffer = this.buffer ? this.buffer + source : source;
            this.atEnd = !incomplete;
            let next = this.next || "stream";
            while (next && (incomplete || this.hasChars(1)))
              next = yield* this.parseNext(next);
          }
          atLineEnd() {
            let i = this.pos;
            let ch = this.buffer[i];
            while (ch === " " || ch === "	")
              ch = this.buffer[++i];
            if (!ch || ch === "#" || ch === "\n")
              return true;
            if (ch === "\r")
              return this.buffer[i + 1] === "\n";
            return false;
          }
          charAt(n) {
            return this.buffer[this.pos + n];
          }
          continueScalar(offset) {
            let ch = this.buffer[offset];
            if (this.indentNext > 0) {
              let indent = 0;
              while (ch === " ")
                ch = this.buffer[++indent + offset];
              if (ch === "\r") {
                const next = this.buffer[indent + offset + 1];
                if (next === "\n" || !next && !this.atEnd)
                  return offset + indent + 1;
              }
              return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
            }
            if (ch === "-" || ch === ".") {
              const dt = this.buffer.substr(offset, 3);
              if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
                return -1;
            }
            return offset;
          }
          getLine() {
            let end = this.buffer.indexOf("\n", this.pos);
            if (end === -1)
              return this.atEnd ? this.buffer.substring(this.pos) : null;
            if (this.buffer[end - 1] === "\r")
              end -= 1;
            return this.buffer.substring(this.pos, end);
          }
          hasChars(n) {
            return this.pos + n <= this.buffer.length;
          }
          setNext(state) {
            this.buffer = this.buffer.substring(this.pos);
            this.pos = 0;
            this.next = state;
            return null;
          }
          peek(n) {
            return this.buffer.substr(this.pos, n);
          }
          *parseNext(next) {
            switch (next) {
              case "stream":
                return yield* this.parseStream();
              case "line-start":
                return yield* this.parseLineStart();
              case "block-start":
                return yield* this.parseBlockStart();
              case "doc":
                return yield* this.parseDocument();
              case "flow":
                return yield* this.parseFlowCollection();
              case "quoted-scalar":
                return yield* this.parseQuotedScalar();
              case "block-scalar":
                return yield* this.parseBlockScalar();
              case "plain-scalar":
                return yield* this.parsePlainScalar();
            }
          }
          *parseStream() {
            let line = this.getLine();
            if (line === null)
              return this.setNext("stream");
            if (line[0] === cst.BOM) {
              yield* this.pushCount(1);
              line = line.substring(1);
            }
            if (line[0] === "%") {
              let dirEnd = line.length;
              const cs = line.indexOf("#");
              if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === " " || ch === "	")
                  dirEnd = cs - 1;
              }
              while (true) {
                const ch = line[dirEnd - 1];
                if (ch === " " || ch === "	")
                  dirEnd -= 1;
                else
                  break;
              }
              const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
              yield* this.pushCount(line.length - n);
              this.pushNewline();
              return "stream";
            }
            if (this.atLineEnd()) {
              const sp = yield* this.pushSpaces(true);
              yield* this.pushCount(line.length - sp);
              yield* this.pushNewline();
              return "stream";
            }
            yield cst.DOCUMENT;
            return yield* this.parseLineStart();
          }
          *parseLineStart() {
            const ch = this.charAt(0);
            if (!ch && !this.atEnd)
              return this.setNext("line-start");
            if (ch === "-" || ch === ".") {
              if (!this.atEnd && !this.hasChars(4))
                return this.setNext("line-start");
              const s = this.peek(3);
              if (s === "---" && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return "doc";
              } else if (s === "..." && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return "stream";
              }
            }
            this.indentValue = yield* this.pushSpaces(false);
            if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
              this.indentNext = this.indentValue;
            return yield* this.parseBlockStart();
          }
          *parseBlockStart() {
            const [ch0, ch1] = this.peek(2);
            if (!ch1 && !this.atEnd)
              return this.setNext("block-start");
            if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
              const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
              this.indentNext = this.indentValue + 1;
              this.indentValue += n;
              return yield* this.parseBlockStart();
            }
            return "doc";
          }
          *parseDocument() {
            yield* this.pushSpaces(true);
            const line = this.getLine();
            if (line === null)
              return this.setNext("doc");
            let n = yield* this.pushIndicators();
            switch (line[n]) {
              case "#":
                yield* this.pushCount(line.length - n);
              case void 0:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
              case "{":
              case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return "flow";
              case "}":
              case "]":
                yield* this.pushCount(1);
                return "doc";
              case "*":
                yield* this.pushUntil(isNotIdentifierChar);
                return "doc";
              case '"':
              case "'":
                return yield* this.parseQuotedScalar();
              case "|":
              case ">":
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
              default:
                return yield* this.parsePlainScalar();
            }
          }
          *parseFlowCollection() {
            let nl, sp;
            let indent = -1;
            do {
              nl = yield* this.pushNewline();
              sp = yield* this.pushSpaces(true);
              if (nl > 0)
                this.indentValue = indent = sp;
            } while (nl + sp > 0);
            const line = this.getLine();
            if (line === null)
              return this.setNext("flow");
            if (indent !== -1 && indent < this.indentNext || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
              const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
              if (!atFlowEndMarker) {
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
              }
            }
            let n = 0;
            while (line[n] === ",")
              n += (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            n += yield* this.pushIndicators();
            switch (line[n]) {
              case void 0:
                return "flow";
              case "#":
                yield* this.pushCount(line.length - n);
                return "flow";
              case "{":
              case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return "flow";
              case "}":
              case "]":
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? "flow" : "doc";
              case "*":
                yield* this.pushUntil(isNotIdentifierChar);
                return "flow";
              case '"':
              case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
              case ":": {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ",") {
                  yield* this.pushCount(1);
                  yield* this.pushSpaces(true);
                  return "flow";
                }
              }
              default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
            }
          }
          *parseQuotedScalar() {
            const quote = this.charAt(0);
            let end = this.buffer.indexOf(quote, this.pos + 1);
            if (quote === "'") {
              while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
            } else {
              while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === "\\")
                  n += 1;
                if (n % 2 === 0)
                  break;
                end = this.buffer.indexOf('"', end + 1);
              }
            }
            let nl = this.buffer.indexOf("\n", this.pos);
            if (nl !== -1 && nl < end) {
              while (nl !== -1 && nl < end) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                  break;
                nl = this.buffer.indexOf("\n", cs);
              }
              if (nl !== -1 && nl < end) {
                end = nl - 1;
              }
            }
            if (end === -1) {
              if (!this.atEnd)
                return this.setNext("quoted-scalar");
              end = this.buffer.length;
            }
            yield* this.pushToIndex(end + 1, false);
            return this.flowLevel ? "flow" : "doc";
          }
          *parseBlockScalarHeader() {
            this.blockScalarIndent = -1;
            this.blockScalarKeep = false;
            let i = this.pos;
            while (true) {
              const ch = this.buffer[++i];
              if (ch === "+")
                this.blockScalarKeep = true;
              else if (ch > "0" && ch <= "9")
                this.blockScalarIndent = Number(ch) - 1;
              else if (ch !== "-")
                break;
            }
            return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
          }
          *parseBlockScalar() {
            let nl = this.pos - 1;
            let indent = 0;
            let ch;
            loop:
              for (let i = this.pos; ch = this.buffer[i]; ++i) {
                switch (ch) {
                  case " ":
                    indent += 1;
                    break;
                  case "\n":
                    nl = i;
                    indent = 0;
                    break;
                  case "\r": {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                      return this.setNext("block-scalar");
                    if (next === "\n")
                      break;
                  }
                  default:
                    break loop;
                }
              }
            if (!ch && !this.atEnd)
              return this.setNext("block-scalar");
            if (indent >= this.indentNext) {
              if (this.blockScalarIndent === -1)
                this.indentNext = indent;
              else
                this.indentNext += this.blockScalarIndent;
              do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                  break;
                nl = this.buffer.indexOf("\n", cs);
              } while (nl !== -1);
              if (nl === -1) {
                if (!this.atEnd)
                  return this.setNext("block-scalar");
                nl = this.buffer.length;
              }
            }
            if (!this.blockScalarKeep) {
              do {
                let i = nl - 1;
                let ch2 = this.buffer[i];
                if (ch2 === "\r")
                  ch2 = this.buffer[--i];
                while (ch2 === " " || ch2 === "	")
                  ch2 = this.buffer[--i];
                if (ch2 === "\n" && i >= this.pos)
                  nl = i;
                else
                  break;
              } while (true);
            }
            yield cst.SCALAR;
            yield* this.pushToIndex(nl + 1, true);
            return yield* this.parseLineStart();
          }
          *parsePlainScalar() {
            const inFlow = this.flowLevel > 0;
            let end = this.pos - 1;
            let i = this.pos - 1;
            let ch;
            while (ch = this.buffer[++i]) {
              if (ch === ":") {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || inFlow && next === ",")
                  break;
                end = i;
              } else if (isEmpty(ch)) {
                const next = this.buffer[i + 1];
                if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
                  break;
                if (ch === "\r") {
                  if (next === "\n") {
                    i += 1;
                    ch = "\n";
                  } else
                    end = i;
                }
                if (ch === "\n") {
                  const cs = this.continueScalar(i + 1);
                  if (cs === -1)
                    break;
                  i = Math.max(i, cs - 2);
                }
              } else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                  break;
                end = i;
              }
            }
            if (!ch && !this.atEnd)
              return this.setNext("plain-scalar");
            yield cst.SCALAR;
            yield* this.pushToIndex(end + 1, true);
            return inFlow ? "flow" : "doc";
          }
          *pushCount(n) {
            if (n > 0) {
              yield this.buffer.substr(this.pos, n);
              this.pos += n;
              return n;
            }
            return 0;
          }
          *pushToIndex(i, allowEmpty) {
            const s = this.buffer.slice(this.pos, i);
            if (s) {
              yield s;
              this.pos += s.length;
              return s.length;
            } else if (allowEmpty)
              yield "";
            return 0;
          }
          *pushIndicators() {
            switch (this.charAt(0)) {
              case "!":
                if (this.charAt(1) === "<")
                  return (yield* this.pushVerbatimTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
              case "&":
                return (yield* this.pushUntil(isNotIdentifierChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
              case ":":
              case "?":
              case "-":
                if (isEmpty(this.charAt(1))) {
                  if (this.flowLevel === 0)
                    this.indentNext = this.indentValue + 1;
                  return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                }
            }
            return 0;
          }
          *pushVerbatimTag() {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== ">")
              ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
          }
          *pushNewline() {
            const ch = this.buffer[this.pos];
            if (ch === "\n")
              return yield* this.pushCount(1);
            else if (ch === "\r" && this.charAt(1) === "\n")
              return yield* this.pushCount(2);
            else
              return 0;
          }
          *pushSpaces(allowTabs) {
            let i = this.pos - 1;
            let ch;
            do {
              ch = this.buffer[++i];
            } while (ch === " " || allowTabs && ch === "	");
            const n = i - this.pos;
            if (n > 0) {
              yield this.buffer.substr(this.pos, n);
              this.pos = i;
            }
            return n;
          }
          *pushUntil(test) {
            let i = this.pos;
            let ch = this.buffer[i];
            while (!test(ch))
              ch = this.buffer[++i];
            return yield* this.pushToIndex(i, false);
          }
        };
        exports2.Lexer = Lexer;
      }
    });
    var require_line_counter2 = __commonJS2({
      "node_modules/yaml/dist/parse/line-counter.js"(exports2) {
        "use strict";
        var LineCounter = class {
          constructor() {
            this.lineStarts = [];
            this.addNewLine = (offset) => this.lineStarts.push(offset);
            this.linePos = (offset) => {
              let low = 0;
              let high = this.lineStarts.length;
              while (low < high) {
                const mid = low + high >> 1;
                if (this.lineStarts[mid] < offset)
                  low = mid + 1;
                else
                  high = mid;
              }
              if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
              if (low === 0)
                return { line: 0, col: offset };
              const start = this.lineStarts[low - 1];
              return { line: low, col: offset - start + 1 };
            };
          }
        };
        exports2.LineCounter = LineCounter;
      }
    });
    var require_parser2 = __commonJS2({
      "node_modules/yaml/dist/parse/parser.js"(exports2) {
        "use strict";
        var cst = require_cst2();
        var lexer = require_lexer2();
        function includesToken(list, type) {
          for (let i = 0; i < list.length; ++i)
            if (list[i].type === type)
              return true;
          return false;
        }
        function includesNonEmpty(list) {
          for (let i = 0; i < list.length; ++i) {
            switch (list[i].type) {
              case "space":
              case "comment":
              case "newline":
                break;
              default:
                return true;
            }
          }
          return false;
        }
        function isFlowToken(token) {
          switch (token === null || token === void 0 ? void 0 : token.type) {
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
            case "flow-collection":
              return true;
            default:
              return false;
          }
        }
        function getPrevProps(parent) {
          switch (parent.type) {
            case "document":
              return parent.start;
            case "block-map": {
              const it = parent.items[parent.items.length - 1];
              return it.sep || it.start;
            }
            case "block-seq":
              return parent.items[parent.items.length - 1].start;
            default:
              return [];
          }
        }
        function getFirstKeyStartProps(prev) {
          var _a;
          if (prev.length === 0)
            return [];
          let i = prev.length;
          loop:
            while (--i >= 0) {
              switch (prev[i].type) {
                case "doc-start":
                case "explicit-key-ind":
                case "map-value-ind":
                case "seq-item-ind":
                case "newline":
                  break loop;
              }
            }
          while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
          }
          return prev.splice(i, prev.length);
        }
        function fixFlowSeqItems(fc) {
          if (fc.start.type === "flow-seq-start") {
            for (const it of fc.items) {
              if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
                if (it.key)
                  it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                  if (it.value.end)
                    Array.prototype.push.apply(it.value.end, it.sep);
                  else
                    it.value.end = it.sep;
                } else
                  Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
              }
            }
          }
        }
        var Parser = class {
          constructor(onNewLine) {
            this.atNewLine = true;
            this.atScalar = false;
            this.indent = 0;
            this.offset = 0;
            this.onKeyLine = false;
            this.stack = [];
            this.source = "";
            this.type = "";
            this.lexer = new lexer.Lexer();
            this.onNewLine = onNewLine;
          }
          *parse(source, incomplete = false) {
            if (this.onNewLine && this.offset === 0)
              this.onNewLine(0);
            for (const lexeme of this.lexer.lex(source, incomplete))
              yield* this.next(lexeme);
            if (!incomplete)
              yield* this.end();
          }
          *next(source) {
            this.source = source;
            if (process.env.LOG_TOKENS)
              console.log("|", cst.prettyToken(source));
            if (this.atScalar) {
              this.atScalar = false;
              yield* this.step();
              this.offset += source.length;
              return;
            }
            const type = cst.tokenType(source);
            if (!type) {
              const message = `Not a YAML token: ${source}`;
              yield* this.pop({ type: "error", offset: this.offset, message, source });
              this.offset += source.length;
            } else if (type === "scalar") {
              this.atNewLine = false;
              this.atScalar = true;
              this.type = "scalar";
            } else {
              this.type = type;
              yield* this.step();
              switch (type) {
                case "newline":
                  this.atNewLine = true;
                  this.indent = 0;
                  if (this.onNewLine)
                    this.onNewLine(this.offset + source.length);
                  break;
                case "space":
                  if (this.atNewLine && source[0] === " ")
                    this.indent += source.length;
                  break;
                case "explicit-key-ind":
                case "map-value-ind":
                case "seq-item-ind":
                  if (this.atNewLine)
                    this.indent += source.length;
                  break;
                case "doc-mode":
                  return;
                default:
                  this.atNewLine = false;
              }
              this.offset += source.length;
            }
          }
          *end() {
            while (this.stack.length > 0)
              yield* this.pop();
          }
          get sourceToken() {
            const st = {
              type: this.type,
              offset: this.offset,
              indent: this.indent,
              source: this.source
            };
            return st;
          }
          *step() {
            const top = this.peek(1);
            if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
              while (this.stack.length > 0)
                yield* this.pop();
              this.stack.push({
                type: "doc-end",
                offset: this.offset,
                source: this.source
              });
              return;
            }
            if (!top)
              return yield* this.stream();
            switch (top.type) {
              case "document":
                return yield* this.document(top);
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return yield* this.scalar(top);
              case "block-scalar":
                return yield* this.blockScalar(top);
              case "block-map":
                return yield* this.blockMap(top);
              case "block-seq":
                return yield* this.blockSequence(top);
              case "flow-collection":
                return yield* this.flowCollection(top);
              case "doc-end":
                return yield* this.documentEnd(top);
            }
            yield* this.pop();
          }
          peek(n) {
            return this.stack[this.stack.length - n];
          }
          *pop(error) {
            const token = error || this.stack.pop();
            if (!token) {
              const message = "Tried to pop an empty stack";
              yield { type: "error", offset: this.offset, source: "", message };
            } else if (this.stack.length === 0) {
              yield token;
            } else {
              const top = this.peek(1);
              if (token.type === "block-scalar" || token.type === "flow-collection")
                token.indent = "indent" in top ? top.indent : -1;
              if (token.type === "flow-collection")
                fixFlowSeqItems(token);
              switch (top.type) {
                case "document":
                  top.value = token;
                  break;
                case "block-scalar":
                  top.props.push(token);
                  break;
                case "block-map": {
                  const it = top.items[top.items.length - 1];
                  if (it.value) {
                    top.items.push({ start: [], key: token, sep: [] });
                    this.onKeyLine = true;
                    return;
                  } else if (it.sep) {
                    it.value = token;
                  } else {
                    Object.assign(it, { key: token, sep: [] });
                    this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                    return;
                  }
                  break;
                }
                case "block-seq": {
                  const it = top.items[top.items.length - 1];
                  if (it.value)
                    top.items.push({ start: [], value: token });
                  else
                    it.value = token;
                  break;
                }
                case "flow-collection": {
                  const it = top.items[top.items.length - 1];
                  if (!it || it.value)
                    top.items.push({ start: [], key: token, sep: [] });
                  else if (it.sep)
                    it.value = token;
                  else
                    Object.assign(it, { key: token, sep: [] });
                  return;
                }
                default:
                  yield* this.pop();
                  yield* this.pop(token);
              }
              if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
                const last = token.items[token.items.length - 1];
                if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
                  if (top.type === "document")
                    top.end = last.start;
                  else
                    top.items.push({ start: last.start });
                  token.items.splice(-1, 1);
                }
              }
            }
          }
          *stream() {
            switch (this.type) {
              case "directive-line":
                yield { type: "directive", offset: this.offset, source: this.source };
                return;
              case "byte-order-mark":
              case "space":
              case "comment":
              case "newline":
                yield this.sourceToken;
                return;
              case "doc-mode":
              case "doc-start": {
                const doc = {
                  type: "document",
                  offset: this.offset,
                  start: []
                };
                if (this.type === "doc-start")
                  doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
              }
            }
            yield {
              type: "error",
              offset: this.offset,
              message: `Unexpected ${this.type} token in YAML stream`,
              source: this.source
            };
          }
          *document(doc) {
            if (doc.value)
              return yield* this.lineEnd(doc);
            switch (this.type) {
              case "doc-start": {
                if (includesNonEmpty(doc.start)) {
                  yield* this.pop();
                  yield* this.step();
                } else
                  doc.start.push(this.sourceToken);
                return;
              }
              case "anchor":
              case "tag":
              case "space":
              case "comment":
              case "newline":
                doc.start.push(this.sourceToken);
                return;
            }
            const bv = this.startBlockValue(doc);
            if (bv)
              this.stack.push(bv);
            else {
              yield {
                type: "error",
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
              };
            }
          }
          *scalar(scalar) {
            if (this.type === "map-value-ind") {
              const prev = getPrevProps(this.peek(2));
              const start = getFirstKeyStartProps(prev);
              let sep;
              if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
              } else
                sep = [this.sourceToken];
              const map = {
                type: "block-map",
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
              };
              this.onKeyLine = true;
              this.stack[this.stack.length - 1] = map;
            } else
              yield* this.lineEnd(scalar);
          }
          *blockScalar(scalar) {
            switch (this.type) {
              case "space":
              case "comment":
              case "newline":
                scalar.props.push(this.sourceToken);
                return;
              case "scalar":
                scalar.source = this.source;
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                  let nl = this.source.indexOf("\n") + 1;
                  while (nl !== 0) {
                    this.onNewLine(this.offset + nl);
                    nl = this.source.indexOf("\n", nl) + 1;
                  }
                }
                yield* this.pop();
                break;
              default:
                yield* this.pop();
                yield* this.step();
            }
          }
          *blockMap(map) {
            var _a;
            const it = map.items[map.items.length - 1];
            switch (this.type) {
              case "newline":
                this.onKeyLine = false;
                if (it.value) {
                  const end = "end" in it.value ? it.value.end : void 0;
                  const last = Array.isArray(end) ? end[end.length - 1] : void 0;
                  if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                    end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                  else
                    map.items.push({ start: [this.sourceToken] });
                } else if (it.sep)
                  it.sep.push(this.sourceToken);
                else
                  it.start.push(this.sourceToken);
                return;
              case "space":
              case "comment":
                if (it.value)
                  map.items.push({ start: [this.sourceToken] });
                else if (it.sep)
                  it.sep.push(this.sourceToken);
                else {
                  if (this.atIndentedComment(it.start, map.indent)) {
                    const prev = map.items[map.items.length - 2];
                    const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                    if (Array.isArray(end)) {
                      Array.prototype.push.apply(end, it.start);
                      end.push(this.sourceToken);
                      map.items.pop();
                      return;
                    }
                  }
                  it.start.push(this.sourceToken);
                }
                return;
            }
            if (this.indent >= map.indent) {
              const atNextItem = !this.onKeyLine && this.indent === map.indent && (it.sep || includesNonEmpty(it.start));
              switch (this.type) {
                case "anchor":
                case "tag":
                  if (atNextItem || it.value) {
                    map.items.push({ start: [this.sourceToken] });
                    this.onKeyLine = true;
                  } else if (it.sep)
                    it.sep.push(this.sourceToken);
                  else
                    it.start.push(this.sourceToken);
                  return;
                case "explicit-key-ind":
                  if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
                    it.start.push(this.sourceToken);
                  else if (atNextItem || it.value)
                    map.items.push({ start: [this.sourceToken] });
                  else
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: [this.sourceToken] }]
                    });
                  this.onKeyLine = true;
                  return;
                case "map-value-ind":
                  if (!it.sep)
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
                    map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                  else if (includesToken(it.sep, "map-value-ind"))
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: [], key: null, sep: [this.sourceToken] }]
                    });
                  else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                    const start = getFirstKeyStartProps(it.start);
                    const key = it.key;
                    const sep = it.sep;
                    sep.push(this.sourceToken);
                    delete it.key, delete it.sep;
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key, sep }]
                    });
                  } else
                    it.sep.push(this.sourceToken);
                  this.onKeyLine = true;
                  return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar": {
                  const fs = this.flowScalar(this.type);
                  if (atNextItem || it.value) {
                    map.items.push({ start: [], key: fs, sep: [] });
                    this.onKeyLine = true;
                  } else if (it.sep) {
                    this.stack.push(fs);
                  } else {
                    Object.assign(it, { key: fs, sep: [] });
                    this.onKeyLine = true;
                  }
                  return;
                }
                default: {
                  const bv = this.startBlockValue(map);
                  if (bv) {
                    if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
                      map.items.push({ start: [] });
                    this.stack.push(bv);
                    return;
                  }
                }
              }
            }
            yield* this.pop();
            yield* this.step();
          }
          *blockSequence(seq) {
            var _a;
            const it = seq.items[seq.items.length - 1];
            switch (this.type) {
              case "newline":
                if (it.value) {
                  const end = "end" in it.value ? it.value.end : void 0;
                  const last = Array.isArray(end) ? end[end.length - 1] : void 0;
                  if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                    end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                  else
                    seq.items.push({ start: [this.sourceToken] });
                } else
                  it.start.push(this.sourceToken);
                return;
              case "space":
              case "comment":
                if (it.value)
                  seq.items.push({ start: [this.sourceToken] });
                else {
                  if (this.atIndentedComment(it.start, seq.indent)) {
                    const prev = seq.items[seq.items.length - 2];
                    const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                    if (Array.isArray(end)) {
                      Array.prototype.push.apply(end, it.start);
                      end.push(this.sourceToken);
                      seq.items.pop();
                      return;
                    }
                  }
                  it.start.push(this.sourceToken);
                }
                return;
              case "anchor":
              case "tag":
                if (it.value || this.indent <= seq.indent)
                  break;
                it.start.push(this.sourceToken);
                return;
              case "seq-item-ind":
                if (this.indent !== seq.indent)
                  break;
                if (it.value || includesToken(it.start, "seq-item-ind"))
                  seq.items.push({ start: [this.sourceToken] });
                else
                  it.start.push(this.sourceToken);
                return;
            }
            if (this.indent > seq.indent) {
              const bv = this.startBlockValue(seq);
              if (bv) {
                this.stack.push(bv);
                return;
              }
            }
            yield* this.pop();
            yield* this.step();
          }
          *flowCollection(fc) {
            const it = fc.items[fc.items.length - 1];
            if (this.type === "flow-error-end") {
              let top;
              do {
                yield* this.pop();
                top = this.peek(1);
              } while (top && top.type === "flow-collection");
            } else if (fc.end.length === 0) {
              switch (this.type) {
                case "comma":
                case "explicit-key-ind":
                  if (!it || it.sep)
                    fc.items.push({ start: [this.sourceToken] });
                  else
                    it.start.push(this.sourceToken);
                  return;
                case "map-value-ind":
                  if (!it || it.value)
                    fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                  else if (it.sep)
                    it.sep.push(this.sourceToken);
                  else
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  return;
                case "space":
                case "comment":
                case "newline":
                case "anchor":
                case "tag":
                  if (!it || it.value)
                    fc.items.push({ start: [this.sourceToken] });
                  else if (it.sep)
                    it.sep.push(this.sourceToken);
                  else
                    it.start.push(this.sourceToken);
                  return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar": {
                  const fs = this.flowScalar(this.type);
                  if (!it || it.value)
                    fc.items.push({ start: [], key: fs, sep: [] });
                  else if (it.sep)
                    this.stack.push(fs);
                  else
                    Object.assign(it, { key: fs, sep: [] });
                  return;
                }
                case "flow-map-end":
                case "flow-seq-end":
                  fc.end.push(this.sourceToken);
                  return;
              }
              const bv = this.startBlockValue(fc);
              if (bv)
                this.stack.push(bv);
              else {
                yield* this.pop();
                yield* this.step();
              }
            } else {
              const parent = this.peek(2);
              if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
                yield* this.pop();
                yield* this.step();
              } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                  type: "block-map",
                  offset: fc.offset,
                  indent: fc.indent,
                  items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
              } else {
                yield* this.lineEnd(fc);
              }
            }
          }
          flowScalar(type) {
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            return {
              type,
              offset: this.offset,
              indent: this.indent,
              source: this.source
            };
          }
          startBlockValue(parent) {
            switch (this.type) {
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return this.flowScalar(this.type);
              case "block-scalar-header":
                return {
                  type: "block-scalar",
                  offset: this.offset,
                  indent: this.indent,
                  props: [this.sourceToken],
                  source: ""
                };
              case "flow-map-start":
              case "flow-seq-start":
                return {
                  type: "flow-collection",
                  offset: this.offset,
                  indent: this.indent,
                  start: this.sourceToken,
                  items: [],
                  end: []
                };
              case "seq-item-ind":
                return {
                  type: "block-seq",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                };
              case "explicit-key-ind": {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start }]
                };
              }
              case "map-value-ind": {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                };
              }
            }
            return null;
          }
          atIndentedComment(start, indent) {
            if (this.type !== "comment")
              return false;
            if (this.indent <= indent)
              return false;
            return start.every((st) => st.type === "newline" || st.type === "space");
          }
          *documentEnd(docEnd) {
            if (this.type !== "doc-mode") {
              if (docEnd.end)
                docEnd.end.push(this.sourceToken);
              else
                docEnd.end = [this.sourceToken];
              if (this.type === "newline")
                yield* this.pop();
            }
          }
          *lineEnd(token) {
            switch (this.type) {
              case "comma":
              case "doc-start":
              case "doc-end":
              case "flow-seq-end":
              case "flow-map-end":
              case "map-value-ind":
                yield* this.pop();
                yield* this.step();
                break;
              case "newline":
                this.onKeyLine = false;
              case "space":
              case "comment":
              default:
                if (token.end)
                  token.end.push(this.sourceToken);
                else
                  token.end = [this.sourceToken];
                if (this.type === "newline")
                  yield* this.pop();
            }
          }
        };
        exports2.Parser = Parser;
      }
    });
    var require_public_api2 = __commonJS2({
      "node_modules/yaml/dist/public-api.js"(exports2) {
        "use strict";
        var composer = require_composer2();
        var Document = require_Document2();
        var errors = require_errors2();
        var log2 = require_log2();
        var lineCounter = require_line_counter2();
        var parser = require_parser2();
        function parseOptions(options) {
          const prettyErrors = !options || options.prettyErrors !== false;
          const lineCounter$1 = options && options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
          return { lineCounter: lineCounter$1, prettyErrors };
        }
        function parseAllDocuments(source, options = {}) {
          const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
          const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
          const composer$1 = new composer.Composer(options);
          const docs = Array.from(composer$1.compose(parser$1.parse(source)));
          if (prettyErrors && lineCounter2)
            for (const doc of docs) {
              doc.errors.forEach(errors.prettifyError(source, lineCounter2));
              doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
            }
          if (docs.length > 0)
            return docs;
          return Object.assign([], { empty: true }, composer$1.streamInfo());
        }
        function parseDocument(source, options = {}) {
          const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
          const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
          const composer$1 = new composer.Composer(options);
          let doc = null;
          for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
            if (!doc)
              doc = _doc;
            else if (doc.options.logLevel !== "silent") {
              doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
              break;
            }
          }
          if (prettyErrors && lineCounter2) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter2));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
          }
          return doc;
        }
        function parse(src, reviver, options) {
          let _reviver = void 0;
          if (typeof reviver === "function") {
            _reviver = reviver;
          } else if (options === void 0 && reviver && typeof reviver === "object") {
            options = reviver;
          }
          const doc = parseDocument(src, options);
          if (!doc)
            return null;
          doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning));
          if (doc.errors.length > 0) {
            if (doc.options.logLevel !== "silent")
              throw doc.errors[0];
            else
              doc.errors = [];
          }
          return doc.toJS(Object.assign({ reviver: _reviver }, options));
        }
        function stringify(value, replacer, options) {
          let _replacer = null;
          if (typeof replacer === "function" || Array.isArray(replacer)) {
            _replacer = replacer;
          } else if (options === void 0 && replacer) {
            options = replacer;
          }
          if (typeof options === "string")
            options = options.length;
          if (typeof options === "number") {
            const indent = Math.round(options);
            options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
          }
          if (value === void 0) {
            const { keepUndefined } = options || replacer || {};
            if (!keepUndefined)
              return void 0;
          }
          return new Document.Document(value, _replacer, options).toString(options);
        }
        exports2.parse = parse;
        exports2.parseAllDocuments = parseAllDocuments;
        exports2.parseDocument = parseDocument;
        exports2.stringify = stringify;
      }
    });
    var require_dist4 = __commonJS2({
      "node_modules/yaml/dist/index.js"(exports2) {
        "use strict";
        var composer = require_composer2();
        var Document = require_Document2();
        var Schema = require_Schema2();
        var errors = require_errors2();
        var Alias = require_Alias2();
        var Node = require_Node2();
        var Pair = require_Pair2();
        var Scalar = require_Scalar2();
        var YAMLMap = require_YAMLMap2();
        var YAMLSeq = require_YAMLSeq2();
        var options = require_options2();
        var cst = require_cst2();
        var lexer = require_lexer2();
        var lineCounter = require_line_counter2();
        var parser = require_parser2();
        var publicApi = require_public_api2();
        var visit = require_visit2();
        exports2.Composer = composer.Composer;
        exports2.Document = Document.Document;
        exports2.Schema = Schema.Schema;
        exports2.YAMLError = errors.YAMLError;
        exports2.YAMLParseError = errors.YAMLParseError;
        exports2.YAMLWarning = errors.YAMLWarning;
        exports2.Alias = Alias.Alias;
        exports2.isAlias = Node.isAlias;
        exports2.isCollection = Node.isCollection;
        exports2.isDocument = Node.isDocument;
        exports2.isMap = Node.isMap;
        exports2.isNode = Node.isNode;
        exports2.isPair = Node.isPair;
        exports2.isScalar = Node.isScalar;
        exports2.isSeq = Node.isSeq;
        exports2.Pair = Pair.Pair;
        exports2.Scalar = Scalar.Scalar;
        exports2.YAMLMap = YAMLMap.YAMLMap;
        exports2.YAMLSeq = YAMLSeq.YAMLSeq;
        exports2.defaultOptions = options.defaultOptions;
        exports2.CST = cst;
        exports2.Lexer = lexer.Lexer;
        exports2.LineCounter = lineCounter.LineCounter;
        exports2.Parser = parser.Parser;
        exports2.parse = publicApi.parse;
        exports2.parseAllDocuments = publicApi.parseAllDocuments;
        exports2.parseDocument = publicApi.parseDocument;
        exports2.stringify = publicApi.stringify;
        exports2.visit = visit.visit;
      }
    });
    var require_lodash5 = __commonJS2({
      "node_modules/lodash.chunk/index.js"(exports2, module22) {
        var INFINITY = 1 / 0;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAX_INTEGER = 17976931348623157e292;
        var NAN = 0 / 0;
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var symbolTag = "[object Symbol]";
        var reTrim = /^\s+|\s+$/g;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var freeParseInt = parseInt;
        var objectProto = Object.prototype;
        var objectToString = objectProto.toString;
        var nativeCeil = Math.ceil;
        var nativeMax = Math.max;
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function chunk2(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array ? array.length : 0;
          if (!length || size < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
          while (index < length) {
            result[resIndex++] = baseSlice(array, index, index += size);
          }
          return result;
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && typeof value == "object";
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result = toFinite(value), remainder = result % 1;
          return result === result ? remainder ? result - remainder : result : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, "");
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        module22.exports = chunk2;
      }
    });
    __export2(exports, {
      constants: () => constants,
      default: () => noodl_aggregator_default
    });
    var constants_exports = {};
    __export2(constants_exports, {
      APP_CONFIG_DOES_NOT_EXIST: () => APP_CONFIG_DOES_NOT_EXIST,
      DEFAULT_CONFIG_HOSTNAME: () => DEFAULT_CONFIG_HOSTNAME,
      ON_APP_PAGE_DOESNT_EXIST: () => ON_APP_PAGE_DOESNT_EXIST,
      ON_CONFIG_KEY: () => ON_CONFIG_KEY,
      ON_CONFIG_VERSION: () => ON_CONFIG_VERSION,
      ON_PLACEHOLDER_PURGED: () => ON_PLACEHOLDER_PURGED,
      ON_RETRIEVED_APP_CONFIG: () => ON_RETRIEVED_APP_CONFIG,
      ON_RETRIEVED_APP_PAGE: () => ON_RETRIEVED_APP_PAGE,
      ON_RETRIEVED_ROOT_CONFIG: () => ON_RETRIEVED_ROOT_CONFIG,
      ON_RETRIEVE_APP_PAGE_FAILED: () => ON_RETRIEVE_APP_PAGE_FAILED,
      ON_RETRIEVING_APP_CONFIG: () => ON_RETRIEVING_APP_CONFIG,
      ON_RETRIEVING_ROOT_CONFIG: () => ON_RETRIEVING_ROOT_CONFIG,
      PARSED_APP_CONFIG: () => PARSED_APP_CONFIG,
      RETRIEVED_APP_BASE_URL: () => RETRIEVED_APP_BASE_URL,
      RETRIEVED_APP_ENDPOINT: () => RETRIEVED_APP_ENDPOINT,
      RETRIEVED_ROOT_BASE_URL: () => RETRIEVED_ROOT_BASE_URL,
      RETRIEVED_VERSION: () => RETRIEVED_VERSION,
      ROOT_CONFIG_DOES_NOT_EXIST: () => ROOT_CONFIG_DOES_NOT_EXIST
    });
    var DEFAULT_CONFIG_HOSTNAME = "public.aitmed.com";
    var ON_APP_PAGE_DOESNT_EXIST = "ON_APP_PAGE_DOESNT_EXIST";
    var APP_CONFIG_DOES_NOT_EXIST = "APP_CONFIG_DOES_NOT_EXIST";
    var ON_CONFIG_KEY = "ON_CONFIG_KEY";
    var ON_CONFIG_VERSION = "ON_CONFIG_VERSION";
    var ON_PLACEHOLDER_PURGED = "ON_PLACEHOLDER_PURGED";
    var ON_RETRIEVING_ROOT_CONFIG = "ON_RETRIEVING_ROOT_CONFIG";
    var ON_RETRIEVED_ROOT_CONFIG = "ON_RETRIEVED_ROOT_CONFIG";
    var ROOT_CONFIG_DOES_NOT_EXIST = "ROOT_CONFIG_DOES_NOT_EXIST";
    var ON_RETRIEVING_APP_CONFIG = "ON_RETRIEVING_APP_CONFIG";
    var ON_RETRIEVED_APP_CONFIG = "ON_RETRIEVED_APP_CONFIG";
    var RETRIEVED_VERSION = "RETRIEVED_VERSION";
    var RETRIEVED_ROOT_BASE_URL = "RETRIEVED_ROOT_BASE_URL";
    var RETRIEVED_APP_ENDPOINT = "RETRIEVED_APP_ENDPOINT";
    var RETRIEVED_APP_BASE_URL = "RETRIEVED_APP_BASE_URL";
    var ON_RETRIEVED_APP_PAGE = "ON_RETRIEVED_APP_PAGE";
    var ON_RETRIEVE_APP_PAGE_FAILED = "ON_RETRIEVE_APP_PAGE_FAILED";
    var PARSED_APP_CONFIG = "PARSED_APP_CONFIG";
    var u = __toModule2(require_dist3());
    var import_noodl_common = __toModule2(require_dist22());
    var import_flatten = __toModule2(require_flatten());
    var import_path = __toModule2(require("path"));
    var import_noodl_utils = __toModule2(require_dist32());
    var import_invariant = __toModule2(require_invariant());
    var import_axios = __toModule2(require_axios2());
    var import_chalk = __toModule2(require_source());
    var import_yaml2 = __toModule2(require_dist4());
    var import_lodash = __toModule2(require_lodash5());
    var _configKey;
    var _configVersion;
    var _toRootPageKey;
    var _getRootConfig;
    var NoodlAggregator = class {
      constructor(opts) {
        __privateAdd(this, _configKey, "");
        __privateAdd(this, _configVersion, "latest");
        this.cbs = {};
        this.deviceType = "web";
        this.env = "test";
        this.options = {};
        __privateAdd(this, _toRootPageKey, (filepath, ext = ".yml") => import_path.default.posix.basename(filepath, ext.startsWith(".") ? ext : `.${ext}`).replace(/(_en|~\/)/gi, ""));
        __privateAdd(this, _getRootConfig, () => this.root.get(this.configKey));
        if (u.isStr(opts))
          this.configKey = opts;
        else
          u.assign(this.options, opts);
        this.root = new Map([["Global", new import_yaml2.default.Document()]]);
        Object.defineProperty(this.root, "toJSON", {
          value: () => {
            const result = {};
            for (const [name, doc] of this.root) {
              import_yaml2.default.isDocument(doc) && (result[name] = doc.toJSON());
            }
            return result;
          }
        });
      }
      get appConfigUrl() {
        return `${this.baseUrl}${this.appKey}.yml`;
      }
      get appKey() {
        var _a, _b, _c;
        return ((_c = ((_b = (_a = __privateGet(this, _getRootConfig).call(this)) == null ? void 0 : _a.get) == null ? void 0 : _b.call(_a, "cadlMain")) || "") == null ? void 0 : _c.replace(".yml", "")) || "";
      }
      get assetsUrl() {
        var _a, _b;
        return `${((_b = (_a = __privateGet(this, _getRootConfig).call(this)) == null ? void 0 : _a.get) == null ? void 0 : _b.call(_a, "cadlBaseUrl")) || ""}assets/`.replace(`\${cadlBaseUrl}`, this.baseUrl) || "";
      }
      get baseUrl() {
        var _a, _b;
        return ((_b = (_a = __privateGet(this, _getRootConfig).call(this)) == null ? void 0 : _a.get) == null ? void 0 : _b.call(_a, "cadlBaseUrl")) || "";
      }
      get configKey() {
        return __privateGet(this, _configKey);
      }
      set configKey(configKey) {
        __privateSet(this, _configKey, configKey);
        this.emit(ON_CONFIG_KEY, configKey);
      }
      get configVersion() {
        var _a, _b;
        if (__privateGet(this, _configVersion) === "latest") {
          return ((_b = (_a = __privateGet(this, _getRootConfig).call(this)) == null ? void 0 : _a.getIn) == null ? void 0 : _b.call(_a, [
            this.deviceType,
            "cadlVersion",
            this.env
          ])) || "";
        }
        return __privateGet(this, _configVersion);
      }
      set configVersion(configVersion) {
        __privateSet(this, _configVersion, configVersion);
      }
      get pageNames() {
        const appConfig = this.root.get(this.appKey);
        const preloadPages = (appConfig == null ? void 0 : appConfig.get("preload")).toJSON();
        const pages = (appConfig == null ? void 0 : appConfig.get("page")).toJSON();
        return [...preloadPages, ...pages];
      }
      emit(event, args) {
        var _a, _b;
        (_b = (_a = this.cbs[event]) == null ? void 0 : _a.forEach) == null ? void 0 : _b.call(_a, (fn) => fn(args));
      }
      extractAssets({ remote = true } = {}) {
        const assets = [];
        const commonUrlKeys = ["path", "resource"];
        const visitedAssets = [];
        const addAsset = (assetPath) => {
          if (!visitedAssets.includes(assetPath) && (0, import_noodl_utils.isValidAsset)(assetPath)) {
            if (!remote && assetPath.startsWith("http"))
              return;
            visitedAssets.push(assetPath);
            const linkStructure = (0, import_noodl_common.getLinkStructure)(assetPath, {
              prefix: this.assetsUrl,
              config: this.configKey
            });
            assets.push(linkStructure);
          }
        };
        for (const visitee of this.root.values()) {
          import_yaml2.default.visit(visitee, {
            Map(key, node) {
              commonUrlKeys.forEach((key2) => {
                if (node.has(key2)) {
                  const value = node.get(key2);
                  u.isStr(value) && addAsset(value);
                }
              });
            },
            Pair(key, node) {
              commonUrlKeys.forEach((key2) => {
                if (import_yaml2.default.isScalar(node.key) && u.isStr(node.key.value)) {
                  if (node.key.value === key2) {
                    addAsset(node.value.value);
                  }
                }
              });
            }
          });
        }
        return assets;
      }
      getConfigVersion(doc = this.root.get(this.configKey)) {
        return doc == null ? void 0 : doc.getIn([
          this.deviceType,
          "cadlVersion",
          this.env
        ]);
      }
      getPageUrl(pathname) {
        return pathname ? `${this.baseUrl}${pathname}` : "";
      }
      getRawRootConfigYml() {
        return this.root.get(`${this.configKey}_raw`);
      }
      getRawAppConfigYml() {
        return this.root.get(`${this.appKey}_raw`);
      }
      init() {
        return __async(this, arguments, function* ({
          fallback,
          loadPages: shouldLoadPages = true,
          loadPreloadPages: shouldLoadPreloadPages = true
        } = {}) {
          (0, import_invariant.default)(!!this.configKey, `Cannot initiate the aggregator without setting a config key first`);
          const result = {
            doc: {
              root: yield this.loadRootConfig(),
              app: yield this.loadAppConfig({ fallback: fallback == null ? void 0 : fallback.appConfig })
            },
            raw: {
              root: this.getRawRootConfigYml(),
              app: this.getRawAppConfigYml()
            }
          };
          shouldLoadPreloadPages && (yield this.loadPreloadPages());
          shouldLoadPages && (yield this.loadPages());
          return result;
        });
      }
      loadRootConfig() {
        return __async(this, arguments, function* (configName = this.configKey) {
          let configDoc;
          let configYml = "";
          if (import_yaml2.default.isDocument(configName)) {
            configDoc = configName;
            configName = this.configKey;
          } else if (u.isStr(configName)) {
            this.configKey = configName;
          }
          (0, import_invariant.default)(!!configName, `Cannot retrieve the root config because a config key was not passed in or set`);
          if (configDoc) {
            configYml = (0, import_noodl_common.stringifyDoc)(configDoc);
          } else {
            const configUrl = `https://${DEFAULT_CONFIG_HOSTNAME}/config/${(0, import_noodl_common.withYmlExt)(configName)}`;
            this.emit(ON_RETRIEVING_ROOT_CONFIG, { url: configUrl });
            const { data: yml } = yield import_axios.default.get(configUrl);
            configDoc = import_yaml2.default.parseDocument(yml);
            configYml = yml;
          }
          this.root.set(this.configKey, configDoc);
          this.root.set(`${this.configKey}_raw`, configYml);
          this.emit(ON_RETRIEVED_ROOT_CONFIG, {
            name: this.configKey,
            doc: configDoc,
            yml: configYml
          });
          this.configVersion = this.getConfigVersion(configDoc);
          this.emit(ON_CONFIG_VERSION, this.configVersion);
          const replacePlaceholders = (0, import_noodl_utils.createNoodlPlaceholderReplacer)({
            cadlBaseUrl: configDoc.get("cadlBaseUrl"),
            cadlVersion: this.configVersion,
            designSuffix: ""
          });
          import_yaml2.default.visit(configDoc, {
            Pair: (key, node) => {
              if (import_yaml2.default.isScalar(node.key) && node.key.value === "cadlBaseUrl") {
                if (import_yaml2.default.isScalar(node.value) && u.isStr(node.value) && (0, import_noodl_utils.hasNoodlPlaceholder)(node.value)) {
                  const before = node.value.value;
                  node.value.value = replacePlaceholders(node.value.value);
                  this.emit(ON_PLACEHOLDER_PURGED, {
                    before,
                    after: node.value.value
                  });
                  return import_yaml2.default.visit.SKIP;
                }
              }
            },
            Scalar: (key, node) => {
              if (u.isStr(node.value) && (0, import_noodl_utils.hasNoodlPlaceholder)(node.value)) {
                const before = node.value;
                node.value = replacePlaceholders(node.value);
                this.emit(ON_PLACEHOLDER_PURGED, {
                  before,
                  after: node.value
                });
              }
            }
          });
          return configDoc;
        });
      }
      loadAppConfig() {
        return __async(this, arguments, function* ({
          fallback
        } = {}) {
          (0, import_invariant.default)(!!this.root.get(this.configKey), "Cannot initiate app config without retrieving the root config");
          this.emit(ON_RETRIEVING_APP_CONFIG, { url: this.appConfigUrl });
          let appConfigYml = "";
          let appConfigDoc;
          let yml = "";
          try {
            yml = (yield import_axios.default.get(this.appConfigUrl)).data;
          } catch (error) {
            console.error(`[${import_chalk.default.red("Error")}] ${import_chalk.default.yellow("loadAppConfig")}: ${error.message}. If a fallback loader was provided, it will be used. Otherwise the app config will be undefined`, { fallbackProvided: u.isFnc(fallback) });
            u.isFnc(fallback) && (yml = yield fallback());
          }
          this.emit(ON_RETRIEVED_APP_CONFIG, appConfigYml = yml);
          this.root.set(`${this.appKey}_raw`, appConfigYml);
          appConfigYml && (appConfigDoc = import_yaml2.default.parseDocument(appConfigYml));
          appConfigDoc && this.root.set(this.appKey, appConfigDoc);
          this.emit(PARSED_APP_CONFIG, {
            name: this.appKey,
            doc: appConfigDoc
          });
          return appConfigDoc;
        });
      }
      loadPage(name = "", doc) {
        return __async(this, null, function* () {
          var _a;
          try {
            const key = __privateGet(this, _toRootPageKey).call(this, name);
            if (u.isStr(name)) {
              const pageUrl = this.getPageUrl(`${key}_en.yml`);
              const { data: yml } = yield import_axios.default.get(pageUrl);
              this.root.set(key, doc = import_yaml2.default.parseDocument(yml));
            } else if (name && import_yaml2.default.isDocument(doc)) {
              this.root.set(key, doc);
            } else {
              u.log(u.red(`Page "${name}" was not loaded because of bad parameters`));
            }
            if (name) {
              this.emit(ON_RETRIEVED_APP_PAGE, { name, doc });
              return this.root.get(key || "");
            }
          } catch (error) {
            if (error instanceof Error) {
              if (((_a = error.response) == null ? void 0 : _a.status) === 404) {
                console.log(`[${import_chalk.default.red(error.name)}]: Could not find page ${u.red(name || "")}`);
                this.emit(ON_APP_PAGE_DOESNT_EXIST, { name, error });
              } else {
                console.log(`[${import_chalk.default.yellow(error.name)}] on page ${u.red(name || "")}: ${error.message}`);
              }
              this.emit(ON_RETRIEVE_APP_PAGE_FAILED, {
                name,
                error
              });
            }
          }
        });
      }
      loadPreloadPages() {
        return __async(this, arguments, function* (preloadPages = []) {
          var _a;
          if (preloadPages.length) {
          } else {
            const seq = (_a = this.root.get(this.appKey)) == null ? void 0 : _a.get("preload");
            if (import_yaml2.default.isSeq(seq)) {
              for (const node of seq.items) {
                if (import_yaml2.default.isScalar(node) && u.isStr(node.value)) {
                  preloadPages.push(node.value);
                }
              }
            }
          }
          return yield (0, import_noodl_common.promiseAllSafe)(...preloadPages.map((page) => __async(this, null, function* () {
            return this.loadPage(page);
          })));
        });
      }
      loadPages() {
        return __async(this, arguments, function* ({
          chunks = 4
        } = {}) {
          var _a;
          const pages = [];
          const nodes = (_a = this.root.get(this.appKey)) == null ? void 0 : _a.get("page");
          if (import_yaml2.default.isSeq(nodes)) {
            for (const node of nodes.items) {
              if (import_yaml2.default.isScalar(node) && u.isStr(node.value)) {
                pages.push(node.value);
              }
            }
          }
          const chunkedPages = (0, import_lodash.default)(pages, chunks);
          const allPages = yield Promise.all(chunkedPages.map((chunked) => Promise.all(chunked.map((c2) => this.loadPage(c2)))));
          return (0, import_flatten.default)(allPages);
        });
      }
      on(evt, fn) {
        var _a;
        !u.isArr(this.cbs[evt]) && (this.cbs[evt] = []);
        (_a = this.cbs[evt]) == null ? void 0 : _a.push(fn);
        return this;
      }
    };
    _configKey = new WeakMap();
    _configVersion = new WeakMap();
    _toRootPageKey = new WeakMap();
    _getRootConfig = new WeakMap();
    var noodl_aggregator_default = NoodlAggregator;
    var constants = constants_exports;
  }
});

// src/functions/metadata.ts
__export(exports, {
  handler: () => handler
});
var import_yaml = __toModule(require_dist());
var import_noodl_aggregator = __toModule(require_dist2());
var handler = async (event, context) => {
  try {
    const { queryStringParameters, rawUrl } = event;
    const params = queryStringParameters;
    console.log({ params });
    const aggregator = new import_noodl_aggregator.default();
    const configName = params?.config;
    if (configName) {
      aggregator.configKey = configName;
      const {
        doc: { root: rootDoc, app: appDoc },
        raw: { root: rootYml, app: appYml }
      } = await aggregator.init({
        loadPages: true,
        loadPreloadPages: true
      });
      const actionObjects = [];
      for (const [name, doc] of aggregator.root) {
        import_yaml.default.visit(doc, {
          Scalar() {
          },
          Pair(key, node, path) {
            if (key === "key" && import_yaml.default.isScalar(node.key) && node.key.value === "actionType") {
              actionObjects.push(node.toJSON());
              return import_yaml.default.visit.SKIP;
            }
          },
          Map() {
          },
          Seq() {
          },
          Value() {
          }
        });
      }
      console.log(actionObjects);
    } else {
    }
    return {
      statusCode: 200,
      body: ""
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({
        code: error.code,
        name: error.name,
        message: error.message
      }, null, 2)
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
